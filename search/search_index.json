{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Latent Calendar","text":"<p>Analyze and model data on a weekly calendar</p>"},{"location":"#installation","title":"Installation","text":"<p>Install from PyPI:</p> <pre><code>pip install latent-calendar\n</code></pre> <p>Or install directly from GitHub for the latest functionality.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>DataFrame agnostic transformations and aggregation powered by <code>narwhals</code></li> <li>Integrated automatically into <code>pandas</code> and <code>polars</code> with <code>cal</code> attribute on DataFrame and Series</li> <li>Compatible with <code>scikit-learn</code> pipelines and transformers</li> <li>Transform and visualize data on a weekly calendar</li> <li>Model weekly calendar data with a mixture of calendars</li> <li>Create lower dimensional representations of calendar data</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import pandas as pd\n\nfrom latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar import LatentCalendar\nfrom latent_calendar.plot import plot_model_components\n\nimport matplotlib.pyplot as plt\n\ndf_trips: pd.DataFrame = load_chicago_bikes()\ndf_stations = df_trips.cal.aggregate_events(\"start_station_name\", \"started_at\", minutes=60, widen=True)\n\nmodel = LatentCalendar(n_components=10, random_state=42)\nmodel.fit(df_stations)\n\norder = model.component_distribution_.argsort()[::-1]\nplot_model_components(model, components=order)\nfirst_date, last_date = df_trips[\"started_at\"].min().date(), df_trips[\"started_at\"].max().date()\ntitle = f\"Trip behavior between {first_date} and {last_date} (ordered by component frequency)\"\nplt.suptitle(title)\n</code></pre>"},{"location":"draft/","title":"Draft","text":""},{"location":"draft/#1-transform-and-visualize","title":"1. Transform and visualize","text":"<p>Transform and visualize data on a weekly calendar with the <code>cal</code> attribute of DataFrames.</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_chicago_bikes\n\ndf = load_chicago_bikes()\ndf_member_casual = df.cal.aggregate_events(\"member_casual\", timestamp_col=\"started_at\")\n\n(\n    df_member_casual\n    .cal.divide_by_max()\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Bike Rentals by Member Type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"draft/#2-find-latent-structure","title":"2. Find latent structure","text":"<p>The <code>LatentCalendar</code> models calendar data by breaking down each calendar into a mixture of <code>n_components</code> calendars. Read more on the methodology here.</p> <pre><code>from latent_calendar import LatentCalendar\nfrom latent_calendar.plot import plot_model_components\n\ndf_stations = df.cal.aggregate_events(\"start_station_name\", timestamp_col=\"started_at\")\n\nmodel = LatentCalendar(n_components=3, random_state=42)\nmodel.fit(df_wide)\n\nplot_model_components(model)\nfig = plt.gcf()\nfig.suptitle(\"Chicago Bike Rental Model Components\")\nplt.show()\n</code></pre> <p></p>"},{"location":"draft/#3-recover-components-and-distributions","title":"3. Recover components and distributions","text":"<p>The <code>LatentCalendar</code> provides soft clusters for each row which can be recovered with the <code>transform</code> method.</p> <pre><code>df_component_probs = df_stations.cal.transform(model=model)\n\nhist_kwargs = dict(bins=10, edgecolor=\"black\", grid=False, layout=(1, 3))\naxes = df_component_probs.hist(**hist_kwargs)\naxes = axes.ravel()\nfor ax in axes:\n    ax.set_xlabel(\"Probability\")\n    title = ax.get_title()\n    ax.set_title(f\"Component {title}\")\naxes[0].set_ylabel(\"# Stations\")\nfig = plt.gcf()\nfig.suptitle(\"Station Component Distributions\")\nplt.show()\n</code></pre> <p></p> <p>The <code>predict</code> method recovers the joint distribution of the calendar data using the latent calendar components.</p> <pre><code>stations = [\"Wood St &amp; Milwaukee Ave\", \"Theater on the Lake\", \"Wabash Ave &amp; Grand Ave\"]\ndf_stations.loc[stations].cal.plot_profile()\nplt.show()\n</code></pre> <p></p>"},{"location":"methodology/","title":"Methodology","text":""},{"location":"methodology/#multinomial-distribution-from-events-on-calendar","title":"Multinomial Distribution from Events on Calendar","text":"<p>With \\(D = \\text{Day of Week}\\) with \\(d \\in \\{\\text{Monday}, \\text{Tuesday}, ..., \\text{Sunday}\\}\\) and \\(T = \\text{Time of Day}\\) with \\(t \\in [0, 24)\\), we are interested in the joint distribution of the \\(P(D=d, T=t)\\).</p> <p>However, if we discretize \\(T\\) into \\(H = \\text{Hour of Day}\\) which takes values \\(h \\in \\{0, 1, 2, ..., 23\\}\\), we get a discrete approximation of the distribution, \\(P[D=d, H=h]\\)</p> <p></p> <p>Introducing the number of events, \\(N\\), we can express this quantity as</p> \\[P[D=d, H=h] = \\sum_{n=0}^{\\infty} P[N=n] \\times P[D=d, H=h | N=n]\\] <p>having</p> \\[\\sum_{d, h \\in D \\times H} N(d, h) = n\\] <p>where \\(N(d, h)\\) is the number of events at \\(D=d\\), \\(H=h\\).</p> <p>This is two quantities now:</p> <ol> <li>How many events will happen: \\(P[N=n]\\)</li> <li>When on the calendar will these events happen: \\(P[D=d, H=h | N=n]\\)</li> </ol> <p>But since the day of week and time of day make up a discrete space of \"time slots\", we can use the multinomial distribution to model quantity 2.</p> <p></p>"},{"location":"methodology/#linking-to-latent-dirichlet-allocation","title":"Linking to Latent Dirichlet Allocation","text":"<p>The generative model for Latent Dirichlet Allocation is a mixture of multinomial distributions allowing us to introduce \\(c\\) calendar distributions.</p> \\[P[D=d, H=h | N=n] = \\sum_{l=1}^c P[L=l | N=n] \\times P[D=d, H=h | L=l, N=n]\\] <ol> <li>\\(P[L=l | N=n]\\) is the probability of being latent component</li> <li>\\(P[D=d, H=h | L=l, N=n]\\) is the calendar from latent component \\(l\\)</li> </ol> <p>By introducing latent calendar distributions, we introduce correlations between the time slots.</p>"},{"location":"examples/cal-attribute/","title":"Pandas and Polars Extensions","text":"<p>Transform and visualize data on a weekly calendar with the <code>cal</code> attribute of DataFrames.</p>"},{"location":"examples/cal-attribute/#event-level-data","title":"Event Level Data","text":"<pre><code>import pandas as pd\nimport polars as pl\n\nimport matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_chicago_bikes\n\ndf: pd.DataFrame = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                 start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre>"},{"location":"examples/cal-attribute/#aggregation","title":"Aggregation","text":"<p>Aggregate event level data into can be done with the <code>cal.aggregate_events</code> method.</p> <pre><code>df_polars = pl.from_pandas(df)\n\ndf_agg = df_polars.cal.aggregate_events(\"member_casual\", \"started_at\")\n</code></pre> <pre><code>shape: (336, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 member_casual \u2506 day_of_week \u2506 hour \u2506 num_events \u2502\n\u2502 ---           \u2506 ---         \u2506 ---  \u2506 ---        \u2502\n\u2502 str           \u2506 i8          \u2506 i64  \u2506 i32        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 casual        \u2506 6           \u2506 11   \u2506 1003       \u2502\n\u2502 casual        \u2506 2           \u2506 5    \u2506 106        \u2502\n\u2502 casual        \u2506 5           \u2506 23   \u2506 926        \u2502\n\u2502 member        \u2506 2           \u2506 15   \u2506 1413       \u2502\n\u2502 member        \u2506 4           \u2506 4    \u2506 57         \u2502\n\u2502 \u2026             \u2506 \u2026           \u2506 \u2026    \u2506 \u2026          \u2502\n\u2502 member        \u2506 4           \u2506 2    \u2506 63         \u2502\n\u2502 member        \u2506 6           \u2506 16   \u2506 1247       \u2502\n\u2502 member        \u2506 3           \u2506 16   \u2506 2101       \u2502\n\u2502 member        \u2506 3           \u2506 13   \u2506 1311       \u2502\n\u2502 member        \u2506 4           \u2506 1    \u2506 135        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/cal-attribute/#calendar-data","title":"Calendar Data","text":"<p>The aggregate event level data into wide format calendar data with the <code>cal.widen</code> method. This results in 7 * 24 = 168 columns, one for each hour of the week.</p> <pre><code>df_member_casual = (\n    df_agg\n    .to_pandas()\n    .set_index([\"member_casual\", \"day_of_week\", \"hour\"])\n    .cal.widen(\"num_events\")\n)\n</code></pre> <pre><code>day_of_week      0                              ...     6\nhour            0    1    2   3   4    5    6   ...    17    18    19    20   21   22   23\nmember_casual                                   ...\ncasual         250  137  102  55  47   99  231  ...  1287  1195  1165   980  774  488  331\nmember         165   89   74  52  59  273  838  ...  1307  1355  1251  1137  800  505  294\n\n[2 rows x 168 columns]\n</code></pre>"},{"location":"examples/cal-attribute/#visualize-calendar-data","title":"Visualize Calendar Data","text":"<p>Various plot methods are available on the <code>cal</code> attribute of DataFrames. For instance, the <code>plot_by_row</code> plots each row of the wide format calendar data as a separate calendar.</p> <p>Custom color maps can be passed, but normalizing each row by the maximum value also does the trick.</p> <pre><code>(\n    df_member_casual\n    .cal.divide_by_max()\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Bike Rentals by Member Type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/create-segments/","title":"Create segments","text":"<p>Create some segments for a calendar:</p> <pre><code>import pandas as pd\nimport numpy as np\n\nfrom latent_calendar.segments import create_box_segment, stack_segments\n\nmornings = create_box_segment(\n    day_start=0, day_end=7, hour_start=6, hour_end=11, name=\"Mornings\"\n)\nafternoons = create_box_segment(\n    day_start=0, day_end=7, hour_start=11, hour_end=16, name=\"Afternoons\"\n)\nevenings = create_box_segment(\n    day_start=0, day_end=7, hour_start=16, hour_end=21, name=\"Evenings\"\n)\n\ndf_segments = stack_segments([\n    mornings,\n    afternoons,\n    evenings,\n])\n\ndf_segments.cal.plot_by_row()\n</code></pre> <p></p> <p>These can be used to sum over for analysis of counts or probabilities by segment.</p> <pre><code>nrows = 10\nncols = len(df_segments.columns)\n\ndf = pd.DataFrame(np.ones((nrows, ncols)))\n\ndf_summed = df.cal.sum_over_segments(df_segments)\ndf_summed\n</code></pre> <pre><code>   Mornings  Afternoons  Evenings\n0      35.0        35.0      35.0\n1      35.0        35.0      35.0\n2      35.0        35.0      35.0\n3      35.0        35.0      35.0\n4      35.0        35.0      35.0\n5      35.0        35.0      35.0\n6      35.0        35.0      35.0\n7      35.0        35.0      35.0\n8      35.0        35.0      35.0\n9      35.0        35.0      35.0\n</code></pre>"},{"location":"examples/folium-integration/","title":"Folium Integration","text":"<p>The <code>latent-calendar</code> library provides seamless integration with Folium to display interactive calendar heatmaps as map popups. This is perfect for visualizing temporal patterns across geographic locations.</p>"},{"location":"examples/folium-integration/#installation","title":"Installation","text":"<p>To use the Folium integration, install the library with the optional dependencies:</p> <pre><code>pip install latent-calendar[html,folium]\n</code></pre> <p>This installs:</p> <ul> <li><code>altair&gt;=5.0.0</code> - For generating interactive HTML calendar charts</li> <li><code>folium&gt;=0.14.0</code> - For creating interactive maps</li> </ul>"},{"location":"examples/folium-integration/#quick-start","title":"Quick Start","text":"<p>Here's a minimal example showing UFO sightings in California:</p> <pre><code>import folium\nfrom latent_calendar.datasets import load_ufo_sightings\nfrom latent_calendar.integrations.folium import create_calendar_popup\n\n# 1. Load and aggregate data by state\ndf = load_ufo_sightings()\ndf_states = df[df['country'] == 'us'].cal.aggregate_events(\n    by='state/province',\n    timestamp_col='Date_time'\n)\n\n# 2. Get California's weekly pattern (168 values)\ncalifornia_data = df_states.loc['ca']\n\n# 3. Create an interactive popup\npopup = create_calendar_popup(\n    california_data,\n    title=\"California UFO Sightings\",\n    width=400,\n    height=280,\n    color_scheme='blues'\n)\n\n# 4. Add to map\nm = folium.Map(location=[36.7, -119.7], zoom_start=6)\nfolium.Marker(\n    location=[36.7, -119.7],\n    popup=popup,\n    tooltip=\"Click to see calendar\"\n).add_to(m)\n\nm.save('california_ufos.html')\n</code></pre>"},{"location":"examples/folium-integration/#understanding-the-data-format","title":"Understanding the Data Format","text":"<p>The Folium integration works with the wide format produced by <code>.cal.aggregate_events()</code>:</p> <ul> <li>Input: A Series or DataFrame row with 168 values (7 days \u00d7 24 hours)</li> <li>Calendar columns: Multi-index with <code>(day_of_week, hour)</code> pairs</li> <li>Values: Event counts or any numeric data for each time slot</li> </ul> <p>Example: <pre><code>&gt;&gt;&gt; df_states.loc['ca']\nday_of_week  hour\n0            0       45\n             1       32\n             ...\n6            23      67\nName: ca, dtype: int64\n</code></pre></p>"},{"location":"examples/folium-integration/#api-overview","title":"API Overview","text":"<p>The integration provides four main functions:</p> <ul> <li><code>create_calendar_popup()</code> - Creates interactive popups (most common)</li> <li><code>create_calendar_tooltip()</code> - Creates compact hover tooltips</li> <li><code>create_popup_html()</code> - Generates HTML strings (advanced)</li> <li><code>create_tooltip_html()</code> - Generates tooltip HTML (advanced)</li> </ul> <p>For complete API documentation with all parameters and options, see the Folium Integration API Reference.</p>"},{"location":"examples/folium-integration/#complete-example-ufo-sightings-map","title":"Complete Example: UFO Sightings Map","text":"<p>This example shows the recommended workflow - aggregating UFO sightings by state and displaying them on an interactive map with calendar popups. The complete code is available in <code>examples/folium_ufo_sightings.py</code>.</p> <p>Requirements: <pre><code>pip install latent-calendar[html,folium] requests us\n</code></pre></p> <p>Complete code:</p> <pre><code>\"\"\"Interactive map showing weekly UFO sighting patterns by state.\"\"\"\nimport folium\nimport requests\nimport us  # For state name/abbreviation mapping\nfrom latent_calendar.datasets import load_ufo_sightings\nfrom latent_calendar.integrations.folium import create_calendar_popup\n\n# 1. Load and aggregate UFO sightings by state\nprint(\"Loading UFO sightings data...\")\ndf = load_ufo_sightings()\n\n# Filter to US sightings and clean state codes\ndf_us = df[df['country'] == 'us'].copy()\ndf_us['state/province'] = df_us['state/province'].str.lower().str.strip()\n\n# Aggregate to weekly calendar format (7 days \u00d7 24 hours = 168 time slots)\ndf_states = df_us.cal.aggregate_events(\n    by='state/province',\n    timestamp_col='Date_time'\n)\nprint(f\"Aggregated data for {len(df_states)} states\")\n\n# Calculate total sightings per state for choropleth coloring\nstate_totals = df_states.sum(axis=1).to_dict()\n\n# 2. Load US states GeoJSON\nprint(\"Fetching US states GeoJSON...\")\ngeojson_url = 'https://raw.githubusercontent.com/python-visualization/folium-example-data/main/us_states.json'\ngeo_data = requests.get(geojson_url).json()\n\n# 3. Create map centered on US\nm = folium.Map(location=[37.8, -96], zoom_start=4, tiles='cartodbpositron')\n\n# 4. Add calendar popup to each state polygon\nprint(\"Adding state popups...\")\nfor feature in geo_data['features']:\n    state_name = feature['properties']['name']\n\n    # Convert state name to abbreviation\n    state_obj = us.states.lookup(state_name)\n\n    if state_obj:\n        state_abbr = state_obj.abbr.lower()\n\n        if state_abbr in df_states.index:\n            # State has data - create calendar popup\n            calendar_data = df_states.loc[state_abbr]\n            total = int(state_totals[state_abbr])\n\n            popup = create_calendar_popup(\n                calendar_data,\n                title=f\"UFO Sightings in {state_name}\",\n                width=400,\n                height=280,\n                color_scheme='blues',\n                show_values=False  # Faster rendering\n            )\n\n            # Color by total sightings\n            if total &gt; 5000:\n                fill_color = '#08519c'  # Dark blue\n            elif total &gt; 1000:\n                fill_color = '#3182bd'\n            else:\n                fill_color = '#9ecae1'  # Light blue\n\n            folium.GeoJson(\n                feature,\n                style_function=lambda x, color=fill_color: {\n                    'fillColor': color,\n                    'fillOpacity': 0.6,\n                    'color': 'black',\n                    'weight': 1\n                },\n                popup=popup,\n                tooltip=state_name\n            ).add_to(m)\n\n# 5. Save map\nm.save('ufo_sightings_map.html')\n</code></pre> <p>What this creates:</p> <ul> <li>Click any state to see its weekly UFO sighting pattern</li> <li>States are colored by total sightings (darker = more sightings)</li> <li>Calendar heatmap shows day-of-week vs hour-of-day patterns</li> <li>Hover to see state names</li> </ul> <p> Example: Clicking on Washington shows evening spikes in UFO sightings (8-11 PM)</p> <p>Customization tips:</p> <ul> <li>Change <code>color_scheme='blues'</code> to <code>'viridis'</code>, <code>'greens'</code>, etc.</li> <li>Set <code>show_values=True</code> to display counts in calendar cells</li> <li>Adjust <code>width</code> and <code>height</code> for different popup sizes</li> <li>Use <code>monday_start=False</code> for Sunday-first weeks</li> </ul>"},{"location":"examples/folium-integration/#simple-marker-example","title":"Simple Marker Example","text":"<p>For a quick test with a single location:</p> <pre><code>import folium\nfrom latent_calendar.datasets import load_ufo_sightings\nfrom latent_calendar.integrations.folium import create_calendar_popup\n\n# Aggregate by state\ndf = load_ufo_sightings()\ndf_states = df[df['country'] == 'us'].cal.aggregate_events(\n    by='state/province',\n    timestamp_col='Date_time'\n)\n\n# Create popup for California\npopup = create_calendar_popup(\n    df_states.loc['ca'],\n    title=\"California UFO Sightings\",\n    color_scheme='blues'\n)\n\n# Add to map\nm = folium.Map(location=[36.7, -119.7], zoom_start=6)\nfolium.Marker([36.7, -119.7], popup=popup).add_to(m)\nm.save('california_map.html')\n</code></pre> <p> Simple marker showing California's UFO sighting pattern - notice the evening peak on Saturday nights</p>"},{"location":"examples/folium-integration/#performance-optimization","title":"Performance Optimization","text":"<p>For maps with many popups, consider these optimizations:</p>"},{"location":"examples/folium-integration/#1-reduce-chart-dimensions","title":"1. Reduce Chart Dimensions","text":"<pre><code>popup = create_calendar_popup(\n    data,\n    width=350,   # Smaller than default 500\n    height=250   # Smaller than default 350\n)\n</code></pre>"},{"location":"examples/folium-integration/#2-hide-cell-values","title":"2. Hide Cell Values","text":"<pre><code>popup = create_calendar_popup(\n    data,\n    show_values=False  # Removes text labels from cells\n)\n</code></pre>"},{"location":"examples/folium-integration/#3-disable-interactivity-if-not-needed","title":"3. Disable Interactivity (if not needed)","text":"<pre><code>popup = create_calendar_popup(\n    data,\n    interactive=False  # Removes zoom/pan controls\n)\n</code></pre> <p>Example Results: - 50 US states with full interactivity: ~880 KB - 50 states with <code>show_values=False</code>: ~870 KB - 50 states with smaller dimensions: ~750 KB</p>"},{"location":"examples/folium-integration/#use-cases","title":"Use Cases","text":""},{"location":"examples/folium-integration/#1-geographic-time-series-analysis","title":"1. Geographic Time-Series Analysis","text":"<p>Visualize how temporal patterns vary across locations (e.g., crime patterns by neighborhood, sales patterns by store location).</p>"},{"location":"examples/folium-integration/#2-event-distribution-maps","title":"2. Event Distribution Maps","text":"<p>Show when and where events occur throughout the week (e.g., taxi pickups, bike rentals, restaurant reservations).</p>"},{"location":"examples/folium-integration/#3-operational-analytics","title":"3. Operational Analytics","text":"<p>Display operational patterns for facilities or regions (e.g., call center activity, manufacturing output, customer service requests).</p>"},{"location":"examples/folium-integration/#4-research-visualization","title":"4. Research Visualization","text":"<p>Present research findings with interactive geographic context (e.g., social media activity, environmental sensors, mobile app usage).</p>"},{"location":"examples/folium-integration/#advanced-customization","title":"Advanced Customization","text":""},{"location":"examples/folium-integration/#custom-color-schemes","title":"Custom Color Schemes","text":"<p>Use any Altair/Vega color scheme: <pre><code># Sequential schemes\ncolor_scheme='blues', 'greens', 'reds', 'purples', 'greys', 'oranges'\n\n# Perceptual schemes\ncolor_scheme='viridis', 'plasma', 'inferno', 'magma', 'cividis'\n\n# Diverging schemes\ncolor_scheme='redblue', 'redgrey', 'blueorange'\n</code></pre></p>"},{"location":"examples/folium-integration/#sunday-week-start","title":"Sunday Week Start","text":"<pre><code>popup = create_calendar_popup(\n    data,\n    monday_start=False  # Week starts on Sunday\n)\n</code></pre>"},{"location":"examples/folium-integration/#multiple-popups-on-same-map","title":"Multiple Popups on Same Map","text":"<pre><code>for location, data in zip(locations, datasets):\n    popup = create_calendar_popup(data, title=location)\n    folium.Marker(location, popup=popup).add_to(map)\n</code></pre>"},{"location":"examples/folium-integration/#technical-details","title":"Technical Details","text":""},{"location":"examples/folium-integration/#how-it-works","title":"How It Works","text":"<p>The integration uses three key technologies:</p> <ol> <li>Altair: Generates interactive Vega-Lite charts as standalone HTML documents</li> <li>Folium IFrame: Embeds HTML documents using base64 encoding</li> <li>Calendar Grid: Transforms 168-value wide format into 7\u00d724 heatmap</li> </ol> <p>Data Flow: <pre><code>User Data \u2192 .cal.aggregate_events() \u2192 168 columns\n\u2192 wide_to_long_format() \u2192 Altair Chart \u2192 HTML Document\n\u2192 folium.IFrame \u2192 folium.Popup\n</code></pre></p>"},{"location":"examples/folium-integration/#the-iframe-solution","title":"The IFrame Solution","text":"<p>The implementation uses <code>folium.IFrame</code> to properly embed full HTML documents:</p> <pre><code>iframe = folium.IFrame(html, width=max_width, height=height+80)\npopup = folium.Popup(iframe, max_width=max_width)\n</code></pre> <p>This creates proper isolation between the map's HTML and the chart's HTML, preventing rendering issues in browsers.</p>"},{"location":"examples/folium-integration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/folium-integration/#issue-raw-javascript-visible-in-popup","title":"Issue: Raw JavaScript visible in popup","text":"<p>Cause: Old implementation passed HTML directly to <code>folium.Popup()</code> Solution: Update to latest version that uses <code>folium.IFrame</code></p>"},{"location":"examples/folium-integration/#issue-chart-not-displaying","title":"Issue: Chart not displaying","text":"<p>Cause: Missing optional dependencies Solution: <code>pip install latent-calendar[html,folium]</code></p>"},{"location":"examples/folium-integration/#issue-calendar-has-wrong-dimensions","title":"Issue: Calendar has wrong dimensions","text":"<p>Cause: Data not in 168-column format Solution: Ensure data comes from <code>.cal.aggregate_events()</code> with default parameters</p>"},{"location":"examples/folium-integration/#issue-popup-too-small","title":"Issue: Popup too small","text":"<p>Cause: Default <code>max_width</code> is too small Solution: Increase <code>max_width</code> parameter: <pre><code>popup = create_calendar_popup(data, max_width=800)\n</code></pre></p>"},{"location":"examples/folium-integration/#see-also","title":"See Also","text":"<ul> <li>Folium Integration API Reference - Complete API documentation</li> <li>HTML Module Reference - Low-level HTML generation functions</li> <li><code>.cal</code> Accessor - Core API for data aggregation</li> <li>UFO Sightings Dataset - Example dataset used in examples</li> <li>Folium Documentation - Official Folium docs</li> <li>Altair Color Schemes - Available color palettes</li> </ul>"},{"location":"examples/generation-process/","title":"Generation process","text":"<p>Some sample data can be generated with the <code>sample_from_lda</code> function. More to come!</p>"},{"location":"examples/datasets/bikes-in-chicago/","title":"Bikes in Chicago","text":"<p>The Chicago dataset is bike trips in the city of Chicago.</p> <pre><code>import pandas as pd\n\nimport matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar.plot.elements import CalendarEvent\n\ndf = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                 start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre> <p>This dataset is two weeks of data starting at the end of June 2023. We can easily see this by plotting it as a calendar grouped by the week of year.</p> <pre><code># Map the week number to a human readable label\ndf[\"week_number\"] = df[\"started_at\"].dt.isocalendar().week\n\n# Bit scary but just trying to make a nice label\ndef create_label(df: pd.DataFrame) -&gt; pd.Series:\n    first_date = df[\"first_date\"]\n    last_date = df[\"last_date\"]\n    return first_date.dt.date.astype(str).str.cat(\n        last_date.dt.date.astype(str), sep=\" until \"\n    )\n\nlabel = (\n    df.groupby(\"week_number\")\n    .agg(first_date=(\"started_at\", \"min\"), last_date=(\"started_at\", \"max\"))\n    .pipe(create_label)\n)\ndf[\"week_of_year\"] = df[\"week_number\"].map(label.to_dict())\n\ndf_wide = df.cal.aggregate_events(\"week_of_year\", \"started_at\")\n\n(\n    df_wide\n    .cal.divide_by_max()\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\nplt.show()\n</code></pre> <p>We are able to understand that the data is two weeks of data starting at the end of June 2023, but also see that there is heavy influence from the July 4 holiday weekend. People have off work and this is reflected in the data.</p> <p></p> <p>Though the holiday effect around the 4th, there seems to be a lower volume the Sunday before and after work the day after. Interestingly enough, there was a rain storm on the weekend and  another storm the Wednesday the 4th. We can mark this on the calendar for reference.</p> <pre><code>def create_plot_storms_func(first_storm: CalendarEvent, second_storm: CalendarEvent):\n    def plot_storms(first_week_ax: plt.Axes, second_week_ax: plt.Axes):\n        alpha = 0.15\n        first_storm.plot(ax=first_week_ax, facecolor=\"blue\", alpha=alpha, label=\"rain storm\")\n        second_storm.plot(ax=second_week_ax, facecolor=\"blue\", alpha=alpha, label=\"rain storm\")\n        first_week_ax.legend()\n        second_week_ax.legend()\n\n    return plot_storms\n\nfirst_storm = CalendarEvent(day=6, start=7, end=18)\nsecond_storm = CalendarEvent(day=2, start=17, end=22)\nplot_storms = create_plot_storms_func(first_storm, second_storm)\n\n(\n    df_wide\n    .cal.divide_by_max()\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\n\n\nplot_storms(fig.axes[0], fig.axes[1])\nplt.show()\n</code></pre> <p></p> <p>Let's break it down further by adding the <code>member_casual</code> column to the aggregation.</p> <pre><code>df_wide = df.cal.aggregate_events([\"member_casual\", \"week_of_year\"], \"started_at\")\n\n\ndef title_func(idx, row) -&gt; str:\n    group, week = idx\n\n    return f\"{group} - {week}\"\n\n\n(\n    df_wide\n    .cal.divide_by_max()\n    .cal.plot_by_row(max_cols=2, title_func=title_func)\n)\nfig = plt.gcf()\nfig.suptitle(\"Two week of bike rides in Chicago\")\n\naxes = fig.axes\n\nplot_storms(axes[0], axes[1])\nplot_storms(axes[2], axes[3])\n\nplt.show()\n</code></pre> <p>We can see that the holiday weekend has heavy volume from the casual riders showing on the Monday and Tuesday of the holiday weekend. Not only that, but the members that use the bikes heavily to commute shift their usage with this holiday too.</p> <p></p> <p>The effect of rain can be investigated by sum the trips that happen during the day time. We can do this by creating a segment for each day of the week between the hours of 7am and 6pm, the time of the Sunday storm.</p> <pre><code>from latent_calendar.vocab import DOWHour\nfrom latent_calendar.segments.hand_picked import create_series_for_range, stack_segments\n\nall_daytime_rain = stack_segments([\n    create_series_for_range(\n        start=DOWHour(dow=dow, hour=7), end=DOWHour(dow=dow, hour=18)\n    ).rename(f\"all_daytime_{dow}\")\n    for dow in range(7)\n])\n\ndf_volume = df_wide.cal.sum_over_segments(all_daytime_rain)\n</code></pre> <p>These are the row totals between the hours of 7am and 6pm for each day of the week at the same index level as before.</p> <pre><code>                                           all_daytime_0  all_daytime_1  all_daytime_2  all_daytime_3  all_daytime_4  all_daytime_5  all_daytime_6\nmember_casual week_of_year\ncasual        2023-06-26 until 2023-07-02           3887           4086           4634           4012           6647           8213            481\n              2023-07-03 until 2023-07-09           8946          10868           4523           5616           6920           6802           9643\nmember        2023-06-26 until 2023-07-02           7949           8960           9043           7852           9242           7663            822\n              2023-07-03 until 2023-07-09           9105           8239           8511           9989           9873           7846           9573\n</code></pre> <p>Visualizing this data, we can see the heavy impact of the Sunday weather for casual riders and members alike but not enough to ruin the holiday weekend.</p> <pre><code>def replace_index(ser: pd.Series, index: pd.Index) -&gt; pd.Series:\n    ser.index = index\n    return ser\n\nstart_date = df[\"started_at\"].min().date()\nend_date = df[\"started_at\"].max().date()\ndates = pd.date_range(start_date, end_date, freq=\"D\")\n\nax = (\n    df_volume\n    .stack()\n    .unstack(0)\n    .pipe(replace_index, index=dates)\n    .plot()\n)\nax.set(\n    ylabel=\"# trips\",\n    title=\"Trips between 7am and 6pm\",\n    ylim=(0, None),\n)\nax.legend(title=\"customer type\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/datasets/store-transactions/","title":"Store transactions","text":"<pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_online_transactions\n\ndf = load_online_transactions()\ndf.head()\n</code></pre> <pre><code>  Invoice StockCode                          Description  Quantity         InvoiceDate  Price  Customer ID         Country\n0  489434     85048  15CM CHRISTMAS GLASS BALL 20 LIGHTS        12 2009-12-01 07:45:00   6.95      13085.0  United Kingdom\n1  489434    79323P                   PINK CHERRY LIGHTS        12 2009-12-01 07:45:00   6.75      13085.0  United Kingdom\n2  489434    79323W                  WHITE CHERRY LIGHTS        12 2009-12-01 07:45:00   6.75      13085.0  United Kingdom\n3  489434     22041         RECORD FRAME 7\" SINGLE SIZE         48 2009-12-01 07:45:00   2.10      13085.0  United Kingdom\n4  489434     21232       STRAWBERRY CERAMIC TRINKET BOX        24 2009-12-01 07:45:00   1.25      13085.0  United Kingdom\n</code></pre> <p>By default, a new <code>cal</code> attribute will be added to DataFrames given access to module functionality.</p> <pre><code>df_wide = df.cal.aggregate_events(\"Country\", \"InvoiceDate\")\n\ndf_wide.head()\n</code></pre> <pre><code>day_of_week  0                                                                                  1     ...  5     6\nhour        0  1  2  3  4  5  6  7   8   9   10  11   12  13  14   15  16 17 18 19 20 21 22 23 0  1   ... 22 23 0  1  2  3  4  5  6  7  8  9   10  11  12  13  14   15 16 17 18 19 20 21 22 23\nCountry                                                                                               ...\nAustralia    0  0  0  0  0  0  0  0   0  27   6  19   20   7   2  105  27  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0  11  37  20   0  16    0  0  0  0  0  0  0  0  0\nAustria      0  0  0  0  0  0  0  0   9  55  81   0   18   0   0   33   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0  37    0  0  0  0  0  0  0  0  0\nBahrain      0  0  0  0  0  0  0  0   0   0   1   6    0  13   0    0   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0    0  0  0  0  0  0  0  0  0\nBelgium      0  0  0  0  0  0  0  0  15  15  42  26  109  54  38   17  26  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0  18  20  28  41   0  131  0  0  0  0  0  0  0  0\nBermuda      0  0  0  0  0  0  0  0   0   0   0   0    0   0   0    0   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0    0  0  0  0  0  0  0  0  0\n\n[5 rows x 168 columns]\n</code></pre> <p>We can clearly see the weekly hours of operation for these countries. Even though these are online transactions, these hours affect the transaction times.</p> <p>The slight shift in hours for the UK might be the difference in time zones between the UK and the other countries. Maybe it could be difference in buying patterns of these populations. Not sure but this visual gives us a good glance at the data and starting point to ask questions</p> <pre><code>countries = [\"United Kingdom\", \"Germany\", \"France\"]\n\n(\n    df_wide\n    .loc[countries]\n    .cal.divide_by_max()\n    .cal.plot_by_row()\n)\nfig = plt.gcf()\nfig.suptitle(\"Store Transactions by Country\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/datasets/ufo-sightings/","title":"UFO Sightings","text":"<pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_ufo_sightings\n\ndf = load_ufo_sightings()\n</code></pre> <p>Each row of the dataset is a UFO sighting somewhere around the world.</p> <pre><code>            Date_time                  city state/province country  ...                                        description date_documented    latitude   longitude\n0 1949-10-10 20:30:00            san marcos             tx      us  ...  This event took place in early fall around 194...       4/27/2004  29.8830556  -97.941111\n1 1949-10-10 21:00:00          lackland afb             tx     NaN  ...  1949 Lackland AFB&amp;#44 TX.  Lights racing acros...      12/16/2005    29.38421  -98.581082\n2 1955-10-10 17:00:00  chester (uk/england)            NaN      gb  ...  Green/Orange circular disc over Chester&amp;#44 En...       1/21/2008        53.2   -2.916667\n3 1956-10-10 21:00:00                  edna             tx      us  ...  My older brother and twin sister were leaving ...       1/17/2004  28.9783333  -96.645833\n4 1960-10-10 20:00:00               kaneohe             hi      us  ...  AS a Marine 1st Lt. flying an FJ4B fighter/att...       1/22/2004  21.4180556 -157.803611\n\n[5 rows x 11 columns]\n</code></pre> <pre><code>df[\"year\"] = df[\"Date_time\"].dt.year\n\ndf_wide = df.cal.aggregate_events(\"year\", \"Date_time\")\n\ndf_5_year = df_wide.tail(5)\n</code></pre> <p>which has the data in the wide format where each row is a weekly calendar.</p> <pre><code>day_of_week  0                                                                                  1     ...  5     6\nhour        0  1  2  3  4  5  6  7   8   9   10  11   12  13  14   15  16 17 18 19 20 21 22 23 0  1   ... 22 23 0  1  2  3  4  5  6  7  8  9   10  11  12  13  14   15 16 17 18 19 20 21 22 23\nCountry                                                                                               ...\nAustralia    0  0  0  0  0  0  0  0   0  27   6  19   20   7   2  105  27  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0  11  37  20   0  16    0  0  0  0  0  0  0  0  0\nAustria      0  0  0  0  0  0  0  0   9  55  81   0   18   0   0   33   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0  37    0  0  0  0  0  0  0  0  0\nBahrain      0  0  0  0  0  0  0  0   0   0   1   6    0  13   0    0   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0    0  0  0  0  0  0  0  0  0\nBelgium      0  0  0  0  0  0  0  0  15  15  42  26  109  54  38   17  26  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0  18  20  28  41   0  131  0  0  0  0  0  0  0  0\nBermuda      0  0  0  0  0  0  0  0   0   0   0   0    0   0   0    0   0  0  0  0  0  0  0  0  0  0  ...  0  0  0  0  0  0  0  0  0  0  0  0   0   0   0   0   0    0  0  0  0  0  0  0  0  0\n\n[5 rows x 168 columns]\n</code></pre> <p>We can make use the <code>cal</code> attribute further to plot an aggregate of the data and plots of the data by day of week and hour of day.</p> <pre><code>fig, axes = plt.subplots(ncols=3)\n\ndf_5_year.sum().cal.plot_row(ax=axes[0])\n\naxes[0].set(\n    title=\"Weekly UFO sightings\",\n)\n\nfor aggregation, ax in zip([\"dow\", \"hour\"], axes.ravel()[1:]):\n    (\n        df_5_year\n        .cal.sum_over_vocab(aggregation=aggregation)\n        .cal.divide_by_sum()\n        .mul(100)\n        .T.plot(ax=ax)\n    )\n    ymax = ax.get_ylim()[1]\n    ax.set_ylim(0, ymax * 1.1)\n\naxes[1].set_xticks(axes[0].get_xticks())\n\naxes[1].set(\n    title=\"Chance of UFO sighting by day of week\",\n    xlabel=\"Day of week\",\n    ylabel=\"Chance of UFO sighting (%)\",\n)\naxes[2].set(\n    title=\"Chance of UFO sighting by hour of day\",\n    xlabel=\"Hour of day\",\n    ylabel=\"\",\n)\nfig.suptitle(\"UFO sightings over 5 years\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/model/sklearn-compat/","title":"Scikit-Learn Compatibility","text":"<p>The <code>LatentCalendar</code> class is <code>scikit-learn</code> compatible making it very easy to integrate into your existing machine learning pipelines.</p> <p>Here are a few examples but feel free to get creative and combine them all together!</p>"},{"location":"examples/model/sklearn-compat/#pipelines","title":"Pipelines","text":"<p><code>LatentCalendar</code> can be used in <code>scikit-learn</code> pipelines. The <code>tranform</code> method will be used based on the <code>TransformerMixin</code> base of <code>LatentDirichletAllocation</code>.</p> <pre><code>from sklearn.pipeline import Pipeline\nfrom sklearn.mixture import GaussianMixture\n\nfrom latent_calendar import LatentCalendar\n\n\ndef create_hard_clustering_pipeline(n_components: int) -&gt; Pipeline:\n    gaussian_components = n_components ** 2 - 1\n    return Pipeline(\n        [\n            (\"latent_calendar\", LatentCalendar(n_components=n_components)),\n            (\"gaussian_mixture\", GaussianMixture(n_components=gaussian_components)),\n        ]\n    )\n\npipeline = create_hard_clustering_pipeline(n_components=3)\npipeline.fit(df_wide)\n\n# Hard cluster labels\npipline.predict(df_wide)\n</code></pre>"},{"location":"examples/model/sklearn-compat/#columntransformer","title":"ColumnTransformer","text":"<p>Similar with <code>Pipeline</code>s, the <code>transform</code> method will be used.</p> <pre><code>from sklearn.compose import ColumnTransformer\n\nvocab_columns = df_wide.columns.tolist()\n\ndf_wide[\"total_events\"] = df_wide.sum(axis=1)\n\ntransformer = ColumnTransformer(\n    [\n        (\"latent_calendar\", LatentCalendar(n_components=3), vocab_columns),\n    ], remainder=\"passthrough\"\n)\n\ntransformer = transformer.fit(df_wide)\n</code></pre>"},{"location":"examples/model/sklearn-compat/#other-transformers","title":"Other Transformers","text":"<pre><code>import pandas as pd\n\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.pipeline import Pipeline\n\nclass RemoveLowVolumeTimeSlots(BaseEstimator, TransformerMixin):\n    def __init__(self, model: LatentCalendar, min_count: int):\n        self.model = model\n        self.min_count = min_count\n\n    def fit(self, X: pd.DataFrame, y=None) -&gt; \"RemoveLowVolumeTimeSlots\":\n        self.original_columns = X.columns\n\n        column_counts = X.sum()\n        self.columns_to_keep = column_counts[column_counts &gt; self.min_count].index\n\n        self.model.fit(X.loc[:, self.columns_to_keep])\n\n        return self\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        return self.model.predict(X.loc[:, self.columns_to_keep])\n\n    def predict(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        X_pred = self.model.predict(X.loc[:, self.columns_to_keep])\n        return X_pred.reindex(self.original_columns, fill_value=0, axis=1)\n\n\nmodel = LatentCalendar(n_components=3)\ntransformer = RemoveLowVolumeTimeSlots(model=model, min_count=10)\ntransformer.fit(df_wide)\n</code></pre>"},{"location":"examples/plotting/add-calendar-events/","title":"Add calendar events","text":"<p>Can use the <code>CalendarEvent</code> class to add arbitrary events to calendar.</p> <p>The constructor takes a day of week, start time, an end time or duration, and number of days.</p> <p>The <code>plot</code> method takes a <code>plt.Axes</code> and allows for customization with additional keyword arguments</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.plot import plot_blank_calendar\nfrom latent_calendar.plot.elements import CalendarEvent\n\nax = plot_blank_calendar()\n\nevent = CalendarEvent(\n    day=4, start=12, duration=90,\n)\nevent.plot(ax=ax, label=\"90 minutes\", linestyle=\"--\", alpha=0.25)\n\nevent = CalendarEvent(\n    day=0, start=23, duration=3 * 60,\n)\nevent.plot(ax=ax, label=\"Overnight\", facecolor=\"red\", linestyle=\"dashed\", lw=1.5)\n\nevent = CalendarEvent(\n    day=6, start=17, end=19, days=3,\n)\nevent.plot(ax=ax, label=\"Multiday\", facecolor=\"orange\", linestyle=\"--\")\n\nax.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/calendar-customization/","title":"Calendar customization","text":"<p>Each calendar plot is made up of the following components:</p> <ul> <li>X axis (Day of week)</li> <li>Y axis (Time of the day)</li> <li>Grid Lines</li> <li>Events (Rectangles)</li> </ul> <p>The X axis and Y axis have default values but can be customized</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom latent_calendar.plot import plot_blank_calendar\nfrom latent_calendar.plot.elements import DayLabeler, TimeLabeler, GridLines\n\n\nfig, axes = plt.subplots(ncols=2, nrows=2)\nfig.suptitle(\"Calendar Customization\")\n\nax = axes[0, 0]\nplot_blank_calendar(ax=ax)\nax.set_title(\"Default\")\n\nax = axes[0, 1]\nplot_blank_calendar(\n    ax=ax, monday_start=False\n)\nax.set_title(\"Sunday Start\")\n\nax = axes[1, 0]\nday_labeler = DayLabeler(days_of_week=[\"M\", \"T\", \"W\", \"Th\", \"F\", \"Sa\", \"Su\"], rotation=0)\nhour_formatter = lambda hour: f\"{hour}h\"\ntime_labeler = TimeLabeler(hour_formatter=hour_formatter, stride=4)\nplot_blank_calendar(\n    ax=ax,\n    day_labeler=day_labeler,\n    time_labeler=time_labeler,\n)\nax.set_title(\"Custom Labels\")\n\nax = axes[1, 1]\ngrid_lines = GridLines(dow=True, hour=True)\nplot_blank_calendar(\n    ax=ax, grid_lines=grid_lines\n)\nax.set_title(\"Adding Grid Lines\")\n\nplt.show()\n</code></pre> <p></p> <p>Additionally, the labels can be turned off completely. This is done automatically with functions that plot multiple calendars.</p> <pre><code>fig, axes = plt.subplots(ncols=2, nrows=1)\n\nax = axes[0]\nday_labeler = DayLabeler(days_of_week=[\"M\", \"T\", \"W\", \"Th\", \"F\", \"Sa\", \"Su\"], rotation=0, display=False)\nplot_blank_calendar(\n    day_labeler=day_labeler,\n    ax=axes[0]\n)\nax.set(title=\"No Day Labels\")\n\nax = axes[1]\nhour_formatter = lambda hour: f\"{hour}h\"\ntime_labeler = TimeLabeler(hour_formatter=hour_formatter, stride=4, display=False)\nplot_blank_calendar(\n    time_labeler=time_labeler,\n    ax=ax\n)\nax.set(title=\"No Time Labels\")\nplt.show()\n</code></pre> <p></p> <p>This customization is available through the other plotting functions and methods as well. Access them with through the same parameter names.</p> <pre><code>from latent_calendar.segments.hand_picked import create_box_segment, stack_segments\n\nmornings = create_box_segment(\n    hour_start=6,\n    hour_end=11,\n    day_start=0, day_end=7,\n    name=\"mornings\"\n)\n\nevenings = create_box_segment(\n    hour_start=18,\n    hour_end=21,\n    day_start=0, day_end=7,\n    name=\"evenings\"\n)\n\nweekend_daytimes = create_box_segment(\n    hour_start=11,\n    hour_end=18,\n    day_start=5, day_end=7,\n    name=\"weekend daytimes\"\n)\n\ndf_segments = stack_segments([mornings, evenings, weekend_daytimes])\n\n# Plotting\n(\n    df_segments\n    .cal.plot_by_row(\n        day_labeler=day_labeler,\n        time_labeler=time_labeler\n    )\n)\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/event-frequency/","title":"Event frequency","text":"<p>All number of time slots divisible by 7 (days of the week) are supported for plotting. This is thanks to the <code>plot_calendar</code> function taking an iterable.</p> <pre><code>import numpy as np\n\nimport matplotlib.pyplot as plt\n\nfrom latent_calendar.plot import plot_calendar\nfrom latent_calendar.plot.iterate import iterate_matrix\nfrom latent_calendar.plot.colors import create_default_cmap\n\ntime_slots = [12, 24, 48]\n\nfig, axes = plt.subplots(ncols=len(time_slots))\n\nrng = np.random.default_rng(0)\nfor ts, ax in zip(time_slots, axes.ravel()):\n    data = rng.poisson(lam=1, size=(7, ts))\n\n    cmap = create_default_cmap(data.max())\n    plot_calendar(\n        iterate_matrix(data),\n        cmap=cmap,\n        ax=ax,\n    )\n    ax.set_title(f\"{ts} Time Slots\")\n\nfig.suptitle(\"Calendar Plot with Different # Time Slots\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/plotting/pandas-methods/","title":"Pandas methods","text":"<p>DataFrames can be plotted in various ways with the <code>cal</code> attribute.</p> <p>Event level data with the <code>cal.plot</code> or <code>cal.plot_across_column</code></p> <p>Wide data with the <code>cal.plot_by_row</code></p> <p>Check out the methods that start with <code>plot</code> in the Extensions section of the docs.</p>"},{"location":"modules/const/","title":"Const","text":"<p>Constants used to create the full vocabulary of the dataset.</p>"},{"location":"modules/const/#latent_calendar.const.create_full_vocab","title":"<code>create_full_vocab(days_in_week, minutes, as_multiindex=True)</code>","text":"<p>Create the full vocabulary of the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>days_in_week</code> <code>int</code> <p>Number of days in the week.</p> required <code>minutes</code> <code>int</code> <p>Number of minutes to discretize the hours by.</p> required <code>as_multiindex</code> <code>bool</code> <p>Whether to return a multiindex or a list of strings.</p> <code>True</code> <p>Returns:</p> Type Description <code>MultiIndex | list[str]</code> <p>The full vocabulary of the dataset. Either a MultiIndex or a list of strings.</p> Source code in <code>latent_calendar/const.py</code> <pre><code>def create_full_vocab(\n    days_in_week: int,\n    minutes: int,\n    as_multiindex: bool = True,\n) -&gt; pd.MultiIndex | list[str]:\n    \"\"\"Create the full vocabulary of the dataset.\n\n    Args:\n        days_in_week: Number of days in the week.\n        minutes: Number of minutes to discretize the hours by.\n        as_multiindex: Whether to return a multiindex or a list of strings.\n\n    Returns:\n        The full vocabulary of the dataset.\n            Either a MultiIndex or a list of strings.\n\n    \"\"\"\n\n    if not as_multiindex:\n        return [\n            format_dow_hour(day_of_week, hour)\n            for day_of_week, hour in product(\n                range(days_in_week), dicretized_hours(minutes)\n            )\n        ]\n\n    return pd.MultiIndex.from_product(\n        [range(days_in_week), dicretized_hours(minutes)], names=[\"day_of_week\", \"hour\"]\n    )\n</code></pre>"},{"location":"modules/datasets/","title":"Datasets","text":"<p>Example datasets for latent_calendar.</p> <p>All datasets are loaded from the web and cached locally if desired with the <code>local_save</code> argument.</p> <p>The datasets all include one or more columns that represent a datetime that can be used for calendar analysis.</p> <p>Examples:</p> <p>Load the chicago bikes dataset:</p> <pre><code>from latent_calendar.datasets import load_chicago_bikes\n\ndf = load_chicago_bikes()\ndf.head()\n</code></pre> <pre><code>                start_station_name end_station_name  rideable_type          started_at            ended_at member_casual\nride_id\nABF4F851DE485B76                NaN              NaN  electric_bike 2023-06-30 18:56:13 2023-06-30 19:30:40        member\nF123B5D34B002CDB                NaN              NaN  electric_bike 2023-06-30 06:12:31 2023-06-30 06:23:05        member\nCA8E2C38AF641DFB                NaN              NaN  electric_bike 2023-06-30 08:28:51 2023-06-30 08:37:45        member\n93CCE4EA48CFDB69                NaN              NaN  electric_bike 2023-06-30 09:09:24 2023-06-30 09:17:41        member\nFDBCEFE7890F7262                NaN              NaN  electric_bike 2023-06-30 16:29:48 2023-06-30 16:38:51        member\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_chicago_bikes","title":"<code>load_chicago_bikes(local_save=False, **read_kwargs)</code>","text":"<p>Bikesharing trip level data from Chicago's Divvy system.</p> <p>Read more about the data source here.</p> <p>The data is two weeks of trips starting June 26th, 2023 until July 9th, 2023.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <code>read_kwargs</code> <p>kwargs to pass to pd.read_csv</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Trips data from Chicago's Divvy system.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_chicago_bikes(local_save: bool = False, **read_kwargs) -&gt; pd.DataFrame:\n    \"\"\"Bikesharing trip level data from Chicago's Divvy system.\n\n    Read more about the data source [here](https://data.cityofchicago.org/Transportation/Divvy-Trips/fg6s-gzvg).\n\n    The data is two weeks of trips starting June 26th, 2023 until July 9th, 2023.\n\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n        read_kwargs: kwargs to pass to pd.read_csv\n\n    Returns:\n        Trips data from Chicago's Divvy system.\n\n    \"\"\"\n    name = \"chicago-bikes\"\n    read_kwargs = {\n        \"parse_dates\": [\"started_at\", \"ended_at\"],\n        \"index_col\": [\"ride_id\"],\n        **read_kwargs,\n    }\n\n    return _load_data(name, read_kwargs=read_kwargs, local_save=local_save)\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_online_transactions","title":"<code>load_online_transactions(local_save=False, **read_kwargs)</code>","text":"<p>Kaggle Data for an non-store online retailer in UK. More information here.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <code>read_kwargs</code> <p>kwargs to pass to pd.read_csv</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Online transactions data from a non-store online retailer in UK.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_online_transactions(local_save: bool = False, **read_kwargs) -&gt; pd.DataFrame:\n    \"\"\"Kaggle Data for an non-store online retailer in UK. More information [here](https://www.kaggle.com/datasets/mashlyn/online-retail-ii-uci).\n\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n        read_kwargs: kwargs to pass to pd.read_csv\n\n    Returns:\n        Online transactions data from a non-store online retailer in UK.\n\n    \"\"\"\n    name = \"online_retail_II\"\n    read_kwargs = {\n        \"parse_dates\": [\"InvoiceDate\"],\n        **read_kwargs,\n    }\n\n    return _load_data(name, read_kwargs=read_kwargs, local_save=local_save)\n</code></pre>"},{"location":"modules/datasets/#latent_calendar.datasets.load_ufo_sightings","title":"<code>load_ufo_sightings(local_save=False, **read_kwargs)</code>","text":"<p>UFO sightings over time around the world. More info here.</p> <p>Parameters:</p> Name Type Description Default <code>local_save</code> <code>bool</code> <p>Whether to save the data locally if it doesn't exists.</p> <code>False</code> <code>read_kwargs</code> <p>kwargs to pass to pd.read_csv</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Sighting level data for UFOs.</p> Source code in <code>latent_calendar/datasets/__init__.py</code> <pre><code>def load_ufo_sightings(local_save: bool = False, **read_kwargs) -&gt; pd.DataFrame:\n    \"\"\"UFO sightings over time around the world. More info [here](https://www.kaggle.com/datasets/camnugent/ufo-sightings-around-the-world).\n\n    Args:\n        local_save: Whether to save the data locally if it doesn't exists.\n        read_kwargs: kwargs to pass to pd.read_csv\n\n    Returns:\n        Sighting level data for UFOs.\n\n    \"\"\"\n    name = \"ufo_sighting_data\"\n    read_kwargs = {\"low_memory\": False, **read_kwargs}\n    save_kwargs = {\"index\": False}\n\n    df = _load_data(\n        name, read_kwargs=read_kwargs, save_kwargs=save_kwargs, local_save=local_save\n    )\n    df[\"Date_time\"] = pd.to_datetime(\n        df[\"Date_time\"]\n        .str.replace(\" 24:00\", \" 23:59\")\n        .pipe(pd.to_datetime, format=\"mixed\", dayfirst=True)\n    )\n\n    return df\n</code></pre>"},{"location":"modules/extensions/","title":"Extensions","text":"<p>DataFrame extensions for <code>latent-calendar</code> and primary interface for the package.</p> <p>Tip</p> <p>The extensions work for both pandas and polars DataFrames. However, there is currently limited functionality for polars DataFrames. Consider using polars for aggregation then converting to pandas for plotting and model training.</p> <p>Provides a <code>cal</code> accessor to <code>DataFrame</code> and <code>Series</code> instances for easy transformation and plotting after import of <code>latent_calendar</code>.</p> <p>Functionality includes:</p> <ul> <li>aggregation of events to wide format</li> <li>convolutions of wide formats</li> <li>making transformations and predictions with models</li> <li>plotting of events, predictions, and comparisons as calendars</li> </ul> <p>Each <code>DataFrame</code> will be either at event level or an aggregated wide format.</p> <p>Methods that end in <code>row</code> or <code>by_row</code> will be for wide format DataFrames and will plot each row as a calendar.</p> <p>Examples:</p> <p>Plotting an event level Series as a calendar</p> <pre><code>import pandas as pd\nimport latent_calendar\n\ndates = pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"h\")\nser = (\n    pd.Series(dates)\n    .sample(10, random_state=42)\n)\n\nser.cal.plot()\n</code></pre> <p></p> <p>Transform event level DataFrame to wide format and plot</p> <pre><code>from latent_calendar.datasets import load_online_transactions\n\ndf = load_online_transactions()\n\n# (n_customer, n_timeslots)\ndf_wide = (\n    df\n    .cal.aggregate_events(\"Customer ID\", timestamp_col=\"InvoiceDate\")\n)\n\n(\n    df_wide\n    .sample(n=12, random_state=42)\n    .cal.plot_by_row(max_cols=4)\n)\n</code></pre> <p></p> <p>Train a model and plot predictions</p> <pre><code>from latent_calendar import LatentCalendar\n\nmodel = LatentCalendar(n_components=5, random_state=42)\nmodel.fit(df_wide.to_numpy())\n\n(\n    df_wide\n    .head(2)\n    .cal.plot_profile_by_row(model=model)\n)\n</code></pre> <p></p>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor","title":"<code>PandasDataFrameAccessor</code>","text":"<p>DataFrame accessor for latent_calendar accessed through <code>cal</code> attribute of DataFrames.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pd.api.extensions.register_dataframe_accessor(\"cal\")\nclass PandasDataFrameAccessor:\n    \"\"\"DataFrame accessor for latent_calendar accessed through `cal` attribute of DataFrames.\"\"\"\n\n    def __init__(self, pandas_obj: pd.DataFrame):\n        self._obj = pandas_obj\n\n    def divide_by_max(self) -&gt; pd.DataFrame:\n        \"\"\"Divide each row by the max value.\n\n        Use before plotting to normalize the values to [0, 1].\n\n        Returns:\n            DataFrame with row-wise operations applied\n\n        \"\"\"\n        return self._obj.div(self._obj.max(axis=1), axis=0)\n\n    def divide_by_sum(self) -&gt; pd.DataFrame:\n        \"\"\"Divide each row by the sum of the row.\n\n        Use to create an empirical probability distribution for each row.\n\n        Returns:\n            DataFrame with row-wise operations applied\n\n        \"\"\"\n        return self._obj.div(self._obj.sum(axis=1), axis=0)\n\n    def divide_by_even_rate(self) -&gt; pd.DataFrame:\n        \"\"\"Divide each row by the number of columns.\n\n        Use to create a relative rate compared to an even distribution. Greater than\n        1 indicates the row has more events than expected under an even distribution.\n\n        Returns:\n            DataFrame with row-wise operations applied\n\n        \"\"\"\n        value = self._obj.shape[1]\n        return self._obj.mul(value)\n\n    def conditional_probabilities(\n        self,\n        *,\n        level: int | str = 0,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Calculate conditional probabilities for each row over the level.\n\n        Args:\n            level: level of the columns MultiIndex.\n                Default 0 or day_of_week\n\n        Returns:\n            DataFrame with conditional probabilities\n\n        \"\"\"\n        if not isinstance(self._obj.columns, pd.MultiIndex):\n            raise ValueError(\n                \"DataFrame is expected to have a MultiIndex with the last column as the vocab.\"\n            )\n\n        return self._obj.div(\n            self._obj.T.groupby(level=level).sum().T, level=level, axis=1\n        )\n\n    def timestamp_features(\n        self,\n        column: str,\n        discretize: bool = True,\n        minutes: int = 60,\n        create_vocab: bool = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Create day of week and proportion into day columns for event level DataFrame\n\n        Exposed as a method on DataFrame for convenience. Use `cal.aggregate_events` instead to create the wide format DataFrame.\n\n        Args:\n            column: The name of the timestamp column.\n            discretize: Whether to discretize the hour column.\n            minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n            create_vocab: Whether to create the vocab column.\n\n        Returns:\n            DataFrame with features added\n\n        \"\"\"\n        transformer = create_timestamp_feature_pipeline(\n            timestamp_col=column,\n            discretize=discretize,\n            create_vocab=create_vocab,\n            minutes=minutes,\n        )\n\n        return transformer.fit_transform(self._obj)\n\n    def widen(\n        self,\n        column: str,\n        as_int: bool = True,\n        minutes: int = 60,\n        multiindex: bool = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Transform an aggregated DataFrame to wide calendar format.\n\n        Wrapper around `LongToWide` transformer to transform to wide format.\n\n        Args:\n            column: column to widen\n            as_int: whether to cast the column to int\n            minutes: number of minutes to\n            multiindex: whether to use a MultiIndex\n\n        Returns:\n            DataFrame in wide format\n\n        \"\"\"\n        if not isinstance(self._obj.index, pd.MultiIndex):\n            raise ValueError(\n                \"DataFrame is expected to have a MultiIndex with the last column as the vocab.\"\n            )\n\n        transformer = LongToWide(\n            col=column, as_int=as_int, minutes=minutes, multiindex=multiindex\n        )\n\n        return transformer.fit_transform(self._obj)\n\n    def aggregate_events(\n        self,\n        by: str | list[str],\n        timestamp_col: str,\n        minutes: int = 60,\n        as_multiindex: bool = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Transform event level DataFrame to wide format with groups as index.\n\n        Wrapper around `create_raw_to_vocab_transformer` to transform to wide format.\n\n        Args:\n            by: column(s) to use as index\n            timestamp_col: column to use as timestamp\n            minutes: The number of minutes to discretize by.\n            as_multiindex: whether to use MultiIndex columns\n\n        Returns:\n            DataFrame in wide format\n\n        \"\"\"\n        if not isinstance(by, list):\n            id_col = by\n            additional_groups = None\n        else:\n            id_col, *additional_groups = by\n\n        transformer = create_raw_to_vocab_transformer(\n            id_col=id_col,\n            timestamp_col=timestamp_col,\n            minutes=minutes,\n            additional_groups=additional_groups,\n            as_multiindex=as_multiindex,\n        )\n        return transformer.fit_transform(self._obj)\n\n    def sum_over_vocab(\n        self,\n        aggregation: Literal[\"dow\", \"hour\"] = \"dow\",\n    ) -&gt; pd.DataFrame:\n        \"\"\"Sum the wide format to day of week or hour of day.\n\n        Args:\n            aggregation: one of ['dow', 'hour']\n\n        Returns:\n            DataFrame with summed values\n\n        Examples:\n            Sum to day of week\n\n            ```python\n            df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n            ```\n\n        \"\"\"\n        return sum_over_vocab(self._obj, aggregation=aggregation)\n\n    def sum_next_hours(self, hours: int) -&gt; pd.DataFrame:\n        \"\"\"Sum the wide format over next hours.\n\n        Args:\n            hours: number of hours to sum over\n\n        Returns:\n            DataFrame with summed values\n\n        \"\"\"\n        return sum_next_hours(self._obj, hours=hours)\n\n    def sum_over_segments(self, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Sum the wide format over user defined segments.\n\n        Args:\n            df_segments: DataFrame in wide format with segments as index\n\n        Returns:\n            DataFrame with columns as the segments and summed values\n\n        \"\"\"\n        return sum_over_segments(self._obj, df_segments=df_segments)\n\n    def transform(self, *, model: LatentCalendar) -&gt; pd.DataFrame:\n        \"\"\"Transform DataFrame with model.\n\n        Applies the dimensionality reduction to each row of the DataFrame.\n\n        Args:\n            model: model to use for transformation\n\n        Returns:\n            DataFrame with transformed values\n\n        \"\"\"\n        return transform_on_dataframe(self._obj, model=model)\n\n    def predict(self, *, model: LatentCalendar) -&gt; pd.DataFrame:\n        \"\"\"Predict DataFrame with model.\n\n        Args:\n            model: model to use for prediction\n\n        Returns:\n            DataFrame with predicted values (wide format)\n\n        \"\"\"\n        return predict_on_dataframe(self._obj, model=model)\n\n    def plot(\n        self,\n        start_col: str,\n        *,\n        end_col: str | None = None,\n        duration: int | None = None,\n        alpha: float = None,\n        cmap=None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        monday_start: bool = True,\n        ax: plt.Axes | None = None,\n    ) -&gt; plt.Axes:\n        \"\"\"Plot DataFrame of timestamps as a calendar.\n\n        Args:\n            start_col: column with start timestamp\n            end_col: column with end timestamp\n            duration: length of event in minutes. Alternative to end_col\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            monday_start: whether to start the week on Monday or Sunday\n            ax: optional matplotlib axis to plot on\n\n        Returns:\n            Modified matplotlib axis\n\n        \"\"\"\n        config = StartEndConfig(start=start_col, end=end_col, minutes=duration)\n\n        return plot_dataframe_as_calendar(\n            self._obj,\n            config=config,\n            alpha=alpha,\n            cmap=cmap,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n            monday_start=monday_start,\n            ax=ax,\n        )\n\n    def plot_across_column(\n        self,\n        start_col: str,\n        grid_col: str,\n        *,\n        end_col: str | None = None,\n        duration: int | None = None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        max_cols: int = 3,\n        alpha: float = None,\n    ) -&gt; None:\n        \"\"\"Plot DataFrame of timestamps as a calendar as grid across column values.\n\n        NA values are excluded\n\n        Args:\n            start_col: column with start timestamp\n            grid_col: column of values to use as grid\n            end_col: column with end timestamp\n            duration: length of event in minutes. Alternative to end_col\n            max_cols: max number of columns per row\n            alpha: alpha value for the color\n\n        Returns:\n            None\n\n        \"\"\"\n        config = StartEndConfig(start=start_col, end=end_col, minutes=duration)\n\n        plot_dataframe_grid_across_column(\n            self._obj,\n            grid_col=grid_col,\n            config=config,\n            max_cols=max_cols,\n            alpha=alpha,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n        )\n\n    def plot_by_row(\n        self,\n        *,\n        max_cols: int = 3,\n        title_func: TITLE_FUNC | None = None,\n        cmaps: CMAP | ColorMap | CMAP_GENERATOR | None = None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        monday_start: bool = True,\n    ) -&gt; None:\n        \"\"\"Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.\n\n        Wrapper around `latent_calendar.plot.plot_calendar_by_row`.\n\n        Args:\n            max_cols: max number of columns per row of grid\n            title_func: function to generate title for each row\n            day_labeler: function to generate day labels\n            time_labeler: function to generate time labels\n            cmaps: optional generator of colormaps\n            grid_lines: optional grid lines\n            monday_start: whether to start the week on Monday or Sunday\n\n        Returns:\n            None\n\n        \"\"\"\n        return plot_calendar_by_row(\n            self._obj,\n            max_cols=max_cols,\n            title_func=title_func,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            cmaps=cmaps,\n            grid_lines=grid_lines,\n            monday_start=monday_start,\n        )\n\n    def plot_profile_by_row(\n        self,\n        *,\n        model: LatentCalendar,\n        index_func=lambda idx: idx,\n        include_components: bool = True,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n    ) -&gt; np.ndarray:\n        \"\"\"Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.\n\n        Args:\n            model: model to use for prediction and transform\n            index_func: function to generate title for each row\n            include_components: whether to include components in the plot\n            day_labeler: DayLabeler instance to use for day labels\n            time_labeler: TimeLabeler instance to use for time labels\n\n        Returns:\n            grid of axes\n\n        \"\"\"\n        return plot_profile_by_row(\n            self._obj,\n            model=model,\n            index_func=index_func,\n            include_components=include_components,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        )\n\n    def plot_raw_and_predicted_by_row(\n        self,\n        *,\n        model: LatentCalendar,\n        index_func=lambda idx: idx,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n    ) -&gt; np.ndarray:\n        \"\"\"Plot raw and predicted values for a model. Data must have been transformed to wide format first.\n\n        Args:\n            model: model to use for prediction\n            index_func: function to generate title for each row\n            day_labeler: DayLabeler instance to use for day labels\n            time_labeler: TimeLabeler instance to use for time labels\n\n        Returns:\n            grid of axes\n\n        \"\"\"\n        return plot_profile_by_row(\n            self._obj,\n            model=model,\n            index_func=index_func,\n            include_components=False,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        )\n\n    def plot_model_predictions_by_row(\n        self,\n        df_holdout: pd.DataFrame,\n        *,\n        model: LatentCalendar,\n        index_func=lambda idx: idx,\n        divergent: bool = True,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n    ) -&gt; np.ndarray:\n        \"\"\"Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.\n\n        Args:\n            df_holdout: holdout DataFrame for comparison\n            model: model to use for prediction\n            index_func: function to generate title for each row\n            divergent: whether to use divergent colormap\n            day_labeler: DayLabeler instance to use for day labels\n            time_labeler: TimeLabeler instance to use for time labels\n\n        Returns:\n            grid of axes\n\n        \"\"\"\n        return plot_model_predictions_by_row(\n            self._obj,\n            df_holdout=df_holdout,\n            model=model,\n            index_func=index_func,\n            divergent=divergent,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        )\n\n    def chart(\n        self,\n        *,\n        title: str | None = None,\n        width: int = 400,\n        height: int = 300,\n        color_scheme: str = \"greens\",\n        monday_start: bool = True,\n        interactive: bool = True,\n        show_values: bool = True,\n    ):\n        \"\"\"Create an Altair calendar heatmap chart.\n\n        Convenience wrapper around create_calendar_chart() that works directly\n        on the DataFrame without requiring an import.\n\n        Works with:\n\n        - Multi-row wide format (from .cal.aggregate_events())\n        - Single-row wide format (168 columns)\n        - Long format (day_of_week, hour, value columns)\n\n        Returns Altair Chart that can be:\n\n        - Displayed in notebooks\n        - Saved with .save('file.html')\n        - Faceted with .facet(column='group:N')\n\n        Args:\n            title: Chart title\n            width: Chart width in pixels\n            height: Chart height in pixels\n            color_scheme: Altair color scheme ('greens', 'blues', 'viridis', etc.)\n            monday_start: Start week on Monday (True) or Sunday (False)\n            interactive: Enable tooltips and zoom/pan\n            show_values: Show values in tooltips\n\n        Returns:\n            Altair Chart object\n\n        Examples:\n            Create chart from aggregated data:\n\n            ```python\n            chart = df.cal.aggregate_events(\"group\", \"timestamp\").cal.chart()\n            chart.save('calendar.html')\n            ```\n\n            Faceted chart in one line:\n\n            ```python\n            (df.cal.aggregate_events(\"member_casual\", \"started_at\")\n               .cal.chart(color_scheme=\"greens\")\n               .facet(column='member_casual:N'))\n            ```\n\n        \"\"\"\n        from latent_calendar.html import create_calendar_chart\n\n        return create_calendar_chart(\n            self._obj,\n            title=title,\n            width=width,\n            height=height,\n            color_scheme=color_scheme,\n            monday_start=monday_start,\n            interactive=interactive,\n            show_values=show_values,\n        )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.aggregate_events","title":"<code>aggregate_events(by, timestamp_col, minutes=60, as_multiindex=True)</code>","text":"<p>Transform event level DataFrame to wide format with groups as index.</p> <p>Wrapper around <code>create_raw_to_vocab_transformer</code> to transform to wide format.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | list[str]</code> <p>column(s) to use as index</p> required <code>timestamp_col</code> <code>str</code> <p>column to use as timestamp</p> required <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>as_multiindex</code> <code>bool</code> <p>whether to use MultiIndex columns</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in wide format</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def aggregate_events(\n    self,\n    by: str | list[str],\n    timestamp_col: str,\n    minutes: int = 60,\n    as_multiindex: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Transform event level DataFrame to wide format with groups as index.\n\n    Wrapper around `create_raw_to_vocab_transformer` to transform to wide format.\n\n    Args:\n        by: column(s) to use as index\n        timestamp_col: column to use as timestamp\n        minutes: The number of minutes to discretize by.\n        as_multiindex: whether to use MultiIndex columns\n\n    Returns:\n        DataFrame in wide format\n\n    \"\"\"\n    if not isinstance(by, list):\n        id_col = by\n        additional_groups = None\n    else:\n        id_col, *additional_groups = by\n\n    transformer = create_raw_to_vocab_transformer(\n        id_col=id_col,\n        timestamp_col=timestamp_col,\n        minutes=minutes,\n        additional_groups=additional_groups,\n        as_multiindex=as_multiindex,\n    )\n    return transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.chart","title":"<code>chart(*, title=None, width=400, height=300, color_scheme='greens', monday_start=True, interactive=True, show_values=True)</code>","text":"<p>Create an Altair calendar heatmap chart.</p> <p>Convenience wrapper around create_calendar_chart() that works directly on the DataFrame without requiring an import.</p> <p>Works with:</p> <ul> <li>Multi-row wide format (from .cal.aggregate_events())</li> <li>Single-row wide format (168 columns)</li> <li>Long format (day_of_week, hour, value columns)</li> </ul> <p>Returns Altair Chart that can be:</p> <ul> <li>Displayed in notebooks</li> <li>Saved with .save('file.html')</li> <li>Faceted with .facet(column='group:N')</li> </ul> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <p>Chart title</p> <code>None</code> <code>width</code> <code>int</code> <p>Chart width in pixels</p> <code>400</code> <code>height</code> <code>int</code> <p>Chart height in pixels</p> <code>300</code> <code>color_scheme</code> <code>str</code> <p>Altair color scheme ('greens', 'blues', 'viridis', etc.)</p> <code>'greens'</code> <code>monday_start</code> <code>bool</code> <p>Start week on Monday (True) or Sunday (False)</p> <code>True</code> <code>interactive</code> <code>bool</code> <p>Enable tooltips and zoom/pan</p> <code>True</code> <code>show_values</code> <code>bool</code> <p>Show values in tooltips</p> <code>True</code> <p>Returns:</p> Type Description <p>Altair Chart object</p> <p>Examples:</p> <p>Create chart from aggregated data:</p> <pre><code>chart = df.cal.aggregate_events(\"group\", \"timestamp\").cal.chart()\nchart.save('calendar.html')\n</code></pre> <p>Faceted chart in one line:</p> <pre><code>(df.cal.aggregate_events(\"member_casual\", \"started_at\")\n   .cal.chart(color_scheme=\"greens\")\n   .facet(column='member_casual:N'))\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def chart(\n    self,\n    *,\n    title: str | None = None,\n    width: int = 400,\n    height: int = 300,\n    color_scheme: str = \"greens\",\n    monday_start: bool = True,\n    interactive: bool = True,\n    show_values: bool = True,\n):\n    \"\"\"Create an Altair calendar heatmap chart.\n\n    Convenience wrapper around create_calendar_chart() that works directly\n    on the DataFrame without requiring an import.\n\n    Works with:\n\n    - Multi-row wide format (from .cal.aggregate_events())\n    - Single-row wide format (168 columns)\n    - Long format (day_of_week, hour, value columns)\n\n    Returns Altair Chart that can be:\n\n    - Displayed in notebooks\n    - Saved with .save('file.html')\n    - Faceted with .facet(column='group:N')\n\n    Args:\n        title: Chart title\n        width: Chart width in pixels\n        height: Chart height in pixels\n        color_scheme: Altair color scheme ('greens', 'blues', 'viridis', etc.)\n        monday_start: Start week on Monday (True) or Sunday (False)\n        interactive: Enable tooltips and zoom/pan\n        show_values: Show values in tooltips\n\n    Returns:\n        Altair Chart object\n\n    Examples:\n        Create chart from aggregated data:\n\n        ```python\n        chart = df.cal.aggregate_events(\"group\", \"timestamp\").cal.chart()\n        chart.save('calendar.html')\n        ```\n\n        Faceted chart in one line:\n\n        ```python\n        (df.cal.aggregate_events(\"member_casual\", \"started_at\")\n           .cal.chart(color_scheme=\"greens\")\n           .facet(column='member_casual:N'))\n        ```\n\n    \"\"\"\n    from latent_calendar.html import create_calendar_chart\n\n    return create_calendar_chart(\n        self._obj,\n        title=title,\n        width=width,\n        height=height,\n        color_scheme=color_scheme,\n        monday_start=monday_start,\n        interactive=interactive,\n        show_values=show_values,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.conditional_probabilities","title":"<code>conditional_probabilities(*, level=0)</code>","text":"<p>Calculate conditional probabilities for each row over the level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>level of the columns MultiIndex. Default 0 or day_of_week</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with conditional probabilities</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def conditional_probabilities(\n    self,\n    *,\n    level: int | str = 0,\n) -&gt; pd.DataFrame:\n    \"\"\"Calculate conditional probabilities for each row over the level.\n\n    Args:\n        level: level of the columns MultiIndex.\n            Default 0 or day_of_week\n\n    Returns:\n        DataFrame with conditional probabilities\n\n    \"\"\"\n    if not isinstance(self._obj.columns, pd.MultiIndex):\n        raise ValueError(\n            \"DataFrame is expected to have a MultiIndex with the last column as the vocab.\"\n        )\n\n    return self._obj.div(\n        self._obj.T.groupby(level=level).sum().T, level=level, axis=1\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.divide_by_even_rate","title":"<code>divide_by_even_rate()</code>","text":"<p>Divide each row by the number of columns.</p> <p>Use to create a relative rate compared to an even distribution. Greater than 1 indicates the row has more events than expected under an even distribution.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with row-wise operations applied</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def divide_by_even_rate(self) -&gt; pd.DataFrame:\n    \"\"\"Divide each row by the number of columns.\n\n    Use to create a relative rate compared to an even distribution. Greater than\n    1 indicates the row has more events than expected under an even distribution.\n\n    Returns:\n        DataFrame with row-wise operations applied\n\n    \"\"\"\n    value = self._obj.shape[1]\n    return self._obj.mul(value)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.divide_by_max","title":"<code>divide_by_max()</code>","text":"<p>Divide each row by the max value.</p> <p>Use before plotting to normalize the values to [0, 1].</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with row-wise operations applied</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def divide_by_max(self) -&gt; pd.DataFrame:\n    \"\"\"Divide each row by the max value.\n\n    Use before plotting to normalize the values to [0, 1].\n\n    Returns:\n        DataFrame with row-wise operations applied\n\n    \"\"\"\n    return self._obj.div(self._obj.max(axis=1), axis=0)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.divide_by_sum","title":"<code>divide_by_sum()</code>","text":"<p>Divide each row by the sum of the row.</p> <p>Use to create an empirical probability distribution for each row.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with row-wise operations applied</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def divide_by_sum(self) -&gt; pd.DataFrame:\n    \"\"\"Divide each row by the sum of the row.\n\n    Use to create an empirical probability distribution for each row.\n\n    Returns:\n        DataFrame with row-wise operations applied\n\n    \"\"\"\n    return self._obj.div(self._obj.sum(axis=1), axis=0)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.plot","title":"<code>plot(start_col, *, end_col=None, duration=None, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot DataFrame of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>start_col</code> <code>str</code> <p>column with start timestamp</p> required <code>end_col</code> <code>str | None</code> <p>column with end timestamp</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>length of event in minutes. Alternative to end_col</p> <code>None</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Axes | None</code> <p>optional matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot(\n    self,\n    start_col: str,\n    *,\n    end_col: str | None = None,\n    duration: int | None = None,\n    alpha: float = None,\n    cmap=None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n    ax: plt.Axes | None = None,\n) -&gt; plt.Axes:\n    \"\"\"Plot DataFrame of timestamps as a calendar.\n\n    Args:\n        start_col: column with start timestamp\n        end_col: column with end timestamp\n        duration: length of event in minutes. Alternative to end_col\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        monday_start: whether to start the week on Monday or Sunday\n        ax: optional matplotlib axis to plot on\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    config = StartEndConfig(start=start_col, end=end_col, minutes=duration)\n\n    return plot_dataframe_as_calendar(\n        self._obj,\n        config=config,\n        alpha=alpha,\n        cmap=cmap,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        grid_lines=grid_lines,\n        monday_start=monday_start,\n        ax=ax,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.plot_across_column","title":"<code>plot_across_column(start_col, grid_col, *, end_col=None, duration=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), max_cols=3, alpha=None)</code>","text":"<p>Plot DataFrame of timestamps as a calendar as grid across column values.</p> <p>NA values are excluded</p> <p>Parameters:</p> Name Type Description Default <code>start_col</code> <code>str</code> <p>column with start timestamp</p> required <code>grid_col</code> <code>str</code> <p>column of values to use as grid</p> required <code>end_col</code> <code>str | None</code> <p>column with end timestamp</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>length of event in minutes. Alternative to end_col</p> <code>None</code> <code>max_cols</code> <code>int</code> <p>max number of columns per row</p> <code>3</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_across_column(\n    self,\n    start_col: str,\n    grid_col: str,\n    *,\n    end_col: str | None = None,\n    duration: int | None = None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    max_cols: int = 3,\n    alpha: float = None,\n) -&gt; None:\n    \"\"\"Plot DataFrame of timestamps as a calendar as grid across column values.\n\n    NA values are excluded\n\n    Args:\n        start_col: column with start timestamp\n        grid_col: column of values to use as grid\n        end_col: column with end timestamp\n        duration: length of event in minutes. Alternative to end_col\n        max_cols: max number of columns per row\n        alpha: alpha value for the color\n\n    Returns:\n        None\n\n    \"\"\"\n    config = StartEndConfig(start=start_col, end=end_col, minutes=duration)\n\n    plot_dataframe_grid_across_column(\n        self._obj,\n        grid_col=grid_col,\n        config=config,\n        max_cols=max_cols,\n        alpha=alpha,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        grid_lines=grid_lines,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.plot_by_row","title":"<code>plot_by_row(*, max_cols=3, title_func=None, cmaps=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.</p> <p>Wrapper around <code>latent_calendar.plot.plot_calendar_by_row</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_cols</code> <code>int</code> <p>max number of columns per row of grid</p> <code>3</code> <code>title_func</code> <code>TITLE_FUNC | None</code> <p>function to generate title for each row</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>function to generate day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>function to generate time labels</p> <code>TimeLabeler()</code> <code>cmaps</code> <code>CMAP | ColorMap | CMAP_GENERATOR | None</code> <p>optional generator of colormaps</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>optional grid lines</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_by_row(\n    self,\n    *,\n    max_cols: int = 3,\n    title_func: TITLE_FUNC | None = None,\n    cmaps: CMAP | ColorMap | CMAP_GENERATOR | None = None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n) -&gt; None:\n    \"\"\"Plot each row of the DataFrame as a calendar plot. Data must have been transformed to wide format first.\n\n    Wrapper around `latent_calendar.plot.plot_calendar_by_row`.\n\n    Args:\n        max_cols: max number of columns per row of grid\n        title_func: function to generate title for each row\n        day_labeler: function to generate day labels\n        time_labeler: function to generate time labels\n        cmaps: optional generator of colormaps\n        grid_lines: optional grid lines\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        None\n\n    \"\"\"\n    return plot_calendar_by_row(\n        self._obj,\n        max_cols=max_cols,\n        title_func=title_func,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        cmaps=cmaps,\n        grid_lines=grid_lines,\n        monday_start=monday_start,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.plot_model_predictions_by_row","title":"<code>plot_model_predictions_by_row(df_holdout, *, model, index_func=lambda idx: idx, divergent=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>df_holdout</code> <code>DataFrame</code> <p>holdout DataFrame for comparison</p> required <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <code>divergent</code> <code>bool</code> <p>whether to use divergent colormap</p> <code>True</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance to use for day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance to use for time labels</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_model_predictions_by_row(\n    self,\n    df_holdout: pd.DataFrame,\n    *,\n    model: LatentCalendar,\n    index_func=lambda idx: idx,\n    divergent: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n    \"\"\"Plot model predictions for each row of the DataFrame. Data must have been transformed to wide format first.\n\n    Args:\n        df_holdout: holdout DataFrame for comparison\n        model: model to use for prediction\n        index_func: function to generate title for each row\n        divergent: whether to use divergent colormap\n        day_labeler: DayLabeler instance to use for day labels\n        time_labeler: TimeLabeler instance to use for time labels\n\n    Returns:\n        grid of axes\n\n    \"\"\"\n    return plot_model_predictions_by_row(\n        self._obj,\n        df_holdout=df_holdout,\n        model=model,\n        index_func=index_func,\n        divergent=divergent,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.plot_profile_by_row","title":"<code>plot_profile_by_row(*, model, index_func=lambda idx: idx, include_components=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction and transform</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <code>include_components</code> <code>bool</code> <p>whether to include components in the plot</p> <code>True</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance to use for day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance to use for time labels</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_profile_by_row(\n    self,\n    *,\n    model: LatentCalendar,\n    index_func=lambda idx: idx,\n    include_components: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n    \"\"\"Plot each row of the DataFrame as a profile plot. Data must have been transformed to wide format first.\n\n    Args:\n        model: model to use for prediction and transform\n        index_func: function to generate title for each row\n        include_components: whether to include components in the plot\n        day_labeler: DayLabeler instance to use for day labels\n        time_labeler: TimeLabeler instance to use for time labels\n\n    Returns:\n        grid of axes\n\n    \"\"\"\n    return plot_profile_by_row(\n        self._obj,\n        model=model,\n        index_func=index_func,\n        include_components=include_components,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.plot_raw_and_predicted_by_row","title":"<code>plot_raw_and_predicted_by_row(*, model, index_func=lambda idx: idx, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot raw and predicted values for a model. Data must have been transformed to wide format first.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <code>index_func</code> <p>function to generate title for each row</p> <code>lambda idx: idx</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance to use for day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance to use for time labels</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>grid of axes</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_raw_and_predicted_by_row(\n    self,\n    *,\n    model: LatentCalendar,\n    index_func=lambda idx: idx,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n    \"\"\"Plot raw and predicted values for a model. Data must have been transformed to wide format first.\n\n    Args:\n        model: model to use for prediction\n        index_func: function to generate title for each row\n        day_labeler: DayLabeler instance to use for day labels\n        time_labeler: TimeLabeler instance to use for time labels\n\n    Returns:\n        grid of axes\n\n    \"\"\"\n    return plot_profile_by_row(\n        self._obj,\n        model=model,\n        index_func=index_func,\n        include_components=False,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.predict","title":"<code>predict(*, model)</code>","text":"<p>Predict DataFrame with model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for prediction</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with predicted values (wide format)</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def predict(self, *, model: LatentCalendar) -&gt; pd.DataFrame:\n    \"\"\"Predict DataFrame with model.\n\n    Args:\n        model: model to use for prediction\n\n    Returns:\n        DataFrame with predicted values (wide format)\n\n    \"\"\"\n    return predict_on_dataframe(self._obj, model=model)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.sum_next_hours","title":"<code>sum_next_hours(hours)</code>","text":"<p>Sum the wide format over next hours.</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <code>int</code> <p>number of hours to sum over</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with summed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_next_hours(self, hours: int) -&gt; pd.DataFrame:\n    \"\"\"Sum the wide format over next hours.\n\n    Args:\n        hours: number of hours to sum over\n\n    Returns:\n        DataFrame with summed values\n\n    \"\"\"\n    return sum_next_hours(self._obj, hours=hours)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.sum_over_segments","title":"<code>sum_over_segments(df_segments)</code>","text":"<p>Sum the wide format over user defined segments.</p> <p>Parameters:</p> Name Type Description Default <code>df_segments</code> <code>DataFrame</code> <p>DataFrame in wide format with segments as index</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns as the segments and summed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_over_segments(self, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Sum the wide format over user defined segments.\n\n    Args:\n        df_segments: DataFrame in wide format with segments as index\n\n    Returns:\n        DataFrame with columns as the segments and summed values\n\n    \"\"\"\n    return sum_over_segments(self._obj, df_segments=df_segments)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.sum_over_vocab","title":"<code>sum_over_vocab(aggregation='dow')</code>","text":"<p>Sum the wide format to day of week or hour of day.</p> <p>Parameters:</p> Name Type Description Default <code>aggregation</code> <code>Literal['dow', 'hour']</code> <p>one of ['dow', 'hour']</p> <code>'dow'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with summed values</p> <p>Examples:</p> <p>Sum to day of week</p> <pre><code>df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def sum_over_vocab(\n    self,\n    aggregation: Literal[\"dow\", \"hour\"] = \"dow\",\n) -&gt; pd.DataFrame:\n    \"\"\"Sum the wide format to day of week or hour of day.\n\n    Args:\n        aggregation: one of ['dow', 'hour']\n\n    Returns:\n        DataFrame with summed values\n\n    Examples:\n        Sum to day of week\n\n        ```python\n        df_dow = df_wide.cal.sum_over_vocab(aggregation='dow')\n        ```\n\n    \"\"\"\n    return sum_over_vocab(self._obj, aggregation=aggregation)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.timestamp_features","title":"<code>timestamp_features(column, discretize=True, minutes=60, create_vocab=True)</code>","text":"<p>Create day of week and proportion into day columns for event level DataFrame</p> <p>Exposed as a method on DataFrame for convenience. Use <code>cal.aggregate_events</code> instead to create the wide format DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>discretize</code> <code>bool</code> <p>Whether to discretize the hour column.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by. Ingored if <code>discretize</code> is False.</p> <code>60</code> <code>create_vocab</code> <code>bool</code> <p>Whether to create the vocab column.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with features added</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def timestamp_features(\n    self,\n    column: str,\n    discretize: bool = True,\n    minutes: int = 60,\n    create_vocab: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Create day of week and proportion into day columns for event level DataFrame\n\n    Exposed as a method on DataFrame for convenience. Use `cal.aggregate_events` instead to create the wide format DataFrame.\n\n    Args:\n        column: The name of the timestamp column.\n        discretize: Whether to discretize the hour column.\n        minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n        create_vocab: Whether to create the vocab column.\n\n    Returns:\n        DataFrame with features added\n\n    \"\"\"\n    transformer = create_timestamp_feature_pipeline(\n        timestamp_col=column,\n        discretize=discretize,\n        create_vocab=create_vocab,\n        minutes=minutes,\n    )\n\n    return transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.transform","title":"<code>transform(*, model)</code>","text":"<p>Transform DataFrame with model.</p> <p>Applies the dimensionality reduction to each row of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>model to use for transformation</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with transformed values</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def transform(self, *, model: LatentCalendar) -&gt; pd.DataFrame:\n    \"\"\"Transform DataFrame with model.\n\n    Applies the dimensionality reduction to each row of the DataFrame.\n\n    Args:\n        model: model to use for transformation\n\n    Returns:\n        DataFrame with transformed values\n\n    \"\"\"\n    return transform_on_dataframe(self._obj, model=model)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasDataFrameAccessor.widen","title":"<code>widen(column, as_int=True, minutes=60, multiindex=True)</code>","text":"<p>Transform an aggregated DataFrame to wide calendar format.</p> <p>Wrapper around <code>LongToWide</code> transformer to transform to wide format.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>column to widen</p> required <code>as_int</code> <code>bool</code> <p>whether to cast the column to int</p> <code>True</code> <code>minutes</code> <code>int</code> <p>number of minutes to</p> <code>60</code> <code>multiindex</code> <code>bool</code> <p>whether to use a MultiIndex</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in wide format</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def widen(\n    self,\n    column: str,\n    as_int: bool = True,\n    minutes: int = 60,\n    multiindex: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Transform an aggregated DataFrame to wide calendar format.\n\n    Wrapper around `LongToWide` transformer to transform to wide format.\n\n    Args:\n        column: column to widen\n        as_int: whether to cast the column to int\n        minutes: number of minutes to\n        multiindex: whether to use a MultiIndex\n\n    Returns:\n        DataFrame in wide format\n\n    \"\"\"\n    if not isinstance(self._obj.index, pd.MultiIndex):\n        raise ValueError(\n            \"DataFrame is expected to have a MultiIndex with the last column as the vocab.\"\n        )\n\n    transformer = LongToWide(\n        col=column, as_int=as_int, minutes=minutes, multiindex=multiindex\n    )\n\n    return transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasSeriesAccessor","title":"<code>PandasSeriesAccessor</code>","text":"<p>Series accessor for latent_calendar accessed through <code>cal</code> attribute of Series.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"cal\")\nclass PandasSeriesAccessor:\n    \"\"\"Series accessor for latent_calendar accessed through `cal` attribute of Series.\"\"\"\n\n    def __init__(self, pandas_obj: pd.Series):\n        self._obj = pandas_obj\n\n    def aggregate_events(\n        self,\n        minutes: int = 60,\n        as_multiindex: bool = True,\n    ) -&gt; pd.Series:\n        \"\"\"Transform event level Series to row of wide format.\n\n        Args:\n            minutes: The number of minutes to discretize by.\n            as_multiindex: whether to use MultiIndex columns\n\n        Returns:\n            Series that would be row of wide format\n\n        Examples:\n            Discretize datetime Series to 30 minutes\n\n            ```python\n            import pandas as pd\n\n            import matplotlib.pyplot as plt\n\n            from latent_calendar.datasets import load_chicago_bikes\n\n            df_trips = load_chicago_bikes()\n\n            start_times = df_trips[\"started_at\"]\n\n            agg_start_times = start_times.cal.aggregate_events(minutes=30)\n            agg_start_times.cal.plot_row()\n            plt.show()\n\n\n            ```\n\n\n        \"\"\"\n        name = self._obj.name or \"timestamp\"\n        return (\n            self._obj.rename(name)\n            .to_frame()\n            .assign(tmp=1)\n            .cal.aggregate_events(\n                by=\"tmp\",\n                timestamp_col=name,\n                minutes=minutes,\n                as_multiindex=as_multiindex,\n            )\n            .iloc[0]\n            .rename(name)\n        )\n\n    def timestamp_features(\n        self,\n        discretize: bool = True,\n        minutes: int = 60,\n        create_vocab: bool = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Create day of week and proportion into day columns.\n\n        Exposed as a method on Series for convenience.\n\n        Args:\n            discretize: Whether to discretize the hour column.\n            minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n            create_vocab: Whether to create the vocab column.\n\n        Returns:\n            DataFrame with features\n\n        Examples:\n            Create the features for some dates\n\n            ```python\n            ser = pd.Series(pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"h\"))\n\n            ser.cal.timestamp_features()\n            ```\n\n            ```text\n                        timestamp  day_of_week  hour\n            0   2023-01-01 00:00:00            6   0.0\n            1   2023-01-01 01:00:00            6   1.0\n            2   2023-01-01 02:00:00            6   2.0\n            3   2023-01-01 03:00:00            6   3.0\n            4   2023-01-01 04:00:00            6   4.0\n            ..                  ...          ...   ...\n            308 2023-01-13 20:00:00            4  20.0\n            309 2023-01-13 21:00:00            4  21.0\n            310 2023-01-13 22:00:00            4  22.0\n            311 2023-01-13 23:00:00            4  23.0\n            312 2023-01-14 00:00:00            5   0.0\n\n            [313 rows x 3 columns]\n            ```\n\n        \"\"\"\n        name = self._obj.name or \"timestamp\"\n        transformer = create_timestamp_feature_pipeline(\n            timestamp_col=name,\n            discretize=discretize,\n            minutes=minutes,\n            create_vocab=create_vocab,\n        )\n\n        return transformer.fit_transform(self._obj.rename(name).to_frame())\n\n    def conditional_probabilities(\n        self,\n        *,\n        level: int | str = 0,\n    ) -&gt; pd.Series:\n        \"\"\"Calculate conditional probabilities for each the row over the level.\n\n        Args:\n            level: level of the column MultiIndex.\n                Default 0 or day_of_week\n\n        Returns:\n            Series with conditional probabilities\n\n        \"\"\"\n\n        if not isinstance(self._obj.index, pd.MultiIndex):\n            raise ValueError(\n                \"Series is expected to have a MultiIndex with the last column as the vocab.\"\n            )\n\n        return self._obj.div(self._obj.groupby(level=level).sum(), level=level)\n\n    def plot(\n        self,\n        *,\n        duration: int = 5,\n        alpha: float = None,\n        cmap=None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        monday_start: bool = True,\n        ax: plt.Axes | None = None,\n    ) -&gt; plt.Axes:\n        \"\"\"Plot Series of timestamps as a calendar.\n\n        Args:\n            duration: duration of each event in minutes\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            day_labeler: DayLabeler instance\n            time_labeler: TimeLabeler instance\n            grid_lines: GridLines instance\n            monday_start: whether to start the week on Monday or Sunday\n            ax: matplotlib axis to plot on\n\n        Returns:\n            Modified matplotlib axis\n\n        \"\"\"\n        tmp_name = \"tmp_name\"\n        config = StartEndConfig(start=tmp_name, end=None, minutes=duration)\n\n        return plot_dataframe_as_calendar(\n            self._obj.rename(tmp_name).to_frame(),\n            config=config,\n            alpha=alpha,\n            cmap=cmap,\n            monday_start=monday_start,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n            ax=ax,\n        )\n\n    def plot_row(\n        self,\n        *,\n        alpha: float = None,\n        cmap=None,\n        day_labeler: DayLabeler = DayLabeler(),\n        time_labeler: TimeLabeler = TimeLabeler(),\n        grid_lines: GridLines = GridLines(),\n        monday_start: bool = True,\n        ax: plt.Axes | None = None,\n    ) -&gt; plt.Axes:\n        \"\"\"Plot Series of timestamps as a calendar.\n\n        Args:\n            alpha: alpha value for the color\n            cmap: function that maps floats to string colors\n            monday_start: whether to start the week on Monday or Sunday\n            ax: matplotlib axis to plot on\n\n        Returns:\n            Modified matplotlib axis\n\n        \"\"\"\n        return plot_series_as_calendar(\n            self._obj,\n            alpha=alpha,\n            cmap=cmap,\n            ax=ax,\n            monday_start=monday_start,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n        )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasSeriesAccessor.aggregate_events","title":"<code>aggregate_events(minutes=60, as_multiindex=True)</code>","text":"<p>Transform event level Series to row of wide format.</p> <p>Parameters:</p> Name Type Description Default <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>as_multiindex</code> <code>bool</code> <p>whether to use MultiIndex columns</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series that would be row of wide format</p> <p>Examples:</p> <p>Discretize datetime Series to 30 minutes</p> <pre><code>import pandas as pd\n\nimport matplotlib.pyplot as plt\n\nfrom latent_calendar.datasets import load_chicago_bikes\n\ndf_trips = load_chicago_bikes()\n\nstart_times = df_trips[\"started_at\"]\n\nagg_start_times = start_times.cal.aggregate_events(minutes=30)\nagg_start_times.cal.plot_row()\nplt.show()\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def aggregate_events(\n    self,\n    minutes: int = 60,\n    as_multiindex: bool = True,\n) -&gt; pd.Series:\n    \"\"\"Transform event level Series to row of wide format.\n\n    Args:\n        minutes: The number of minutes to discretize by.\n        as_multiindex: whether to use MultiIndex columns\n\n    Returns:\n        Series that would be row of wide format\n\n    Examples:\n        Discretize datetime Series to 30 minutes\n\n        ```python\n        import pandas as pd\n\n        import matplotlib.pyplot as plt\n\n        from latent_calendar.datasets import load_chicago_bikes\n\n        df_trips = load_chicago_bikes()\n\n        start_times = df_trips[\"started_at\"]\n\n        agg_start_times = start_times.cal.aggregate_events(minutes=30)\n        agg_start_times.cal.plot_row()\n        plt.show()\n\n\n        ```\n\n\n    \"\"\"\n    name = self._obj.name or \"timestamp\"\n    return (\n        self._obj.rename(name)\n        .to_frame()\n        .assign(tmp=1)\n        .cal.aggregate_events(\n            by=\"tmp\",\n            timestamp_col=name,\n            minutes=minutes,\n            as_multiindex=as_multiindex,\n        )\n        .iloc[0]\n        .rename(name)\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasSeriesAccessor.conditional_probabilities","title":"<code>conditional_probabilities(*, level=0)</code>","text":"<p>Calculate conditional probabilities for each the row over the level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>level of the column MultiIndex. Default 0 or day_of_week</p> <code>0</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series with conditional probabilities</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def conditional_probabilities(\n    self,\n    *,\n    level: int | str = 0,\n) -&gt; pd.Series:\n    \"\"\"Calculate conditional probabilities for each the row over the level.\n\n    Args:\n        level: level of the column MultiIndex.\n            Default 0 or day_of_week\n\n    Returns:\n        Series with conditional probabilities\n\n    \"\"\"\n\n    if not isinstance(self._obj.index, pd.MultiIndex):\n        raise ValueError(\n            \"Series is expected to have a MultiIndex with the last column as the vocab.\"\n        )\n\n    return self._obj.div(self._obj.groupby(level=level).sum(), level=level)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasSeriesAccessor.plot","title":"<code>plot(*, duration=5, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot Series of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int</code> <p>duration of each event in minutes</p> <code>5</code> <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Axes | None</code> <p>matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot(\n    self,\n    *,\n    duration: int = 5,\n    alpha: float = None,\n    cmap=None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n    ax: plt.Axes | None = None,\n) -&gt; plt.Axes:\n    \"\"\"Plot Series of timestamps as a calendar.\n\n    Args:\n        duration: duration of each event in minutes\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n        ax: matplotlib axis to plot on\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    tmp_name = \"tmp_name\"\n    config = StartEndConfig(start=tmp_name, end=None, minutes=duration)\n\n    return plot_dataframe_as_calendar(\n        self._obj.rename(tmp_name).to_frame(),\n        config=config,\n        alpha=alpha,\n        cmap=cmap,\n        monday_start=monday_start,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        grid_lines=grid_lines,\n        ax=ax,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasSeriesAccessor.plot_row","title":"<code>plot_row(*, alpha=None, cmap=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), monday_start=True, ax=None)</code>","text":"<p>Plot Series of timestamps as a calendar.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>alpha value for the color</p> <code>None</code> <code>cmap</code> <p>function that maps floats to string colors</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <code>ax</code> <code>Axes | None</code> <p>matplotlib axis to plot on</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def plot_row(\n    self,\n    *,\n    alpha: float = None,\n    cmap=None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n    ax: plt.Axes | None = None,\n) -&gt; plt.Axes:\n    \"\"\"Plot Series of timestamps as a calendar.\n\n    Args:\n        alpha: alpha value for the color\n        cmap: function that maps floats to string colors\n        monday_start: whether to start the week on Monday or Sunday\n        ax: matplotlib axis to plot on\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    return plot_series_as_calendar(\n        self._obj,\n        alpha=alpha,\n        cmap=cmap,\n        ax=ax,\n        monday_start=monday_start,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        grid_lines=grid_lines,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PandasSeriesAccessor.timestamp_features","title":"<code>timestamp_features(discretize=True, minutes=60, create_vocab=True)</code>","text":"<p>Create day of week and proportion into day columns.</p> <p>Exposed as a method on Series for convenience.</p> <p>Parameters:</p> Name Type Description Default <code>discretize</code> <code>bool</code> <p>Whether to discretize the hour column.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by. Ingored if <code>discretize</code> is False.</p> <code>60</code> <code>create_vocab</code> <code>bool</code> <p>Whether to create the vocab column.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with features</p> <p>Examples:</p> <p>Create the features for some dates</p> <pre><code>ser = pd.Series(pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"h\"))\n\nser.cal.timestamp_features()\n</code></pre> <pre><code>            timestamp  day_of_week  hour\n0   2023-01-01 00:00:00            6   0.0\n1   2023-01-01 01:00:00            6   1.0\n2   2023-01-01 02:00:00            6   2.0\n3   2023-01-01 03:00:00            6   3.0\n4   2023-01-01 04:00:00            6   4.0\n..                  ...          ...   ...\n308 2023-01-13 20:00:00            4  20.0\n309 2023-01-13 21:00:00            4  21.0\n310 2023-01-13 22:00:00            4  22.0\n311 2023-01-13 23:00:00            4  23.0\n312 2023-01-14 00:00:00            5   0.0\n\n[313 rows x 3 columns]\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def timestamp_features(\n    self,\n    discretize: bool = True,\n    minutes: int = 60,\n    create_vocab: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Create day of week and proportion into day columns.\n\n    Exposed as a method on Series for convenience.\n\n    Args:\n        discretize: Whether to discretize the hour column.\n        minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n        create_vocab: Whether to create the vocab column.\n\n    Returns:\n        DataFrame with features\n\n    Examples:\n        Create the features for some dates\n\n        ```python\n        ser = pd.Series(pd.date_range(\"2023-01-01\", \"2023-01-14\", freq=\"h\"))\n\n        ser.cal.timestamp_features()\n        ```\n\n        ```text\n                    timestamp  day_of_week  hour\n        0   2023-01-01 00:00:00            6   0.0\n        1   2023-01-01 01:00:00            6   1.0\n        2   2023-01-01 02:00:00            6   2.0\n        3   2023-01-01 03:00:00            6   3.0\n        4   2023-01-01 04:00:00            6   4.0\n        ..                  ...          ...   ...\n        308 2023-01-13 20:00:00            4  20.0\n        309 2023-01-13 21:00:00            4  21.0\n        310 2023-01-13 22:00:00            4  22.0\n        311 2023-01-13 23:00:00            4  23.0\n        312 2023-01-14 00:00:00            5   0.0\n\n        [313 rows x 3 columns]\n        ```\n\n    \"\"\"\n    name = self._obj.name or \"timestamp\"\n    transformer = create_timestamp_feature_pipeline(\n        timestamp_col=name,\n        discretize=discretize,\n        minutes=minutes,\n        create_vocab=create_vocab,\n    )\n\n    return transformer.fit_transform(self._obj.rename(name).to_frame())\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PolarsDataFrameAccessor","title":"<code>PolarsDataFrameAccessor</code>","text":"<p>Polars extension accessor for latent_calendar.</p> <p>Examples:</p> <p>Register the accessor on a Polars DataFrame and use it to aggregate events.</p> <pre><code>import polars as pl\n\n# Register the accessor\nimport latent_calendar\n\nurl = \"https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2025-01.parquet\"\ndf = pl.read_parquet(url)\n\ndf_agg = df.cal.aggregate_events(\n    \"PULocationID\",\n    \"tpep_pickup_datetime\",\n)\ndf_agg\n</code></pre> <pre><code>shape: (32_051, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PULocationID \u2506 day_of_week \u2506 hour \u2506 num_events \u2502\n\u2502 ---          \u2506 ---         \u2506 ---  \u2506 ---        \u2502\n\u2502 i32          \u2506 i8          \u2506 i64  \u2506 i32        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 76           \u2506 2           \u2506 15   \u2506 16         \u2502\n\u2502 143          \u2506 0           \u2506 21   \u2506 123        \u2502\n\u2502 153          \u2506 4           \u2506 7    \u2506 2          \u2502\n\u2502 18           \u2506 3           \u2506 20   \u2506 2          \u2502\n\u2502 100          \u2506 4           \u2506 11   \u2506 350        \u2502\n\u2502 \u2026            \u2506 \u2026           \u2506 \u2026    \u2506 \u2026          \u2502\n\u2502 178          \u2506 6           \u2506 1    \u2506 1          \u2502\n\u2502 180          \u2506 2           \u2506 14   \u2506 3          \u2502\n\u2502 82           \u2506 6           \u2506 2    \u2506 2          \u2502\n\u2502 151          \u2506 0           \u2506 5    \u2506 28         \u2502\n\u2502 67           \u2506 2           \u2506 13   \u2506 2          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pl.api.register_dataframe_namespace(\"cal\")\nclass PolarsDataFrameAccessor:\n    \"\"\"Polars extension accessor for latent_calendar.\n\n    Examples:\n\n    Register the accessor on a Polars DataFrame and use it to aggregate events.\n\n    ```python\n    import polars as pl\n\n    # Register the accessor\n    import latent_calendar\n\n    url = \"https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2025-01.parquet\"\n    df = pl.read_parquet(url)\n\n    df_agg = df.cal.aggregate_events(\n        \"PULocationID\",\n        \"tpep_pickup_datetime\",\n    )\n    df_agg\n    ```\n\n    ```text\n    shape: (32_051, 4)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 PULocationID \u2506 day_of_week \u2506 hour \u2506 num_events \u2502\n    \u2502 ---          \u2506 ---         \u2506 ---  \u2506 ---        \u2502\n    \u2502 i32          \u2506 i8          \u2506 i64  \u2506 i32        \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 76           \u2506 2           \u2506 15   \u2506 16         \u2502\n    \u2502 143          \u2506 0           \u2506 21   \u2506 123        \u2502\n    \u2502 153          \u2506 4           \u2506 7    \u2506 2          \u2502\n    \u2502 18           \u2506 3           \u2506 20   \u2506 2          \u2502\n    \u2502 100          \u2506 4           \u2506 11   \u2506 350        \u2502\n    \u2502 \u2026            \u2506 \u2026           \u2506 \u2026    \u2506 \u2026          \u2502\n    \u2502 178          \u2506 6           \u2506 1    \u2506 1          \u2502\n    \u2502 180          \u2506 2           \u2506 14   \u2506 3          \u2502\n    \u2502 82           \u2506 6           \u2506 2    \u2506 2          \u2502\n    \u2502 151          \u2506 0           \u2506 5    \u2506 28         \u2502\n    \u2502 67           \u2506 2           \u2506 13   \u2506 2          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ```\n\n    \"\"\"\n\n    def __init__(self, polars_obj):\n        self._obj = polars_obj\n\n    def timestamp_features(\n        self,\n        timestamp_col: str,\n        discretize: bool = True,\n        minutes: int = 60,\n        create_vocab: bool = True,\n    ):\n        \"\"\"Create day of week and proportion into day columns for event level DataFrame.\n\n        Exposed as a method on Polars DataFrame for convenience. Use `cal.aggregate_events` instead to create the wide format DataFrame.\n\n        Args:\n            timestamp_col: The name of the timestamp column.\n            discretize: Whether to discretize the hour column.\n            minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n            create_vocab: Whether to create the vocab column.\n\n        Returns:\n            DataFrame with features added\n\n        \"\"\"\n        transformer = create_timestamp_feature_pipeline(\n            timestamp_col=timestamp_col,\n            discretize=discretize,\n            create_vocab=create_vocab,\n            minutes=minutes,\n            output=\"polars\",\n        )\n\n        return transformer.fit_transform(self._obj)\n\n    def aggregate_events(\n        self,\n        by: str | list[str],\n        timestamp_col: str,\n        minutes: int = 60,\n        as_multiindex: bool = True,\n    ):\n        \"\"\"Transform event level Polars DataFrame to aggregated.\n\n        !!! note\n\n            Wide format is not supported in Polars yet.\n\n        Args:\n            by: column(s) to use as index\n            timestamp_col: column to use as timestamp\n            minutes: The number of minutes to discretize by.\n            as_multiindex: whether to use MultiIndex columns\n\n        Returns:\n            DataFrame in wide format\n\n        \"\"\"\n        return create_raw_to_vocab_transformer(\n            id_col=by if isinstance(by, str) else by[0],\n            timestamp_col=timestamp_col,\n            minutes=minutes,\n            additional_groups=None if isinstance(by, str) else by[1:],\n            as_multiindex=as_multiindex,\n            widen=False,\n        ).fit_transform(self._obj)\n\n    def chart(\n        self,\n        *,\n        title: str | None = None,\n        width: int = 400,\n        height: int = 300,\n        color_scheme: str = \"greens\",\n        monday_start: bool = True,\n        interactive: bool = True,\n        show_values: bool = True,\n    ):\n        \"\"\"Create an Altair calendar heatmap chart from Polars DataFrame.\n\n        Convenience wrapper that converts Polars DataFrame to pandas\n        and creates an Altair chart.\n\n        Note: Polars .cal.aggregate_events() returns long format with\n        (by_column, day_of_week, hour, num_events) columns which is\n        automatically handled by create_calendar_chart().\n\n        Args:\n            title: Chart title\n            width: Chart width in pixels\n            height: Chart height in pixels\n            color_scheme: Altair color scheme ('greens', 'blues', 'viridis', etc.)\n            monday_start: Start week on Monday (True) or Sunday (False)\n            interactive: Enable tooltips and zoom/pan\n            show_values: Show values in tooltips\n\n        Returns:\n            Altair Chart object\n\n        Examples:\n            Create chart from Polars aggregated data:\n\n            ```python\n            import polars as pl\n\n            chart = df.cal.aggregate_events(\"group\", \"timestamp\").cal.chart()\n            chart.save('calendar.html')\n            ```\n\n            Faceted chart:\n\n            ```python\n            (df.cal.aggregate_events(\"member_casual\", \"started_at\")\n               .cal.chart(color_scheme=\"greens\")\n               .facet(column='member_casual:N'))\n            ```\n\n        \"\"\"\n        from latent_calendar.html import create_calendar_chart\n\n        # Pass directly to create_calendar_chart - it handles Polars via narwhals\n        return create_calendar_chart(\n            self._obj,\n            title=title,\n            width=width,\n            height=height,\n            color_scheme=color_scheme,\n            monday_start=monday_start,\n            interactive=interactive,\n            show_values=show_values,\n        )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PolarsDataFrameAccessor.aggregate_events","title":"<code>aggregate_events(by, timestamp_col, minutes=60, as_multiindex=True)</code>","text":"<p>Transform event level Polars DataFrame to aggregated.</p> <p>Note</p> <p>Wide format is not supported in Polars yet.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | list[str]</code> <p>column(s) to use as index</p> required <code>timestamp_col</code> <code>str</code> <p>column to use as timestamp</p> required <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>as_multiindex</code> <code>bool</code> <p>whether to use MultiIndex columns</p> <code>True</code> <p>Returns:</p> Type Description <p>DataFrame in wide format</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def aggregate_events(\n    self,\n    by: str | list[str],\n    timestamp_col: str,\n    minutes: int = 60,\n    as_multiindex: bool = True,\n):\n    \"\"\"Transform event level Polars DataFrame to aggregated.\n\n    !!! note\n\n        Wide format is not supported in Polars yet.\n\n    Args:\n        by: column(s) to use as index\n        timestamp_col: column to use as timestamp\n        minutes: The number of minutes to discretize by.\n        as_multiindex: whether to use MultiIndex columns\n\n    Returns:\n        DataFrame in wide format\n\n    \"\"\"\n    return create_raw_to_vocab_transformer(\n        id_col=by if isinstance(by, str) else by[0],\n        timestamp_col=timestamp_col,\n        minutes=minutes,\n        additional_groups=None if isinstance(by, str) else by[1:],\n        as_multiindex=as_multiindex,\n        widen=False,\n    ).fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PolarsDataFrameAccessor.chart","title":"<code>chart(*, title=None, width=400, height=300, color_scheme='greens', monday_start=True, interactive=True, show_values=True)</code>","text":"<p>Create an Altair calendar heatmap chart from Polars DataFrame.</p> <p>Convenience wrapper that converts Polars DataFrame to pandas and creates an Altair chart.</p> <p>Note: Polars .cal.aggregate_events() returns long format with (by_column, day_of_week, hour, num_events) columns which is automatically handled by create_calendar_chart().</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <p>Chart title</p> <code>None</code> <code>width</code> <code>int</code> <p>Chart width in pixels</p> <code>400</code> <code>height</code> <code>int</code> <p>Chart height in pixels</p> <code>300</code> <code>color_scheme</code> <code>str</code> <p>Altair color scheme ('greens', 'blues', 'viridis', etc.)</p> <code>'greens'</code> <code>monday_start</code> <code>bool</code> <p>Start week on Monday (True) or Sunday (False)</p> <code>True</code> <code>interactive</code> <code>bool</code> <p>Enable tooltips and zoom/pan</p> <code>True</code> <code>show_values</code> <code>bool</code> <p>Show values in tooltips</p> <code>True</code> <p>Returns:</p> Type Description <p>Altair Chart object</p> <p>Examples:</p> <p>Create chart from Polars aggregated data:</p> <pre><code>import polars as pl\n\nchart = df.cal.aggregate_events(\"group\", \"timestamp\").cal.chart()\nchart.save('calendar.html')\n</code></pre> <p>Faceted chart:</p> <pre><code>(df.cal.aggregate_events(\"member_casual\", \"started_at\")\n   .cal.chart(color_scheme=\"greens\")\n   .facet(column='member_casual:N'))\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def chart(\n    self,\n    *,\n    title: str | None = None,\n    width: int = 400,\n    height: int = 300,\n    color_scheme: str = \"greens\",\n    monday_start: bool = True,\n    interactive: bool = True,\n    show_values: bool = True,\n):\n    \"\"\"Create an Altair calendar heatmap chart from Polars DataFrame.\n\n    Convenience wrapper that converts Polars DataFrame to pandas\n    and creates an Altair chart.\n\n    Note: Polars .cal.aggregate_events() returns long format with\n    (by_column, day_of_week, hour, num_events) columns which is\n    automatically handled by create_calendar_chart().\n\n    Args:\n        title: Chart title\n        width: Chart width in pixels\n        height: Chart height in pixels\n        color_scheme: Altair color scheme ('greens', 'blues', 'viridis', etc.)\n        monday_start: Start week on Monday (True) or Sunday (False)\n        interactive: Enable tooltips and zoom/pan\n        show_values: Show values in tooltips\n\n    Returns:\n        Altair Chart object\n\n    Examples:\n        Create chart from Polars aggregated data:\n\n        ```python\n        import polars as pl\n\n        chart = df.cal.aggregate_events(\"group\", \"timestamp\").cal.chart()\n        chart.save('calendar.html')\n        ```\n\n        Faceted chart:\n\n        ```python\n        (df.cal.aggregate_events(\"member_casual\", \"started_at\")\n           .cal.chart(color_scheme=\"greens\")\n           .facet(column='member_casual:N'))\n        ```\n\n    \"\"\"\n    from latent_calendar.html import create_calendar_chart\n\n    # Pass directly to create_calendar_chart - it handles Polars via narwhals\n    return create_calendar_chart(\n        self._obj,\n        title=title,\n        width=width,\n        height=height,\n        color_scheme=color_scheme,\n        monday_start=monday_start,\n        interactive=interactive,\n        show_values=show_values,\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PolarsDataFrameAccessor.timestamp_features","title":"<code>timestamp_features(timestamp_col, discretize=True, minutes=60, create_vocab=True)</code>","text":"<p>Create day of week and proportion into day columns for event level DataFrame.</p> <p>Exposed as a method on Polars DataFrame for convenience. Use <code>cal.aggregate_events</code> instead to create the wide format DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>discretize</code> <code>bool</code> <p>Whether to discretize the hour column.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by. Ingored if <code>discretize</code> is False.</p> <code>60</code> <code>create_vocab</code> <code>bool</code> <p>Whether to create the vocab column.</p> <code>True</code> <p>Returns:</p> Type Description <p>DataFrame with features added</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def timestamp_features(\n    self,\n    timestamp_col: str,\n    discretize: bool = True,\n    minutes: int = 60,\n    create_vocab: bool = True,\n):\n    \"\"\"Create day of week and proportion into day columns for event level DataFrame.\n\n    Exposed as a method on Polars DataFrame for convenience. Use `cal.aggregate_events` instead to create the wide format DataFrame.\n\n    Args:\n        timestamp_col: The name of the timestamp column.\n        discretize: Whether to discretize the hour column.\n        minutes: The number of minutes to discretize by. Ingored if `discretize` is False.\n        create_vocab: Whether to create the vocab column.\n\n    Returns:\n        DataFrame with features added\n\n    \"\"\"\n    transformer = create_timestamp_feature_pipeline(\n        timestamp_col=timestamp_col,\n        discretize=discretize,\n        create_vocab=create_vocab,\n        minutes=minutes,\n        output=\"polars\",\n    )\n\n    return transformer.fit_transform(self._obj)\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PolarsLazyFrameAccessor","title":"<code>PolarsLazyFrameAccessor</code>","text":"<p>LazyFrame extension accessor for latent_calendar.</p> <p>Examples:</p> <pre><code>import polars as pl\n\n# Register the accessor\nimport latent_calendar\n\nurl = \"https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2025-01.parquet\"\ndf = pl.read_parquet(url).lazy()\n\ndf_agg = df.cal.aggregate_events(\n    \"PULocationID\",\n    \"tpep_pickup_datetime\",\n)\ndf_agg.collect()\n</code></pre> <pre><code>shape: (32_051, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 PULocationID \u2506 day_of_week \u2506 hour \u2506 num_events \u2502\n\u2502 ---          \u2506 ---         \u2506 ---  \u2506 ---        \u2502\n\u2502 i32          \u2506 i8          \u2506 i64  \u2506 i32        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 207          \u2506 1           \u2506 8    \u2506 2          \u2502\n\u2502 232          \u2506 2           \u2506 10   \u2506 19         \u2502\n\u2502 97           \u2506 2           \u2506 9    \u2506 11         \u2502\n\u2502 74           \u2506 5           \u2506 10   \u2506 49         \u2502\n\u2502 92           \u2506 1           \u2506 6    \u2506 2          \u2502\n\u2502 \u2026            \u2506 \u2026           \u2506 \u2026    \u2506 \u2026          \u2502\n\u2502 1            \u2506 4           \u2506 16   \u2506 12         \u2502\n\u2502 34           \u2506 3           \u2506 14   \u2506 1          \u2502\n\u2502 74           \u2506 1           \u2506 23   \u2506 24         \u2502\n\u2502 102          \u2506 0           \u2506 5    \u2506 1          \u2502\n\u2502 212          \u2506 0           \u2506 10   \u2506 3          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>latent_calendar/extensions.py</code> <pre><code>@pl.api.register_lazyframe_namespace(\"cal\")\nclass PolarsLazyFrameAccessor:\n    \"\"\"LazyFrame extension accessor for latent_calendar.\n\n    Examples:\n\n    ```python\n    import polars as pl\n\n    # Register the accessor\n    import latent_calendar\n\n    url = \"https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2025-01.parquet\"\n    df = pl.read_parquet(url).lazy()\n\n    df_agg = df.cal.aggregate_events(\n        \"PULocationID\",\n        \"tpep_pickup_datetime\",\n    )\n    df_agg.collect()\n    ```\n\n    ```text\n    shape: (32_051, 4)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 PULocationID \u2506 day_of_week \u2506 hour \u2506 num_events \u2502\n    \u2502 ---          \u2506 ---         \u2506 ---  \u2506 ---        \u2502\n    \u2502 i32          \u2506 i8          \u2506 i64  \u2506 i32        \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 207          \u2506 1           \u2506 8    \u2506 2          \u2502\n    \u2502 232          \u2506 2           \u2506 10   \u2506 19         \u2502\n    \u2502 97           \u2506 2           \u2506 9    \u2506 11         \u2502\n    \u2502 74           \u2506 5           \u2506 10   \u2506 49         \u2502\n    \u2502 92           \u2506 1           \u2506 6    \u2506 2          \u2502\n    \u2502 \u2026            \u2506 \u2026           \u2506 \u2026    \u2506 \u2026          \u2502\n    \u2502 1            \u2506 4           \u2506 16   \u2506 12         \u2502\n    \u2502 34           \u2506 3           \u2506 14   \u2506 1          \u2502\n    \u2502 74           \u2506 1           \u2506 23   \u2506 24         \u2502\n    \u2502 102          \u2506 0           \u2506 5    \u2506 1          \u2502\n    \u2502 212          \u2506 0           \u2506 10   \u2506 3          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ```\n\n\n    \"\"\"\n\n    def __init__(self, obj):\n        self._obj = obj\n\n    def timestamp_features(\n        self,\n        timestamp_col: str,\n        minutes: int = 60,\n    ) -&gt; pl.LazyFrame:\n        \"\"\"Create day of week and proportion into day columns for event level LazyFrame.\"\"\"\n        return (\n            nw.from_native(self._obj)\n            .pipe(\n                create_timestamp_features,\n                timestamp_col=timestamp_col,\n            )\n            .pipe(\n                create_discretized_hour,\n                col=\"hour\",\n                minutes=minutes,\n            )\n            .pipe(\n                create_vocab,\n                hour_col=\"hour\",\n                day_of_week_col=\"day_of_week\",\n            )\n            .to_native()\n        )\n\n    def aggregate_events(\n        self,\n        by: str | list[str],\n        timestamp_col: str,\n        minutes: int = 60,\n    ) -&gt; pl.LazyFrame:\n        \"\"\"Aggregate the event level Polars LazyFrame to aggregated format.\"\"\"\n        return self._obj.pipe(\n            raw_to_aggregate,\n            id_col=by if isinstance(by, str) else by[0],\n            timestamp_col=timestamp_col,\n            minutes=minutes,\n            additional_groups=None if isinstance(by, str) else by[1:],\n        )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PolarsLazyFrameAccessor.aggregate_events","title":"<code>aggregate_events(by, timestamp_col, minutes=60)</code>","text":"<p>Aggregate the event level Polars LazyFrame to aggregated format.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def aggregate_events(\n    self,\n    by: str | list[str],\n    timestamp_col: str,\n    minutes: int = 60,\n) -&gt; pl.LazyFrame:\n    \"\"\"Aggregate the event level Polars LazyFrame to aggregated format.\"\"\"\n    return self._obj.pipe(\n        raw_to_aggregate,\n        id_col=by if isinstance(by, str) else by[0],\n        timestamp_col=timestamp_col,\n        minutes=minutes,\n        additional_groups=None if isinstance(by, str) else by[1:],\n    )\n</code></pre>"},{"location":"modules/extensions/#latent_calendar.extensions.PolarsLazyFrameAccessor.timestamp_features","title":"<code>timestamp_features(timestamp_col, minutes=60)</code>","text":"<p>Create day of week and proportion into day columns for event level LazyFrame.</p> Source code in <code>latent_calendar/extensions.py</code> <pre><code>def timestamp_features(\n    self,\n    timestamp_col: str,\n    minutes: int = 60,\n) -&gt; pl.LazyFrame:\n    \"\"\"Create day of week and proportion into day columns for event level LazyFrame.\"\"\"\n    return (\n        nw.from_native(self._obj)\n        .pipe(\n            create_timestamp_features,\n            timestamp_col=timestamp_col,\n        )\n        .pipe(\n            create_discretized_hour,\n            col=\"hour\",\n            minutes=minutes,\n        )\n        .pipe(\n            create_vocab,\n            hour_col=\"hour\",\n            day_of_week_col=\"day_of_week\",\n        )\n        .to_native()\n    )\n</code></pre>"},{"location":"modules/generate/","title":"Generate","text":"<p>Generate some fake data for various purposes.</p>"},{"location":"modules/generate/#latent_calendar.generate.sample_from_lda","title":"<code>sample_from_lda(components_prior, components_time_slots_prior, n_samples, random_state=None)</code>","text":"<p>Sample from LDA model.</p> <p>Parameters:</p> Name Type Description Default <code>components_prior</code> <code>ndarray | TensorVariable</code> <p>prior probability of each component (n_components, )</p> required <code>components_time_slots_prior</code> <code>ndarray | TensorVariable</code> <p>prior for time slots (n_components, n_time_slots)</p> required <code>n_samples</code> <code>ndarray</code> <p>number of samples for each user (n_user, )</p> required <code>random_state</code> <code>int | None</code> <p>random state for sampling</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>probability DataFrame (n_user, n_components) and event count DataFrame with (n_user, n_time_slots) with each row summing up to <code>n</code></p> Source code in <code>latent_calendar/generate.py</code> <pre><code>def sample_from_lda(\n    components_prior: np.ndarray | TensorVariable,\n    components_time_slots_prior: np.ndarray | TensorVariable,\n    n_samples: np.ndarray,\n    random_state: int | None = None,\n) -&gt; tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"Sample from LDA model.\n\n    Args:\n        components_prior: prior probability of each component (n_components, )\n        components_time_slots_prior: prior for time slots (n_components, n_time_slots)\n        n_samples: number of samples for each user (n_user, )\n        random_state: random state for sampling\n\n    Returns:\n        probability DataFrame (n_user, n_components) and event count DataFrame with (n_user, n_time_slots) with each row summing up to `n`\n\n    \"\"\"\n    rng = np.random.default_rng(random_state)\n\n    user_travel_style_data = []\n    user_time_slot_data = []\n\n    travel_style = pm.Dirichlet.dist(components_prior)\n    time_slot_styles = pm.Dirichlet.dist(components_time_slots_prior)\n\n    for n in n_samples:\n        _, user_time_slots = define_single_user_samples(\n            travel_style, time_slot_styles, n_samples=int(n)\n        )\n\n        user_travel_style_samples, user_time_slot_samples = pm.draw(\n            [travel_style, user_time_slots.sum(axis=0)], draws=1, random_seed=rng\n        )\n\n        user_travel_style_data.append(user_travel_style_samples)\n        user_time_slot_data.append(user_time_slot_samples)\n\n    df_user_travel_style = pd.DataFrame(user_travel_style_data)\n    df_user_time_slots = pd.DataFrame(user_time_slot_data)\n\n    return df_user_travel_style, df_user_time_slots\n</code></pre>"},{"location":"modules/generate/#latent_calendar.generate.wide_format_dataframe","title":"<code>wide_format_dataframe(n_rows, rate=1.0, random_state=None)</code>","text":"<p>Generate some data from Poisson distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n_rows</code> <code>int</code> <p>number of rows to generate</p> required <code>rate</code> <code>float</code> <p>rate parameter for Poisson distribution</p> <code>1.0</code> <code>random_state</code> <code>int | None</code> <p>random state for reproducibility</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns from FULL_VOCAB and n_rows rows</p> Source code in <code>latent_calendar/generate.py</code> <pre><code>def wide_format_dataframe(\n    n_rows: int,\n    rate: float = 1.0,\n    random_state: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Generate some data from Poisson distribution.\n\n    Args:\n        n_rows: number of rows to generate\n        rate: rate parameter for Poisson distribution\n        random_state: random state for reproducibility\n\n    Returns:\n        DataFrame with columns from FULL_VOCAB and n_rows rows\n\n    \"\"\"\n    if random_state is not None:\n        np.random.seed(random_state)\n\n    data = np.random.poisson(lam=rate, size=(n_rows, len(FULL_VOCAB)))\n\n    return pd.DataFrame(data, columns=FULL_VOCAB)\n</code></pre>"},{"location":"modules/html/","title":"HTML Module","text":"<p>The <code>html</code> module provides functions for converting calendar data into interactive HTML visualizations using Altair.</p>"},{"location":"modules/html/#installation","title":"Installation","text":"<pre><code>pip install latent-calendar[html]\n</code></pre> <p>This installs <code>altair&gt;=5.0.0</code> as an optional dependency.</p>"},{"location":"modules/html/#overview","title":"Overview","text":"<p>The HTML module transforms weekly calendar data (168 time slots) into interactive heatmap charts that can be:</p> <ul> <li>Embedded in web pages</li> <li>Used in Jupyter notebooks</li> <li>Integrated with mapping libraries (see Folium Integration)</li> </ul>"},{"location":"modules/html/#api-reference","title":"API Reference","text":"<p>HTML calendar generation using Altair for interactive visualizations.</p> <p>This module provides functions to create interactive calendar heatmaps using Altair and export them as HTML. These calendars can be embedded in web pages, Jupyter notebooks, or used with mapping libraries like Folium.</p> <p>Note: This module requires altair to be installed:</p> <pre><code>pip install latent-calendar[html]\n</code></pre> <p>Examples:</p> <p>Create a basic calendar chart:</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom latent_calendar.html import create_calendar_chart\n\n# Generate sample calendar data (168 time slots: 7 days \u00d7 24 hours)\ncalendar_data = pd.Series(np.random.rand(168))\n\n# Create interactive Altair chart\nchart = create_calendar_chart(\n    calendar_data,\n    title=\"Weekly Pattern\",\n    color_scheme='greens'\n)\n\n# Save as HTML file\nchart.save('calendar.html')\n</code></pre> <p>Create faceted chart directly from cal.aggregate_events:</p> <pre><code>from latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar.html import create_calendar_chart\n\n# Load data and aggregate by group\ndf = load_chicago_bikes()\ndf_agg = df.cal.aggregate_events(\"member_casual\", \"started_at\")\n\n# Works directly - automatically converts multi-row wide format!\nchart = create_calendar_chart(df_agg, width=250, height=200, color_scheme='viridis')\n\n# Apply faceting using Altair's .facet() method\nfaceted = chart.facet(column='member_casual:N')\nfaceted.save('faceted_calendar.html')\n</code></pre> <p>Chain methods for compact code:</p> <pre><code># Create chart with custom properties and faceting in one expression\nfaceted = (\n    create_calendar_chart(df_agg, color_scheme='viridis')\n    .properties(width=250, height=200, title=\"Bike Share Patterns\")\n    .facet(column='member_casual:N', columns=2)\n)\nfaceted.save('faceted_calendar.html')\n</code></pre> <p>Generate HTML string using Altair's to_html():</p> <pre><code># Get HTML string for embedding\nhtml = chart.to_html()\n\n# Or with custom embed options\nhtml = chart.to_html(embed_options={'actions': False})\n\n# Write to file or embed in application\nwith open('calendar.html', 'w') as f:\n    f.write(html)\n</code></pre>"},{"location":"modules/html/#latent_calendar.html.create_calendar_chart","title":"<code>create_calendar_chart(calendar_data, *, title=None, width=400, height=300, color_scheme='greens', monday_start=True, interactive=True, show_values=True)</code>","text":"<p>Create an Altair calendar heatmap chart.</p> <p>Generates an interactive calendar visualization showing patterns across the week (day-of-week on x-axis) and day (hour on y-axis) with color intensity representing the data values.</p> <p>The returned Altair Chart object can be: - Displayed directly in Jupyter notebooks - Saved to HTML file using chart.save('filename.html') - Converted to HTML string using chart.to_html() - Faceted using chart.facet() for comparing multiple groups</p> <p>Parameters:</p> Name Type Description Default <code>calendar_data</code> <p>Calendar data in wide or long format:           - Wide format: Series, numpy array, list, or DataFrame with 168 columns             (7 days \u00d7 24 hours). Multi-row DataFrames are automatically converted             to long format with the index used as the group column.           - Long format: DataFrame (pandas or Polars) with columns 'day_of_week',             'hour', 'value' (or 'num_events'), and optionally a group column for faceting.             Polars DataFrames are supported directly via narwhals.</p> required <code>title</code> <code>str | None</code> <p>Chart title. If None, no title is shown.</p> <code>None</code> <code>width</code> <code>int</code> <p>Chart width in pixels. Default is 400.</p> <code>400</code> <code>height</code> <code>int</code> <p>Chart height in pixels. Default is 300.</p> <code>300</code> <code>color_scheme</code> <code>str</code> <p>Altair color scheme name. Options include 'greens', 'blues',          'reds', 'oranges', 'purples', 'viridis', 'plasma', 'inferno',          'magma', 'cividis', etc. Default is 'greens'.</p> <code>'greens'</code> <code>monday_start</code> <code>bool</code> <p>Start week on Monday (True) or Sunday (False). Default is True.          Only applies when converting from wide format.</p> <code>True</code> <code>interactive</code> <code>bool</code> <p>Enable tooltips and zoom/pan interactions. Default is True.</p> <code>True</code> <code>show_values</code> <code>bool</code> <p>Show values in tooltips when interactive=True. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Chart</code> <p>Altair Chart object that can be displayed, saved, converted to HTML, or faceted</p> <p>Examples:</p> <p>Create and save to file:</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom latent_calendar.html import create_calendar_chart\n\ncalendar_data = pd.Series(np.random.rand(168))\nchart = create_calendar_chart(calendar_data, title=\"Weekly Pattern\")\nchart.save('calendar.html')\n</code></pre> <p>Create faceted chart directly from cal.aggregate_events output:</p> <pre><code>from latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar.html import create_calendar_chart\n\n# Load and aggregate data by group\ndf = load_chicago_bikes()\ndf_agg = df.cal.aggregate_events(\"member_casual\", \"started_at\")\n\n# Works directly - no need for dataframe_to_long_format!\nchart = create_calendar_chart(df_agg, width=250, height=200)\n\n# Apply faceting using Altair's .facet() method\n# The group column name comes from the DataFrame index name\nfaceted = chart.facet(column='member_casual:N')\nfaceted.save('faceted_calendar.html')\n</code></pre> <p>Chain methods for compact code:</p> <pre><code>faceted = (\n    create_calendar_chart(df_agg, color_scheme='viridis')\n    .properties(width=250, height=200, title=\"Bike Share Patterns\")\n    .facet(column='member_casual:N', columns=2)\n)\n</code></pre> <p>Customize appearance:</p> <pre><code>chart = create_calendar_chart(\n    calendar_data,\n    title=\"Custom Calendar\",\n    width=600,\n    height=400,\n    color_scheme='reds',\n    monday_start=False  # Start on Sunday\n)\n</code></pre> <p>Display in Jupyter notebooks:</p> <pre><code># Chart will display automatically in Jupyter\nchart = create_calendar_chart(calendar_data)\nchart  # Display in notebook\n</code></pre> Source code in <code>latent_calendar/html.py</code> <pre><code>def create_calendar_chart(\n    calendar_data,\n    *,\n    title: str | None = None,\n    width: int = 400,\n    height: int = 300,\n    color_scheme: str = \"greens\",\n    monday_start: bool = True,\n    interactive: bool = True,\n    show_values: bool = True,\n) -&gt; alt.Chart:\n    \"\"\"Create an Altair calendar heatmap chart.\n\n    Generates an interactive calendar visualization showing patterns across the week\n    (day-of-week on x-axis) and day (hour on y-axis) with color intensity representing\n    the data values.\n\n    The returned Altair Chart object can be:\n    - Displayed directly in Jupyter notebooks\n    - Saved to HTML file using chart.save('filename.html')\n    - Converted to HTML string using chart.to_html()\n    - Faceted using chart.facet() for comparing multiple groups\n\n    Args:\n        calendar_data: Calendar data in wide or long format:\n                      - Wide format: Series, numpy array, list, or DataFrame with 168 columns\n                        (7 days \u00d7 24 hours). Multi-row DataFrames are automatically converted\n                        to long format with the index used as the group column.\n                      - Long format: DataFrame (pandas or Polars) with columns 'day_of_week',\n                        'hour', 'value' (or 'num_events'), and optionally a group column for faceting.\n                        Polars DataFrames are supported directly via narwhals.\n        title: Chart title. If None, no title is shown.\n        width: Chart width in pixels. Default is 400.\n        height: Chart height in pixels. Default is 300.\n        color_scheme: Altair color scheme name. Options include 'greens', 'blues',\n                     'reds', 'oranges', 'purples', 'viridis', 'plasma', 'inferno',\n                     'magma', 'cividis', etc. Default is 'greens'.\n        monday_start: Start week on Monday (True) or Sunday (False). Default is True.\n                     Only applies when converting from wide format.\n        interactive: Enable tooltips and zoom/pan interactions. Default is True.\n        show_values: Show values in tooltips when interactive=True. Default is True.\n\n    Returns:\n        Altair Chart object that can be displayed, saved, converted to HTML, or faceted\n\n    Examples:\n        Create and save to file:\n\n        ```python\n        import pandas as pd\n        import numpy as np\n        from latent_calendar.html import create_calendar_chart\n\n        calendar_data = pd.Series(np.random.rand(168))\n        chart = create_calendar_chart(calendar_data, title=\"Weekly Pattern\")\n        chart.save('calendar.html')\n        ```\n\n        Create faceted chart directly from cal.aggregate_events output:\n\n        ```python\n        from latent_calendar.datasets import load_chicago_bikes\n        from latent_calendar.html import create_calendar_chart\n\n        # Load and aggregate data by group\n        df = load_chicago_bikes()\n        df_agg = df.cal.aggregate_events(\"member_casual\", \"started_at\")\n\n        # Works directly - no need for dataframe_to_long_format!\n        chart = create_calendar_chart(df_agg, width=250, height=200)\n\n        # Apply faceting using Altair's .facet() method\n        # The group column name comes from the DataFrame index name\n        faceted = chart.facet(column='member_casual:N')\n        faceted.save('faceted_calendar.html')\n        ```\n\n        Chain methods for compact code:\n\n        ```python\n        faceted = (\n            create_calendar_chart(df_agg, color_scheme='viridis')\n            .properties(width=250, height=200, title=\"Bike Share Patterns\")\n            .facet(column='member_casual:N', columns=2)\n        )\n        ```\n\n        Customize appearance:\n\n        ```python\n        chart = create_calendar_chart(\n            calendar_data,\n            title=\"Custom Calendar\",\n            width=600,\n            height=400,\n            color_scheme='reds',\n            monday_start=False  # Start on Sunday\n        )\n        ```\n\n        Display in Jupyter notebooks:\n\n        ```python\n        # Chart will display automatically in Jupyter\n        chart = create_calendar_chart(calendar_data)\n        chart  # Display in notebook\n        ```\n    \"\"\"\n    # Handle dataframes (pandas or Polars) using narwhals for uniform column detection\n    df_long = None\n    try:\n        df_nw = nw.from_native(calendar_data, eager_only=True)\n\n        # Check if it's already in long format\n        required_cols = {\"day_of_week\", \"hour\"}\n        has_value = \"value\" in df_nw.columns\n        has_num_events = \"num_events\" in df_nw.columns\n\n        if required_cols.issubset(set(df_nw.columns)) and (has_value or has_num_events):\n            # Already long format - rename num_events to value if needed, keep native type\n            if has_num_events and not has_value:\n                df_long = df_nw.rename({\"num_events\": \"value\"}).to_native()\n            else:\n                df_long = df_nw.to_native()\n        elif df_nw.shape[1] == 168:\n            # Wide format (168 columns) - convert via pandas\n            df_pandas = df_nw.to_pandas()\n            if len(df_pandas) == 1:\n                df_long = wide_to_long_format(\n                    df_pandas.iloc[0], monday_start=monday_start\n                )\n            else:\n                group_col = df_pandas.index.name or \"group\"\n                df_long = dataframe_to_long_format(\n                    df_pandas, group_col=group_col, monday_start=monday_start\n                )\n        else:\n            raise ValueError(\n                f\"DataFrame must have either (day_of_week, hour, value/num_events) columns \"\n                f\"for long format, or 168 columns for wide format. \"\n                f\"Got {df_nw.shape[1]} columns with columns: {df_nw.columns}\"\n            )\n    except (TypeError, AttributeError):\n        # Not a dataframe that narwhals can handle - try pandas fallback or array/list\n        if isinstance(calendar_data, pd.DataFrame):\n            required_cols = {\"day_of_week\", \"hour\", \"value\"}\n            if required_cols.issubset(calendar_data.columns):\n                df_long = calendar_data\n            elif calendar_data.shape[1] == 168:\n                if len(calendar_data) == 1:\n                    df_long = wide_to_long_format(\n                        calendar_data.iloc[0], monday_start=monday_start\n                    )\n                else:\n                    group_col = calendar_data.index.name or \"group\"\n                    df_long = dataframe_to_long_format(\n                        calendar_data, group_col=group_col, monday_start=monday_start\n                    )\n            else:\n                raise ValueError(\n                    f\"DataFrame must have either (day_of_week, hour, value) columns \"\n                    f\"for long format, or 168 columns for wide format. \"\n                    f\"Got {calendar_data.shape[1]} columns.\"\n                )\n        else:\n            # Series, array, or list - convert to long format\n            df_long = wide_to_long_format(calendar_data, monday_start=monday_start)\n\n    # Day labels\n    if monday_start:\n        day_labels = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\n    else:\n        day_labels = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"]\n\n    # Build tooltip configuration\n    tooltip_list = []\n    if show_values and interactive:\n        tooltip_list = [\n            alt.Tooltip(\"day_of_week:O\", title=\"Day\"),\n            alt.Tooltip(\"hour:O\", title=\"Hour\"),\n            alt.Tooltip(\"value:Q\", title=\"Value\", format=\".2f\"),\n        ]\n\n    # Create label expression for day names\n    label_expr = f\"datum.value === 0 ? '{day_labels[0]}' : datum.value === 1 ? '{day_labels[1]}' : datum.value === 2 ? '{day_labels[2]}' : datum.value === 3 ? '{day_labels[3]}' : datum.value === 4 ? '{day_labels[4]}' : datum.value === 5 ? '{day_labels[5]}' : '{day_labels[6]}'\"\n\n    # Build chart\n    chart = (\n        alt.Chart(df_long)\n        .mark_rect()\n        .encode(\n            x=alt.X(\n                \"day_of_week:O\",\n                axis=alt.Axis(labelExpr=label_expr, title=\"Day of Week\", labelAngle=0),\n                scale=alt.Scale(domain=list(range(7))),\n            ),\n            y=alt.Y(\n                \"hour:O\",\n                axis=alt.Axis(title=\"Hour of Day\"),\n                scale=alt.Scale(domain=list(range(24))),\n            ),\n            color=alt.Color(\n                \"value:Q\",\n                scale=alt.Scale(scheme=color_scheme),\n                legend=alt.Legend(title=\"Count\"),\n            ),\n            tooltip=tooltip_list,\n        )\n    )\n\n    # Set properties, only add title if provided\n    if title is not None:\n        chart = chart.properties(width=width, height=height, title=title)\n    else:\n        chart = chart.properties(width=width, height=height)\n\n    # Add interactivity if requested\n    if interactive:\n        chart = chart.interactive()\n\n    return chart\n</code></pre>"},{"location":"modules/html/#latent_calendar.html.dataframe_to_long_format","title":"<code>dataframe_to_long_format(df_wide, group_col='group', monday_start=True)</code>","text":"<p>Convert wide calendar DataFrame with multiple rows to long format for Altair faceting.</p> <p>Transforms a DataFrame where each row represents a different group's calendar data (7 days \u00d7 24 hours = 168 columns) into a long-format DataFrame suitable for faceted Altair visualizations.</p> <p>Parameters:</p> Name Type Description Default <code>df_wide</code> <code>DataFrame</code> <p>DataFrame where each row is a calendar (168 columns) and index contains group names.     Can be the result of df.cal.aggregate_events(\"group_col\", \"timestamp_col\").</p> required <code>group_col</code> <code>str</code> <p>Name for the column that will contain the group identifiers from the index.       Default is \"group\".</p> <code>'group'</code> <code>monday_start</code> <code>bool</code> <p>Start week on Monday (True) or Sunday (False). Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: group, day_of_week (int 0-6), hour (int 0-23), value (float)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If DataFrame columns don't have exactly 168 values per row</p> <p>Examples:</p> <p>Convert multi-row aggregated data:</p> <pre><code>from latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar.html import dataframe_to_long_format\n\ndf = load_chicago_bikes()\ndf_agg = df.cal.aggregate_events(\"member_casual\", \"started_at\")\n\n# Convert to long format for faceting\ndf_long = dataframe_to_long_format(df_agg, group_col=\"rider_type\")\nprint(df_long.head())\n#    rider_type  day_of_week  hour  value\n# 0      member            0     0   42.0\n# 1      member            0     1   28.0\n# 2      member            0     2   15.0\n# 3      member            0     3    8.0\n# 4      member            0     4   12.0\n</code></pre> Source code in <code>latent_calendar/html.py</code> <pre><code>def dataframe_to_long_format(\n    df_wide: pd.DataFrame,\n    group_col: str = \"group\",\n    monday_start: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"Convert wide calendar DataFrame with multiple rows to long format for Altair faceting.\n\n    Transforms a DataFrame where each row represents a different group's calendar data\n    (7 days \u00d7 24 hours = 168 columns) into a long-format DataFrame suitable for\n    faceted Altair visualizations.\n\n    Args:\n        df_wide: DataFrame where each row is a calendar (168 columns) and index contains group names.\n                Can be the result of df.cal.aggregate_events(\"group_col\", \"timestamp_col\").\n        group_col: Name for the column that will contain the group identifiers from the index.\n                  Default is \"group\".\n        monday_start: Start week on Monday (True) or Sunday (False). Default is True.\n\n    Returns:\n        DataFrame with columns: group, day_of_week (int 0-6), hour (int 0-23), value (float)\n\n    Raises:\n        ValueError: If DataFrame columns don't have exactly 168 values per row\n\n    Examples:\n        Convert multi-row aggregated data:\n\n        ```python\n        from latent_calendar.datasets import load_chicago_bikes\n        from latent_calendar.html import dataframe_to_long_format\n\n        df = load_chicago_bikes()\n        df_agg = df.cal.aggregate_events(\"member_casual\", \"started_at\")\n\n        # Convert to long format for faceting\n        df_long = dataframe_to_long_format(df_agg, group_col=\"rider_type\")\n        print(df_long.head())\n        #    rider_type  day_of_week  hour  value\n        # 0      member            0     0   42.0\n        # 1      member            0     1   28.0\n        # 2      member            0     2   15.0\n        # 3      member            0     3    8.0\n        # 4      member            0     4   12.0\n        ```\n    \"\"\"\n    # Get the number of columns (should be 168)\n    n_cols = df_wide.shape[1]\n\n    if n_cols != 168:\n        raise ValueError(\n            f\"Expected 168 columns (7 days \u00d7 24 hours), got {n_cols}. \"\n            f\"Make sure each row in df_wide is in calendar format with 168 time slots.\"\n        )\n\n    # Convert each row to long format and combine\n    long_dfs = []\n    for idx, row in df_wide.iterrows():\n        # Convert single row to long format\n        df_row_long = wide_to_long_format(row.values, monday_start=monday_start)\n        # Add group identifier\n        df_row_long[group_col] = str(idx)\n        long_dfs.append(df_row_long)\n\n    # Combine all rows\n    df_long = pd.concat(long_dfs, ignore_index=True)\n\n    # Reorder columns: group, day_of_week, hour, value\n    df_long = df_long.loc[:, [group_col, \"day_of_week\", \"hour\", \"value\"]]\n\n    return df_long\n</code></pre>"},{"location":"modules/html/#latent_calendar.html.wide_to_long_format","title":"<code>wide_to_long_format(calendar_data, monday_start=True)</code>","text":"<p>Convert wide calendar format (168 cols) to long format for Altair.</p> <p>Transforms a calendar in wide format (7 days \u00d7 24 hours = 168 values) into a long-format DataFrame suitable for Altair visualization with columns for day_of_week, hour, and value.</p> <p>This function leverages the existing iterate_long_array() generator from the plot.iterate module, demonstrating how dataclasses can be easily converted to DataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>calendar_data</code> <p>Series or array-like with 168 values (7 days \u00d7 24 hours).           Can be pandas Series, numpy array, or list.</p> required <code>monday_start</code> <code>bool</code> <p>Start week on Monday (True) or Sunday (False). Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: day_of_week (int 0-6), hour (int 0-23), value (float)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If calendar_data does not have exactly 168 values</p> <p>Examples:</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom latent_calendar.html import wide_to_long_format\n\n# Create sample calendar data\ncalendar_data = pd.Series(np.random.rand(168))\n\n# Convert to long format\ndf_long = wide_to_long_format(calendar_data)\nprint(df_long.head())\n#    day_of_week  hour     value\n# 0            0     0  0.417022\n# 1            0     1  0.720324\n# 2            0     2  0.000114\n# 3            0     3  0.302333\n# 4            0     4  0.146756\n</code></pre> <p>With Sunday start:</p> <pre><code>df_long = wide_to_long_format(calendar_data, monday_start=False)\n</code></pre> Source code in <code>latent_calendar/html.py</code> <pre><code>def wide_to_long_format(calendar_data, monday_start: bool = True) -&gt; pd.DataFrame:\n    \"\"\"Convert wide calendar format (168 cols) to long format for Altair.\n\n    Transforms a calendar in wide format (7 days \u00d7 24 hours = 168 values) into\n    a long-format DataFrame suitable for Altair visualization with columns for\n    day_of_week, hour, and value.\n\n    This function leverages the existing iterate_long_array() generator from\n    the plot.iterate module, demonstrating how dataclasses can be easily converted\n    to DataFrames.\n\n    Args:\n        calendar_data: Series or array-like with 168 values (7 days \u00d7 24 hours).\n                      Can be pandas Series, numpy array, or list.\n        monday_start: Start week on Monday (True) or Sunday (False). Default is True.\n\n    Returns:\n        DataFrame with columns: day_of_week (int 0-6), hour (int 0-23), value (float)\n\n    Raises:\n        ValueError: If calendar_data does not have exactly 168 values\n\n    Examples:\n        ```python\n        import pandas as pd\n        import numpy as np\n        from latent_calendar.html import wide_to_long_format\n\n        # Create sample calendar data\n        calendar_data = pd.Series(np.random.rand(168))\n\n        # Convert to long format\n        df_long = wide_to_long_format(calendar_data)\n        print(df_long.head())\n        #    day_of_week  hour     value\n        # 0            0     0  0.417022\n        # 1            0     1  0.720324\n        # 2            0     2  0.000114\n        # 3            0     3  0.302333\n        # 4            0     4  0.146756\n        ```\n\n        With Sunday start:\n\n        ```python\n        df_long = wide_to_long_format(calendar_data, monday_start=False)\n        ```\n    \"\"\"\n\n    # Convert to numpy array\n    values = np.array(calendar_data).ravel()\n\n    # Validate 168 values for Altair hourly visualization\n    if len(values) != 168:\n        raise ValueError(\n            f\"Expected 168 values (7 days \u00d7 24 hours), got {len(values)}. \"\n            f\"Make sure calendar_data is in wide format with 168 time slots.\"\n        )\n\n    # Use existing iterator to create dataclass objects, then convert to DataFrame\n    # CalendarData has (day, start, end, value) fields\n    df = pd.DataFrame(iterate_long_array(values))\n\n    # Rename columns for Altair: day -&gt; day_of_week, start -&gt; hour\n    # For hourly data, start is already 0, 1, 2, ..., 23 (integers as floats)\n    df = df.rename(columns={\"day\": \"day_of_week\", \"start\": \"hour\"})\n\n    # Drop 'end' column (not needed for Altair)\n    df = df[[\"day_of_week\", \"hour\", \"value\"]]\n\n    # Convert hour to int (it's whole numbers for hourly data)\n    df[\"hour\"] = df[\"hour\"].astype(int)\n\n    # Adjust for Sunday start if needed\n    if not monday_start:\n        # Shift: Mon(0)\u2192Tue(1), ..., Sat(5)\u2192Sun(6), Sun(6)\u2192Mon(0)\n        df[\"day_of_week\"] = (df[\"day_of_week\"] + 1) % 7\n\n    return df\n</code></pre>"},{"location":"modules/html/#usage-examples","title":"Usage Examples","text":""},{"location":"modules/html/#basic-html-generation","title":"Basic HTML Generation","text":"<pre><code>from latent_calendar.datasets import load_ufo_sightings\nfrom latent_calendar.html import create_calendar_chart\n\n# Load and aggregate data\ndf = load_ufo_sightings()\ndf_states = df[df['country'] == 'us'].cal.aggregate_events(\n    by='state/province',\n    timestamp_col='Date_time'\n)\n\n# Create chart for California\nchart = create_calendar_chart(\n    df_states.loc['ca'],\n    title=\"California UFO Sightings\",\n    width=500,\n    height=350,\n    color_scheme='greens'\n)\n\n# Save directly to file\nchart.save('calendar.html')\n\n# Or get HTML string for embedding\nhtml = chart.to_html()\nwith open('calendar.html', 'w') as f:\n    f.write(html)\n</code></pre>"},{"location":"modules/html/#faceted-charts-comparing-multiple-groups","title":"Faceted Charts (Comparing Multiple Groups)","text":"<p>Create side-by-side calendar comparisons using Altair's <code>.facet()</code> method.</p> <p>Direct usage with <code>cal.aggregate_events()</code>:</p> <pre><code>from latent_calendar.datasets import load_chicago_bikes\nfrom latent_calendar.html import create_calendar_chart\n\n# Load data and aggregate by group\ndf = load_chicago_bikes()\ndf_agg = df.cal.aggregate_events(\"member_casual\", \"started_at\")\n\n# Create base chart directly from aggregated data\n# The function automatically detects multi-row format and converts it\nchart = create_calendar_chart(\n    df_agg,\n    width=250,\n    height=200,\n    color_scheme='viridis'\n)\n\n# Apply faceting using Altair's .facet() method\n# Use the index name from aggregate_events as the grouping column\nfaceted = chart.facet(column='member_casual:N')\nfaceted.save('faceted_calendar.html')\n</code></pre> <p>Chain methods for compact code:</p> <pre><code># Create chart with custom properties and faceting in one expression\nfaceted = (\n    create_calendar_chart(df_agg, color_scheme='viridis')\n    .properties(width=250, height=200, title=\"Bike Share Patterns\")\n    .facet(column='member_casual:N', columns=2)\n)\nfaceted.save('faceted_calendar.html')\n</code></pre> <p>Using explicit conversion (optional):</p> <p>If you need more control over the group column name, you can still use <code>dataframe_to_long_format()</code>:</p> <pre><code>from latent_calendar.html import dataframe_to_long_format\n\n# Explicitly convert with custom group column name\ndf_long = dataframe_to_long_format(df_agg, group_col=\"rider_type\")\n\nchart = create_calendar_chart(df_long)\nfaceted = chart.facet(column='rider_type:N')\n</code></pre> <p>Advanced faceting options:</p> <pre><code># Two-dimensional faceting (e.g., by season and rider type)\nfaceted_2d = chart.facet(\n    row='season:N',\n    column='rider_type:N'\n)\n\n# Custom number of columns in facet grid\nfaceted = chart.facet(\n    column='station_name:N',\n    columns=3  # 3 charts per row\n)\n\n# Adjust sizing before faceting\nsmaller_chart = chart.properties(width=200, height=150)\nfaceted = smaller_chart.facet(column='group:N')\n</code></pre>"},{"location":"modules/html/#creating-altair-chart-objects","title":"Creating Altair Chart Objects","text":"<pre><code>from latent_calendar.html import create_calendar_chart\n\n# Create a chart object for further customization\nchart = create_calendar_chart(\n    df_states.loc['ca'],\n    title=\"Weekly Pattern\",\n    width=400,\n    height=300,\n    color_scheme='viridis',\n    show_values=True,\n    monday_start=True\n)\n\n# Customize further with Altair API\nchart = chart.configure_view(strokeWidth=0)\n\n# Export as HTML\nhtml = chart.to_html()\n</code></pre>"},{"location":"modules/html/#jupyter-notebook-display","title":"Jupyter Notebook Display","text":"<pre><code>from latent_calendar.html import create_calendar_chart\n\n# Create and display chart in notebook\nchart = create_calendar_chart(\n    calendar_data,\n    title=\"Activity Pattern\",\n    color_scheme='greens'\n)\n\n# Chart displays automatically in Jupyter\nchart\n</code></pre>"},{"location":"modules/html/#data-format-conversion","title":"Data Format Conversion","text":"<pre><code>from latent_calendar.html import wide_to_long_format, dataframe_to_long_format\n\n# Convert single row (168 columns) to long format\ndf_long = wide_to_long_format(\n    df_states.loc['ca'],\n    monday_start=True\n)\n\nprint(df_long)\n# Output:\n#    day_of_week  hour  value\n# 0            0     0     45\n# 1            0     1     32\n# ...\n# 167          6    23     67\n\n# Convert multiple rows for faceting\ndf_long_multi = dataframe_to_long_format(\n    df_states.head(3),  # Multiple states\n    group_col=\"state\"\n)\n\nprint(df_long_multi)\n# Output:\n#     state  day_of_week  hour  value\n# 0      ca            0     0   45.0\n# 1      ca            0     1   32.0\n# ...\n# 503    tx            6    23   28.0\n</code></pre>"},{"location":"modules/html/#color-schemes","title":"Color Schemes","text":"<p>The module supports all Altair/Vega color schemes. Default is <code>'greens'</code>.</p> <p>Sequential (single-hue): - <code>'greens'</code>, <code>'blues'</code>, <code>'reds'</code>, <code>'purples'</code>, <code>'greys'</code>, <code>'oranges'</code></p> <p>Perceptual (multi-hue): - <code>'viridis'</code>, <code>'plasma'</code>, <code>'inferno'</code>, <code>'magma'</code>, <code>'cividis'</code>, <code>'turbo'</code></p> <p>Diverging: - <code>'redblue'</code>, <code>'redgrey'</code>, <code>'blueorange'</code>, <code>'purpleorange'</code></p> <p>Categorical: - <code>'category10'</code>, <code>'category20'</code>, <code>'tableau10'</code>, <code>'tableau20'</code></p> <p>See Altair Color Schemes for the complete list.</p>"},{"location":"modules/html/#interactivity","title":"Interactivity","text":"<p>By default, charts include:</p> <ul> <li>Zoom/Pan: Mouse wheel to zoom, click and drag to pan</li> <li>Tooltips: Hover over cells to see exact values</li> <li>Reset: Double-click to reset view</li> </ul> <p>Disable interactivity: <pre><code>chart = create_calendar_chart(data, interactive=False)\n</code></pre></p>"},{"location":"modules/html/#customization-tips","title":"Customization Tips","text":""},{"location":"modules/html/#compact-charts-no-values","title":"Compact Charts (No Values)","text":"<p>For smaller file sizes and cleaner appearance: <pre><code>chart = create_calendar_chart(\n    data,\n    show_values=False,  # Hide numeric labels\n    width=350,          # Smaller dimensions\n    height=250\n)\nhtml = chart.to_html()\n</code></pre></p>"},{"location":"modules/html/#sunday-week-start","title":"Sunday Week Start","text":"<p>To start weeks on Sunday instead of Monday: <pre><code>chart = create_calendar_chart(data, monday_start=False)\n</code></pre></p>"},{"location":"modules/html/#custom-embed-options","title":"Custom Embed Options","text":"<p>Control Altair rendering behavior: <pre><code>chart = create_calendar_chart(data)\nhtml = chart.to_html(embed_options={\n    'mode': 'vega-lite',\n    'renderer': 'svg',  # Use SVG instead of Canvas\n    'actions': False    # Hide action menu\n})\n</code></pre></p>"},{"location":"modules/html/#technical-details","title":"Technical Details","text":""},{"location":"modules/html/#data-flow","title":"Data Flow","text":"<p>Single Calendar: <pre><code>Input: pd.Series with 168 values\n  \u2193\nwide_to_long_format()\n  \u2193\nDataFrame with (day_of_week, hour, value) columns\n  \u2193\ncreate_calendar_chart()\n  \u2193\nAltair Chart object\n  \u2193\nchart.to_html() or chart.save()\n  \u2193\nStandalone HTML document\n</code></pre></p> <p>Faceted Calendars: <pre><code>Input: pd.DataFrame with multiple rows \u00d7 168 columns\n  \u2193\ncreate_calendar_chart()  [auto-converts to long format internally]\n  \u2193\nAltair Chart object\n  \u2193\nchart.facet(column='group:N')\n  \u2193\nFaceted Altair Chart object\n  \u2193\nchart.to_html() or chart.save()\n  \u2193\nStandalone HTML document\n\nNote: Multi-row wide DataFrames are automatically converted to long format.\nThe index name is used as the group column (or \"group\" if unnamed).\n</code></pre></p>"},{"location":"modules/html/#chart-structure","title":"Chart Structure","text":"<p>The generated Altair chart uses:</p> <ul> <li>Mark Type: <code>rect</code> (rectangles for heatmap cells)</li> <li>Encoding:</li> <li>X-axis: Hour of day (0-23)</li> <li>Y-axis: Day of week (0-6)</li> <li>Color: Event count/value</li> <li>Tooltip: Day name, hour, value</li> <li>Scale: Sequential color scale based on data range</li> </ul>"},{"location":"modules/html/#html-output-format","title":"HTML Output Format","text":"<p>The HTML includes:</p> <ul> <li>Complete <code>&lt;!DOCTYPE html&gt;</code> document</li> <li>Embedded Vega-Lite specification</li> <li>Bundled Vega/Vega-Lite/Vega-Embed JavaScript libraries</li> <li>All styles and scripts for standalone viewing</li> </ul> <p>File size varies by chart complexity: - Simple chart with <code>show_values=False</code>: ~50 KB - Chart with values and large dataset: ~80-120 KB</p>"},{"location":"modules/html/#see-also","title":"See Also","text":"<ul> <li>Folium Integration - Use calendars in maps</li> <li><code>.cal</code> Accessor - Data aggregation and preparation</li> <li>Altair Documentation - Chart customization</li> <li>UFO Sightings Example - Example dataset</li> </ul>"},{"location":"modules/model/","title":"Model","text":"<p>Models for the joint distribution of weekly calendar data.</p> <pre><code>model = LatentCalendar(n_components=3, random_state=42)\n\nX = df_wide.to_numpy()\nmodel.fit(X)\n\nX_latent = model.transform(X)\nX_pred = model.predict(X)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.ConjugateModel","title":"<code>ConjugateModel</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Conjugate model for the calendar joint distribution.</p> <p>This is a wrapper around the conjugate model for the multinomial distribution. It is a wrapper around the Dirichlet distribution.</p> <p>This doesn't use dimensionality reduction, but it does use the conjugate model.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray | None</code> <p>(n_times,) prior for each hour of the day. If None, then the prior is the average of the data.</p> <code>None</code> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class ConjugateModel(BaseEstimator, TransformerMixin):\n    \"\"\"Conjugate model for the calendar joint distribution.\n\n    This is a wrapper around the conjugate model for the multinomial\n    distribution. It is a wrapper around the Dirichlet distribution.\n\n    This doesn't use dimensionality reduction, but it does use the\n    conjugate model.\n\n    Args:\n        a: (n_times,) prior for each hour of the day. If None, then\n            the prior is the average of the data.\n\n    \"\"\"\n\n    def __init__(self, a: np.ndarray | None = None) -&gt; None:\n        self.a = a\n\n    def fit(self, X, y=None) -&gt; \"ConjugateModel\":\n        \"\"\"Fit the conjugate model.\"\"\"\n        if self.a is None:\n            self.a = hourly_prior(X)\n\n        self.prior_ = Dirichlet(alpha=self.a)\n        return self\n\n    def transform(self, X, y=None) -&gt; np.ndarray:\n        return multinomial_dirichlet(x=X, prior=self.prior_).dist.mean()\n\n    def predict(self, X, y=None) -&gt; np.ndarray:\n        return self.transform(X, y=y)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.ConjugateModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Fit the conjugate model.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"ConjugateModel\":\n    \"\"\"Fit the conjugate model.\"\"\"\n    if self.a is None:\n        self.a = hourly_prior(X)\n\n    self.prior_ = Dirichlet(alpha=self.a)\n    return self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel","title":"<code>DummyModel</code>","text":"<p>               Bases: <code>LatentCalendar</code></p> <p>Return even probability of a latent.</p> <p>This can be used as the worse possible baseline.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class DummyModel(LatentCalendar):\n    \"\"\"Return even probability of a latent.\n\n    This can be used as the worse possible baseline.\n\n    \"\"\"\n\n    def fit(self, X, y=None) -&gt; \"DummyModel\":\n        \"\"\"All components are equal probabilty of every hour.\"\"\"\n        # Even probabilty for every thing\n        self.n_components = 1\n        TIME_SLOTS = X.shape[1]\n        EVEN_PROBABILITY = 1 / TIME_SLOTS\n        self.components_ = np.ones((self.n_components, TIME_SLOTS)) * EVEN_PROBABILITY\n\n        return self\n\n    def transform(self, X, y=None) -&gt; np.ndarray:\n        \"\"\"Everyone has equal probability of being in each group.\"\"\"\n        nrows = len(X)\n\n        return np.ones((nrows, self.n_components)) / self.n_components\n\n    @classmethod\n    def create(cls) -&gt; \"DummyModel\":\n        \"\"\"Return a dummy model ready for transforming and predicting.\"\"\"\n        model = cls()\n        model.fit(X=None)\n\n        return model\n\n    @classmethod\n    def from_prior(cls, prior: np.ndarray) -&gt; \"DummyModel\":\n        \"\"\"Return a dummy model from a prior.\"\"\"\n        model = cls()\n        model.components_ = prior[np.newaxis, :]\n        model.n_components = 1\n\n        return model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.create","title":"<code>create()</code>  <code>classmethod</code>","text":"<p>Return a dummy model ready for transforming and predicting.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>@classmethod\ndef create(cls) -&gt; \"DummyModel\":\n    \"\"\"Return a dummy model ready for transforming and predicting.\"\"\"\n    model = cls()\n    model.fit(X=None)\n\n    return model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>All components are equal probabilty of every hour.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"DummyModel\":\n    \"\"\"All components are equal probabilty of every hour.\"\"\"\n    # Even probabilty for every thing\n    self.n_components = 1\n    TIME_SLOTS = X.shape[1]\n    EVEN_PROBABILITY = 1 / TIME_SLOTS\n    self.components_ = np.ones((self.n_components, TIME_SLOTS)) * EVEN_PROBABILITY\n\n    return self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.from_prior","title":"<code>from_prior(prior)</code>  <code>classmethod</code>","text":"<p>Return a dummy model from a prior.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>@classmethod\ndef from_prior(cls, prior: np.ndarray) -&gt; \"DummyModel\":\n    \"\"\"Return a dummy model from a prior.\"\"\"\n    model = cls()\n    model.components_ = prior[np.newaxis, :]\n    model.n_components = 1\n\n    return model\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.DummyModel.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Everyone has equal probability of being in each group.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def transform(self, X, y=None) -&gt; np.ndarray:\n    \"\"\"Everyone has equal probability of being in each group.\"\"\"\n    nrows = len(X)\n\n    return np.ones((nrows, self.n_components)) / self.n_components\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar","title":"<code>LatentCalendar</code>","text":"<p>               Bases: <code>LatentDirichletAllocation</code></p> <p>Model weekly calendar data as a mixture of multinomial distributions.</p> <p>Adapted from sklearn's Latent Dirichlet Allocation model.</p> <p>Provides a <code>predict</code> method that returns the marginal probability of each time slot for a given row and a <code>transform</code> method that returns the latent representation of each row.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class LatentCalendar(BaseLDA):\n    \"\"\"Model weekly calendar data as a mixture of multinomial distributions.\n\n    Adapted from sklearn's [Latent Dirichlet Allocation](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.LatentDirichletAllocation.html) model.\n\n    Provides a `predict` method that returns the marginal probability of each time slot for a given row and\n    a `transform` method that returns the latent representation of each row.\n\n    \"\"\"\n\n    @property\n    def normalized_components_(self) -&gt; np.ndarray:\n        \"\"\"Components that each sum to 1.\"\"\"\n        return self.components_ / self.components_.sum(axis=1)[:, np.newaxis]\n\n    def joint_distribution(self, X_latent: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Marginalize out the components.\"\"\"\n        return joint_distribution(\n            X_latent=X_latent, components=self.normalized_components_\n        )\n\n    def predict(self, X: np.ndarray, y=None) -&gt; np.ndarray:\n        r\"\"\"Return the marginal probabilities for a given row.\n\n        Marginalize out the loads via law of total probability\n\n        $$P[time=t | Row=r] = \\sum_{l=0}^{c} P[time=t | L=l, Row=r] * P[L=l | Row=r]$$\n\n        \"\"\"\n        # (n, n_components)\n        X_latent = self.transform(X)\n\n        return self.joint_distribution(X_latent=X_latent)\n\n    @property\n    def component_distribution_(self) -&gt; np.ndarray:\n        \"\"\"Population frequency of each component.\"\"\"\n        return self.components_.sum(axis=1) / self.components_.sum()\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.component_distribution_","title":"<code>component_distribution_</code>  <code>property</code>","text":"<p>Population frequency of each component.</p>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.normalized_components_","title":"<code>normalized_components_</code>  <code>property</code>","text":"<p>Components that each sum to 1.</p>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.joint_distribution","title":"<code>joint_distribution(X_latent)</code>","text":"<p>Marginalize out the components.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def joint_distribution(self, X_latent: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Marginalize out the components.\"\"\"\n    return joint_distribution(\n        X_latent=X_latent, components=self.normalized_components_\n    )\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.LatentCalendar.predict","title":"<code>predict(X, y=None)</code>","text":"<p>Return the marginal probabilities for a given row.</p> <p>Marginalize out the loads via law of total probability</p> \\[P[time=t | Row=r] = \\sum_{l=0}^{c} P[time=t | L=l, Row=r] * P[L=l | Row=r]\\] Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def predict(self, X: np.ndarray, y=None) -&gt; np.ndarray:\n    r\"\"\"Return the marginal probabilities for a given row.\n\n    Marginalize out the loads via law of total probability\n\n    $$P[time=t | Row=r] = \\sum_{l=0}^{c} P[time=t | L=l, Row=r] * P[L=l | Row=r]$$\n\n    \"\"\"\n    # (n, n_components)\n    X_latent = self.transform(X)\n\n    return self.joint_distribution(X_latent=X_latent)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel","title":"<code>MarginalModel</code>","text":"<p>               Bases: <code>LatentCalendar</code></p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>class MarginalModel(LatentCalendar):\n    def fit(self, X, y=None) -&gt; \"MarginalModel\":\n        \"\"\"Just sum over all the rows.\"\"\"\n        self.n_components = 1\n        # (1, n_times)\n        self.components_ = X.sum(axis=0)[np.newaxis, :]\n\n        return self\n\n    def transform(self, X, y=None) -&gt; np.ndarray:\n        \"\"\"There is only one component to be a part of.\"\"\"\n        nrows = len(X)\n\n        # (nrows, 1)\n        return np.repeat(1, nrows)[:, np.newaxis]\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Just sum over all the rows.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def fit(self, X, y=None) -&gt; \"MarginalModel\":\n    \"\"\"Just sum over all the rows.\"\"\"\n    self.n_components = 1\n    # (1, n_times)\n    self.components_ = X.sum(axis=0)[np.newaxis, :]\n\n    return self\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.MarginalModel.transform","title":"<code>transform(X, y=None)</code>","text":"<p>There is only one component to be a part of.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def transform(self, X, y=None) -&gt; np.ndarray:\n    \"\"\"There is only one component to be a part of.\"\"\"\n    nrows = len(X)\n\n    # (nrows, 1)\n    return np.repeat(1, nrows)[:, np.newaxis]\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.constant_prior","title":"<code>constant_prior(X, value=1.0)</code>","text":"<p>Return the prior for each hour of the day.</p> <p>This is the average of all the rows.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(nrows, n_times)</p> required Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def constant_prior(X: np.ndarray, value: float = 1.0) -&gt; np.ndarray:\n    \"\"\"Return the prior for each hour of the day.\n\n    This is the average of all the rows.\n\n    Args:\n        X: (nrows, n_times)\n    \"\"\"\n    TIME_SLOTS = X.shape[1]\n    return np.repeat(value, TIME_SLOTS)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.hourly_prior","title":"<code>hourly_prior(X)</code>","text":"<p>Return the prior for each hour of the day.</p> <p>This is the average of all the rows.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>(nrows, n_times)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(n_times,)</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def hourly_prior(X: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Return the prior for each hour of the day.\n\n    This is the average of all the rows.\n\n    Args:\n        X: (nrows, n_times)\n\n    Returns:\n        (n_times,)\n\n    \"\"\"\n    return (X &gt; 0).sum(axis=0) / len(X)\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.latent_calendar.joint_distribution","title":"<code>joint_distribution(X_latent, components)</code>","text":"<p>Marginalize out the components.</p> Source code in <code>latent_calendar/model/latent_calendar.py</code> <pre><code>def joint_distribution(X_latent: np.ndarray, components: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Marginalize out the components.\"\"\"\n    return X_latent @ components\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.utils.predict_on_dataframe","title":"<code>predict_on_dataframe(df, model)</code>","text":"<p>Small wrapper to predict on DataFrame and keep same columns and index.</p> Source code in <code>latent_calendar/model/utils.py</code> <pre><code>def predict_on_dataframe(df: pd.DataFrame, model: LatentCalendar) -&gt; pd.DataFrame:\n    \"\"\"Small wrapper to predict on DataFrame and keep same columns and index.\"\"\"\n    return pd.DataFrame(\n        model.predict(df.to_numpy()), columns=df.columns, index=df.index\n    )\n</code></pre>"},{"location":"modules/model/#latent_calendar.model.utils.transform_on_dataframe","title":"<code>transform_on_dataframe(df, model)</code>","text":"<p>Small wrapper to transform on DataFrame and keep index.</p> Source code in <code>latent_calendar/model/utils.py</code> <pre><code>def transform_on_dataframe(df: pd.DataFrame, model: LatentCalendar) -&gt; pd.DataFrame:\n    \"\"\"Small wrapper to transform on DataFrame and keep index.\"\"\"\n    return pd.DataFrame(model.transform(df.to_numpy()), index=df.index)\n</code></pre>"},{"location":"modules/plot/","title":"Plot","text":"<p>Plotting functions for latent calendar.</p> <p>These functions and classes build every calendar plot.</p>"},{"location":"modules/segments/","title":"Segments","text":"<p>Create hand picked segments on the calendar.</p> <p>Examples:</p> <p>Create some segments for a calendar:</p> <pre><code>mornings = create_box_segment(\n    day_start=0, day_end=7, hour_start=6, hour_end=11, name=\"Mornings\"\n)\nafternoons = create_box_segment(\n    day_start=0, day_end=7, hour_start=11, hour_end=16, name=\"Afternoons\"\n)\nevenings = create_box_segment(\n    day_start=0, day_end=7, hour_start=16, hour_end=21, name=\"Evenings\"\n)\n\ndf_segments = stack_segments([\n    mornings,\n    afternoons,\n    evenings,\n])\n\ndf_segments.cal.plot_by_row()\n</code></pre> <p></p> <p>Processing off calendar distribution.</p>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_blank_segment_series","title":"<code>create_blank_segment_series()</code>","text":"<p>Helper for making segments programatically.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_blank_segment_series() -&gt; pd.Series:\n    \"\"\"Helper for making segments programatically.\"\"\"\n    return pd.Series(0, index=FULL_VOCAB)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_box_segment","title":"<code>create_box_segment(day_start, day_end, hour_start, hour_end, name=None)</code>","text":"<p>Programmatically make segment of box described by inputs.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_box_segment(\n    day_start: int,\n    day_end: int,\n    hour_start: int,\n    hour_end: int,\n    name: str | None = None,\n) -&gt; pd.Series:\n    \"\"\"Programmatically make segment of box described by inputs.\"\"\"\n    ser = create_blank_segment_series()\n\n    for dow in range(day_start, day_end):\n        start = DOWHour(dow=dow, hour=hour_start)\n        end = DOWHour(dow=dow, hour=hour_end)\n\n        ser += create_series_for_range(start=start, end=end)\n\n    name = name or f\"{day_start}-{day_end} {hour_start}-{hour_end}\"\n    return ser.rename(name)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_dow_segments","title":"<code>create_dow_segments()</code>","text":"<p>Programmatically make the DOW segments.</p> <p>Each row is just each day of the week.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in the df_segments wide format</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_dow_segments() -&gt; pd.DataFrame:\n    \"\"\"Programmatically make the DOW segments.\n\n    Each row is just each day of the week.\n\n    Returns:\n        DataFrame in the df_segments wide format\n\n    \"\"\"\n    segments = []\n\n    for i, day in enumerate(create_default_days()):\n        day_number = str(i).zfill(2)\n        name = f\"{day_number}-{day}\"\n\n        start = DOWHour(dow=i, hour=0)\n        end = DOWHour(dow=i, hour=24)\n\n        segments.append(create_hourly_segment(start=start, end=end, name=name))\n\n    return stack_segments(segments)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_empty_template","title":"<code>create_empty_template()</code>","text":"<p>Create blank template in order</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_empty_template() -&gt; pd.DataFrame:\n    \"\"\"Create blank template in order\"\"\"\n    index = pd.Index(range(HOURS_IN_DAY), name=\"hour_start\")\n    return pd.DataFrame(\n        np.nan,\n        index=index,\n        columns=create_default_days(),\n    )\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_every_hour_segments","title":"<code>create_every_hour_segments()</code>","text":"<p>Programmatically segments for every hour</p> <p>Each row is just each time slot</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame in the df_segments wide format</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_every_hour_segments() -&gt; pd.DataFrame:\n    \"\"\"Programmatically segments for every hour\n\n    Each row is just each time slot\n\n    Returns:\n        DataFrame in the df_segments wide format\n\n    \"\"\"\n    segments = []\n\n    for dow, hour in itertools.product(range(DAYS_IN_WEEK), range(HOURS_IN_DAY)):\n        name = format_dow_hour(dow, hour)\n\n        start = DOWHour(dow=dow, hour=hour)\n        end = DOWHour(dow=dow, hour=hour + 1)\n        segments.append(create_hourly_segment(start=start, end=end, name=name))\n\n    return stack_segments(segments)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_hourly_segment","title":"<code>create_hourly_segment(start, end, name)</code>","text":"<p>Highlight from start until end.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_hourly_segment(start: DOWHour, end: DOWHour, name: str) -&gt; pd.Series:\n    \"\"\"Highlight from start until end.\"\"\"\n    return create_series_for_range(start=start, end=end).rename(name)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.create_series_for_range","title":"<code>create_series_for_range(start, end)</code>","text":"<p>Create a series for a range of hours with ones for those in range.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def create_series_for_range(start: DOWHour, end: DOWHour) -&gt; pd.Series:\n    \"\"\"Create a series for a range of hours with ones for those in range.\"\"\"\n    ser = create_blank_segment_series()\n\n    if start.is_after(end):\n        end, start = start, end\n        negate = True\n    else:\n        negate = False\n\n    if isinstance(ser.index, pd.MultiIndex):\n        start_idx = pd.IndexSlice[start.dow, start.hour]\n        end_idx = pd.IndexSlice[end.dow, end.hour - 1]\n    else:\n        start_idx = format_dow_hour(start.dow, start.hour)\n        end_idx = format_dow_hour(end.dow, end.hour - 1)\n\n    ser.loc[start_idx:end_idx] = 1\n\n    if negate:\n        ser = (ser - 1) * -1\n\n    return ser.astype(int)\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.get_vocab_for_range","title":"<code>get_vocab_for_range(start, end)</code>","text":"<p>Get the vocab for a range of hours.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def get_vocab_for_range(start: DOWHour, end: DOWHour) -&gt; list[str]:\n    \"\"\"Get the vocab for a range of hours.\"\"\"\n    return (\n        create_series_for_range(start=start, end=end)\n        .loc[lambda x: x == 1]\n        .index.tolist()\n    )\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.hand_picked.stack_segments","title":"<code>stack_segments(segments)</code>","text":"<p>Stack segments into a single dataframe.</p> Source code in <code>latent_calendar/segments/hand_picked.py</code> <pre><code>def stack_segments(segments: list[SEGMENT]) -&gt; pd.DataFrame:\n    \"\"\"Stack segments into a single dataframe.\"\"\"\n    segments = [seg.T if isinstance(seg, pd.DataFrame) else seg for seg in segments]\n    return pd.concat(segments, axis=1).T\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_array_over_segments","title":"<code>sum_array_over_segments(X_pred, X_segment)</code>","text":"<p>Get the probability of the mask for the probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>X_pred</code> <code>ndarray</code> <p>(nrows, n_times)</p> required <code>X_segment</code> <code>ndarray</code> <p>(n_segments, n_times)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Matrix of (nrows, n_segments) defining the probabilities of each segments</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_array_over_segments(X_pred: np.ndarray, X_segment: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Get the probability of the mask for the probabilities.\n\n    Args:\n        X_pred: (nrows, n_times)\n        X_segment: (n_segments, n_times)\n\n    Returns:\n        Matrix of (nrows, n_segments) defining the probabilities of each segments\n\n    \"\"\"\n    return _mask_probs(X_segment, X_pred).sum(axis=2).T\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_next_hours","title":"<code>sum_next_hours(df, hours)</code>","text":"<p>Sum the next hours columns.</p> <p>Useful for finding probability of having tour in the next 5 hours 00 00 column would be 06 06 23</p> <p>TODO: Consider if negative hours should be allowed TODO: Handle when minutes are not 60</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame of probabilities or counts in wide format</p> required <code>hours</code> <code>int</code> <p>Number of hours to sum after the current hour</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame summed over the next hours</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_next_hours(df: pd.DataFrame, hours: int) -&gt; pd.DataFrame:\n    \"\"\"Sum the next hours columns.\n\n    Useful for finding probability of having tour in the next 5 hours\n    00 00 column would be 06 06 23\n\n    TODO: Consider if negative hours should be allowed\n    TODO: Handle when minutes are not 60\n\n    Arguments:\n        df: DataFrame of probabilities or counts in wide format\n        hours: Number of hours to sum after the current hour\n\n    Returns:\n        DataFrame summed over the next hours\n\n    \"\"\"\n    if hours &lt; 0:\n        msg = \"hours cannot be negative\"\n        raise ValueError(msg)\n\n    if hours == 0:\n        return df\n\n    return (\n        pd.concat([df, df.iloc[:, :hours]], axis=1)\n        .pipe(_reverse_columns)\n        .T.rolling(hours + 1)\n        .sum()\n        .T.iloc[:, hours:]\n        .pipe(_reverse_columns)\n    )\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_over_segments","title":"<code>sum_over_segments(df, df_segments)</code>","text":"<p>Sum DataFrame over user defined segments.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame of probabilities or counts in wide format</p> required <code>df_segments</code> <code>DataFrame</code> <p>DataFrame of segments in wide format</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame of probabilities or counts summed over the segments</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_over_segments(df: pd.DataFrame, df_segments: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Sum DataFrame over user defined segments.\n\n    Args:\n        df: DataFrame of probabilities or counts in wide format\n        df_segments: DataFrame of segments in wide format\n\n    Returns:\n        DataFrame of probabilities or counts summed over the segments\n\n    \"\"\"\n    return pd.DataFrame(\n        sum_array_over_segments(df.to_numpy(), df_segments.to_numpy()),\n        index=df.index,\n        columns=df_segments.index,\n    )\n</code></pre>"},{"location":"modules/segments/#latent_calendar.segments.convolution.sum_over_vocab","title":"<code>sum_over_vocab(df, aggregation='dow')</code>","text":"<p>Sum the wide DataFrame columns to hours or dow.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame in wide format with vocab column names</p> required <code>aggregation</code> <code>Literal['dow', 'hour']</code> <p>either dow or hour</p> <code>'dow'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame columns associated with the aggregation</p> Source code in <code>latent_calendar/segments/convolution.py</code> <pre><code>def sum_over_vocab(\n    df: pd.DataFrame,\n    aggregation: Literal[\"dow\", \"hour\"] = \"dow\",\n) -&gt; pd.DataFrame:\n    \"\"\"Sum the wide DataFrame columns to hours or dow.\n\n    Args:\n        df: DataFrame in wide format with vocab column names\n        aggregation: either dow or hour\n\n    Returns:\n        DataFrame columns associated with the aggregation\n\n    \"\"\"\n    if not isinstance(df.columns, pd.MultiIndex):\n        raise ValueError(\"The columns must be a MultiIndex of day_of_week and hour.\")\n\n    level = 1 if aggregation == \"hour\" else 0\n    return df.T.groupby(level=level).sum().T\n</code></pre>"},{"location":"modules/transformers/","title":"Transformers","text":"<p>scikit-learn transformers for the data.</p> <pre><code>from latent_calendar.datasets import load_online_transactions\n\ndf = load_online_transactions()\n\ntransformers = create_raw_to_vocab_transformer(id_col=\"Customer ID\", timestamp_col=\"InvoiceDate\")\n\ndf_wide = transformers.fit_transform(df)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalendarTimestampFeatures","title":"<code>CalendarTimestampFeatures</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Day of week and prop into day columns creation.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class CalendarTimestampFeatures(BaseEstimator, TransformerMixin):\n    \"\"\"Day of week and prop into day columns creation.\"\"\"\n\n    def __sklearn_tags__(self):\n        tags = super().__sklearn_tags__()\n        tags.requires_fit = False\n        return tags\n\n    def __init__(\n        self,\n        timestamp_col: str,\n    ) -&gt; None:\n        self.timestamp_col = timestamp_col\n\n    def fit(self, X, y=None):\n        return self\n\n    @nw.narwhalify\n    def transform(self, X, y=None):\n        \"\"\"Create 2 new columns.\"\"\"\n\n        X = create_timestamp_features(X, self.timestamp_col).to_native()\n        self.columns = list(X.columns)\n\n        return X\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalendarTimestampFeatures.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Create 2 new columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>@nw.narwhalify\ndef transform(self, X, y=None):\n    \"\"\"Create 2 new columns.\"\"\"\n\n    X = create_timestamp_features(X, self.timestamp_col).to_native()\n    self.columns = list(X.columns)\n\n    return X\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.HourDiscretizer","title":"<code>HourDiscretizer</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Discretize the hour column.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>str</code> <p>The name of the column to discretize.</p> <code>'hour'</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class HourDiscretizer(BaseEstimator, TransformerMixin):\n    \"\"\"Discretize the hour column.\n\n    Args:\n        col: The name of the column to discretize.\n        minutes: The number of minutes to discretize by.\n\n    \"\"\"\n\n    def __sklearn_tags__(self):\n        tags = super().__sklearn_tags__()\n        tags.requires_fit = False\n        return tags\n\n    def __init__(self, col: str = \"hour\", minutes: int = 60) -&gt; None:\n        self.col = col\n        self.minutes = minutes\n\n    def fit(self, X, y=None):\n        return self\n\n    @property\n    def divisor(self) -&gt; float:\n        return 1 if self.minutes == 60 else self.minutes / 60\n\n    @nw.narwhalify\n    def transform(self, X: FrameT, y=None) -&gt; FrameT:\n        X = create_discretized_hour(X, col=self.col, minutes=self.minutes)\n\n        self.columns = list(X.columns)\n\n        return X\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.LongToWide","title":"<code>LongToWide</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Unstack the assumed last index as vocab column.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>str</code> <p>The name of the column to unstack.</p> <code>'num_events'</code> <code>as_int</code> <code>bool</code> <p>Whether to cast the values to int.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>multiindex</code> <code>bool</code> <p>Whether the columns are a multiindex.</p> <code>True</code> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class LongToWide(BaseEstimator, TransformerMixin):\n    \"\"\"Unstack the assumed last index as vocab column.\n\n    Args:\n        col: The name of the column to unstack.\n        as_int: Whether to cast the values to int.\n        minutes: The number of minutes to discretize by.\n        multiindex: Whether the columns are a multiindex.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        col: str = \"num_events\",\n        as_int: bool = True,\n        minutes: int = 60,\n        multiindex: bool = True,\n    ) -&gt; None:\n        self.col = col\n        self.as_int = as_int\n        self.minutes = minutes\n        self.multiindex = multiindex\n\n    def fit(self, X: pd.DataFrame, y=None):\n        return self\n\n    @property\n    def columns(self) -&gt; list[str]:\n        return create_full_vocab(\n            days_in_week=DAYS_IN_WEEK,\n            minutes=self.minutes,\n            as_multiindex=self.multiindex,\n        )\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        \"\"\"Unstack the assumed last index as vocab column.\"\"\"\n        X_res = X.loc[:, self.col]\n\n        level = [-2, -1] if self.multiindex else -1\n        X_res = X_res.unstack(level=level)\n\n        X_res = X_res.reindex(self.columns, axis=1)\n        X_res = X_res.fillna(value=0)\n        if self.as_int:\n            X_res = X_res.astype(int)\n\n        return X_res\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.LongToWide.transform","title":"<code>transform(X, y=None)</code>","text":"<p>Unstack the assumed last index as vocab column.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n    \"\"\"Unstack the assumed last index as vocab column.\"\"\"\n    X_res = X.loc[:, self.col]\n\n    level = [-2, -1] if self.multiindex else -1\n    X_res = X_res.unstack(level=level)\n\n    X_res = X_res.reindex(self.columns, axis=1)\n    X_res = X_res.fillna(value=0)\n    if self.as_int:\n        X_res = X_res.astype(int)\n\n    return X_res\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.RawToVocab","title":"<code>RawToVocab</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Transformer timestamp level data into id level data with vocab columns.</p> <p>Parameters:</p> Name Type Description Default <code>id_col</code> <code>str</code> <p>The name of the id column.</p> required <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>additional_groups</code> <code>list[str] | None</code> <p>Additional columns to group by.</p> <code>None</code> <code>cols</code> <code>list[str] | None</code> <p>Additional columns to sum.</p> <code>None</code> <code>as_multiindex</code> <code>bool</code> <p>Whether to return columns as a multiindex.</p> <code>True</code> <code>widen</code> <code>bool</code> <p>Whether to widen the data at the end. Only supported for DataFrames with index.</p> <code>True</code> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class RawToVocab(BaseEstimator, TransformerMixin):\n    \"\"\"Transformer timestamp level data into id level data with vocab columns.\n\n    Args:\n        id_col: The name of the id column.\n        timestamp_col: The name of the timestamp column.\n        minutes: The number of minutes to discretize by.\n        additional_groups: Additional columns to group by.\n        cols: Additional columns to sum.\n        as_multiindex: Whether to return columns as a multiindex.\n        widen: Whether to widen the data at the end. Only supported for DataFrames with index.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        id_col: str,\n        timestamp_col: str,\n        minutes: int = 60,\n        additional_groups: list[str] | None = None,\n        cols: list[str] | None = None,\n        as_multiindex: bool = True,\n        widen: bool = True,\n    ) -&gt; None:\n        self.id_col = id_col\n        self.timestamp_col = timestamp_col\n        self.minutes = minutes\n        self.additional_groups = additional_groups\n        self.cols = cols\n        self.as_multiindex = as_multiindex\n        self.widen = widen\n\n    @nw.narwhalify\n    def fit(self, X: FrameT, y=None):\n        # New features at same index level\n        self.features = create_timestamp_feature_pipeline(\n            self.timestamp_col,\n            minutes=self.minutes,\n            create_vocab=not self.as_multiindex,\n            output=str(X.implementation),\n        )\n        self.features.fit(X)\n\n        groups = [self.id_col]\n        if self.additional_groups is not None:\n            if not isinstance(self.additional_groups, list):\n                raise ValueError(\n                    f\"additional_groups should be list not {type(self.additional_groups)}\"\n                )\n\n            groups.extend(self.additional_groups)\n\n        if self.as_multiindex:\n            groups.extend([\"day_of_week\", \"hour\"])\n        else:\n            groups.append(\"vocab\")\n\n        # Reaggregation\n        self.aggregation = VocabAggregation(groups=groups, cols=self.cols)\n        self.aggregation.fit(X)\n        if not self.widen:\n            return self\n\n        # Unstacking\n        self.widen_transformer = LongToWide(\n            col=\"num_events\",\n            minutes=self.minutes,\n            multiindex=self.as_multiindex,\n        )\n        # Since nothing needs to be \"fit\"\n        return self\n\n    def transform(self, X: pd.DataFrame, y=None) -&gt; pd.DataFrame:\n        X_trans = self.features.transform(X)\n        X_agg = self.aggregation.transform(X_trans)\n\n        if not self.widen:\n            return X_agg\n\n        return self.widen_transformer.transform(X_agg)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.VocabAggregation","title":"<code>VocabAggregation</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>NOTE: The index of the grouping stays for pandas DataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>list[str]</code> <p>The columns to group by.</p> required <code>cols</code> <code>list[str] | None</code> <p>Additional columns to sum.</p> <code>None</code> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class VocabAggregation(BaseEstimator, TransformerMixin):\n    \"\"\"NOTE: The index of the grouping stays for pandas DataFrames.\n\n    Args:\n        groups: The columns to group by.\n        cols: Additional columns to sum.\n\n    \"\"\"\n\n    def __init__(self, groups: list[str], cols: list[str] | None = None) -&gt; None:\n        self.groups = groups\n        self.cols = cols\n\n    def fit(self, X, y=None):\n        self.columns = [\n            *self.groups,\n            *(self.cols or []),\n            \"num_events\",\n        ]\n        return self\n\n    @nw.narwhalify\n    def transform(self, X: FrameT, y=None):\n        return aggregate_vocab(X, self.groups, cols=self.cols)\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.VocabTransformer","title":"<code>VocabTransformer</code>","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>Create a vocab column from the day of week and hour columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>class VocabTransformer(BaseEstimator, TransformerMixin):\n    \"\"\"Create a vocab column from the day of week and hour columns.\"\"\"\n\n    def __sklearn_tags__(self):\n        tags = super().__sklearn_tags__()\n        tags.requires_fit = False\n        return tags\n\n    def __init__(\n        self,\n        day_of_week_col: str = \"day_of_week\",\n        hour_col: str = \"hour\",\n    ) -&gt; None:\n        self.day_of_week_col = day_of_week_col\n        self.hour_col = hour_col\n\n    @nw.narwhalify\n    def fit(self, X, y=None):\n        self.columns = X.columns + [\"vocab\"]\n        return self\n\n    @nw.narwhalify\n    def transform(self, X: FrameT, y=None) -&gt; FrameT:\n        return create_vocab(\n            X,\n            hour_col=self.hour_col,\n            day_of_week_col=self.day_of_week_col,\n        )\n\n    def get_feature_names_out(self, input_features=None):\n        return self.columns\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.CalandarTimestampFeatures","title":"<code>CalandarTimestampFeatures(*arg, **kwargs)</code>","text":"<p>Alias for CalendarTimestampFeatures.</p> <p>This is to avoid breaking changes in the API.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def CalandarTimestampFeatures(*arg, **kwargs) -&gt; CalendarTimestampFeatures:\n    \"\"\"Alias for CalendarTimestampFeatures.\n\n    This is to avoid breaking changes in the API.\n\n    \"\"\"\n    warnings.warn(\n        \"CalandarTimestampFeatures is deprecated. Use CalendarTimestampFeatures instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return CalendarTimestampFeatures(*arg, **kwargs)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_raw_to_vocab_transformer","title":"<code>create_raw_to_vocab_transformer(id_col, timestamp_col, minutes=60, additional_groups=None, as_multiindex=True, widen=True)</code>","text":"<p>Wrapper to create the transformer from the configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>id_col</code> <code>str</code> <p>The name of the id column.</p> required <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>additional_groups</code> <code>list[str] | None</code> <p>Additional columns to group by.</p> <code>None</code> <code>as_multiindex</code> <code>bool</code> <p>Whether to return columns as a multiindex.</p> <code>True</code> <code>widen</code> <code>bool</code> <p>Whether to widen the data at the end. Only supported for DataFrames with index.</p> <code>True</code> <p>Returns:</p> Type Description <code>RawToVocab</code> <p>A transformer that transforms timestamp level data into id level data with vocab columns.</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_raw_to_vocab_transformer(\n    id_col: str,\n    timestamp_col: str,\n    minutes: int = 60,\n    additional_groups: list[str] | None = None,\n    as_multiindex: bool = True,\n    widen: bool = True,\n) -&gt; RawToVocab:\n    \"\"\"Wrapper to create the transformer from the configuration options.\n\n    Args:\n        id_col: The name of the id column.\n        timestamp_col: The name of the timestamp column.\n        minutes: The number of minutes to discretize by.\n        additional_groups: Additional columns to group by.\n        as_multiindex: Whether to return columns as a multiindex.\n        widen: Whether to widen the data at the end. Only supported for DataFrames with index.\n\n    Returns:\n        A transformer that transforms timestamp level data into id level data with vocab columns.\n\n    \"\"\"\n\n    return RawToVocab(\n        id_col=id_col,\n        timestamp_col=timestamp_col,\n        minutes=minutes,\n        additional_groups=additional_groups,\n        as_multiindex=as_multiindex,\n        widen=widen,\n    )\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_timestamp_feature_pipeline","title":"<code>create_timestamp_feature_pipeline(timestamp_col, discretize=True, minutes=60, create_vocab=True, output='pandas')</code>","text":"<p>Create a pipeline that creates features from the timestamp column.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>discretize</code> <code>bool</code> <p>Whether to discretize the hour column.</p> <code>True</code> <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by. Ignored if discretize is False.</p> <code>60</code> <code>create_vocab</code> <code>bool</code> <p>Whether to create the vocab column.</p> <code>True</code> <code>output</code> <code>str</code> <p>The output type of the pipeline. Default is \"pandas\"</p> <code>'pandas'</code> <p>Returns:</p> Type Description <code>Pipeline</code> <p>A pipeline that creates features from the timestamp column.</p> Example <p>Create features for the online transactions dataset.</p> <pre><code>from latent_calendar.datasets import load_online_transactions\n\ndf = load_online_transactions()\n\ntransformers = create_timestamp_feature_pipeline(timestamp_col=\"InvoiceDate\")\n\ndf_features = transformers.fit_transform(df)\n</code></pre> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_timestamp_feature_pipeline(\n    timestamp_col: str,\n    discretize: bool = True,\n    minutes: int = 60,\n    create_vocab: bool = True,\n    output: str = \"pandas\",\n) -&gt; Pipeline:\n    \"\"\"Create a pipeline that creates features from the timestamp column.\n\n    Args:\n        timestamp_col: The name of the timestamp column.\n        discretize: Whether to discretize the hour column.\n        minutes: The number of minutes to discretize by. Ignored if discretize is False.\n        create_vocab: Whether to create the vocab column.\n        output: The output type of the pipeline. Default is \"pandas\"\n\n    Returns:\n        A pipeline that creates features from the timestamp column.\n\n    Example:\n        Create features for the online transactions dataset.\n\n        ```python\n        from latent_calendar.datasets import load_online_transactions\n\n        df = load_online_transactions()\n\n        transformers = create_timestamp_feature_pipeline(timestamp_col=\"InvoiceDate\")\n\n        df_features = transformers.fit_transform(df)\n        ```\n\n    \"\"\"\n    if create_vocab and not discretize:\n        raise ValueError(\"Cannot create vocab without discretizing.\")\n\n    vocab_col = \"hour\"\n    transformers = [\n        (\n            \"timestamp_features\",\n            CalendarTimestampFeatures(timestamp_col=timestamp_col),\n        ),\n    ]\n\n    if discretize:\n        transformers.append(\n            (\"binning\", HourDiscretizer(col=vocab_col, minutes=minutes))\n        )\n\n    if create_vocab:\n        transformers.append(\n            (\"vocab_creation\", VocabTransformer(hour_col=vocab_col)),\n        )\n\n    return Pipeline(\n        transformers,\n    ).set_output(transform=output)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.create_vocab","title":"<code>create_vocab(X, hour_col, day_of_week_col)</code>","text":"<p>Create vocabulary column from day of week and hour.</p> <p>Note: We use conditional logic instead of str.zfill(2) because narwhals' str.zfill() is not supported for PySpark backend (as of narwhals 2.16.0). This workaround specifically handles width=2 padding (sufficient for day_of_week 0-6 and hour 0-23).</p> <p>tracking issue: GitHub Issue</p> Equivalent to <p>day_str = nw.col(day_of_week_col).cast(nw.String).str.zfill(2) hour_str = nw.col(hour_col).cast(nw.String).str.zfill(2)</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def create_vocab(X: FrameT, hour_col: str, day_of_week_col) -&gt; FrameT:\n    \"\"\"Create vocabulary column from day of week and hour.\n\n    Note: We use conditional logic instead of str.zfill(2) because narwhals' str.zfill()\n    is not supported for PySpark backend (as of narwhals 2.16.0). This workaround\n    specifically handles width=2 padding (sufficient for day_of_week 0-6 and hour 0-23).\n\n    tracking issue: [GitHub Issue](https://github.com/narwhals-dev/narwhals/issues/3442)\n\n    Equivalent to:\n        day_str = nw.col(day_of_week_col).cast(nw.String).str.zfill(2)\n        hour_str = nw.col(hour_col).cast(nw.String).str.zfill(2)\n    \"\"\"\n    # Pad day_of_week to width 2: 0 -&gt; \"00\", 1 -&gt; \"01\", ..., 6 -&gt; \"06\"\n    day_of_week_part = (\n        nw.when(nw.col(day_of_week_col) &lt; 10)\n        .then(nw.concat_str([nw.lit(\"0\"), nw.col(day_of_week_col).cast(nw.String)]))\n        .otherwise(nw.col(day_of_week_col).cast(nw.String))\n    )\n\n    # Pad hour to width 2: 0 -&gt; \"00\", 1 -&gt; \"01\", ..., 23 -&gt; \"23\"\n    hour_part = (\n        nw.when(nw.col(hour_col) &lt; 10)\n        .then(nw.concat_str([nw.lit(\"0\"), nw.col(hour_col).cast(nw.String)]))\n        .otherwise(nw.col(hour_col).cast(nw.String))\n    )\n\n    vocab = nw.concat_str([day_of_week_part, hour_part], separator=\" \").alias(\"vocab\")\n\n    return X.with_columns(vocab)\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.prop_into_day","title":"<code>prop_into_day(dt)</code>","text":"<p>Returns the proportion into the day from datetime like object.</p> <p>0.0 is midnight and 1.0 is midnight again.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>ExprDateTimeNamespace</code> <p>datetime like object</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>numeric value(s) between 0.0 and 1.0</p> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def prop_into_day(dt: nw.expr_dt.ExprDateTimeNamespace) -&gt; nw.Expr:\n    \"\"\"Returns the proportion into the day from datetime like object.\n\n    0.0 is midnight and 1.0 is midnight again.\n\n    Args:\n        dt: datetime like object\n\n    Returns:\n        numeric value(s) between 0.0 and 1.0\n\n    \"\"\"\n    if not isinstance(dt, nw.expr_dt.ExprDateTimeNamespace):\n        hour = dt.hour\n        minute = dt.minute\n        second = dt.second\n        microsecond = dt.microsecond\n    else:\n        hour = dt.hour()\n        minute = dt.minute()\n        second = dt.second()\n        microsecond = dt.microsecond()\n\n    prop_hour = hour / HOURS_IN_DAY\n    prop_minute = minute / MINUTES_IN_DAY\n    prop_second = second / SECONDS_IN_DAY\n    prop_microsecond = microsecond / MICROSECONDS_IN_DAY\n\n    return prop_hour + prop_minute + prop_second + prop_microsecond\n</code></pre>"},{"location":"modules/transformers/#latent_calendar.transformers.raw_to_aggregate","title":"<code>raw_to_aggregate(df, id_col, timestamp_col, minutes=60, additional_groups=None, cols=None)</code>","text":"<p>Aggregate raw timestamp level data into</p> <p>This function uses narwhals and will work on any supported DataFrame implementation.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>IntoFrameT</code> <p>The input data.</p> required <code>id_col</code> <code>str</code> <p>The name of the id column.</p> required <code>timestamp_col</code> <code>str</code> <p>The name of the timestamp column.</p> required <code>minutes</code> <code>int</code> <p>The number of minutes to discretize by.</p> <code>60</code> <code>additional_groups</code> <code>list[str] | None</code> <p>Additional columns to group by.</p> <code>None</code> <code>cols</code> <code>list[str] | None</code> <p>Additional columns to sum.</p> <code>None</code> <p>Returns:</p> Type Description <code>IntoFrameT</code> <p>A DataFrame with aggregated data.</p> Example <p>Aggregate DataFrame in a polars LazyFrame</p> <pre><code>import polars as pl\n\nfrom latent_calendar.datasets import load_online_transactions\nfrom latent_calendar import raw_to_aggregate\n\ndf = load_online_transactions()\ndf_lazy = pl.LazyFrame(df)\n\ndf_agg = raw_to_aggregate(\n    df=df_lazy,\n    id_col=\"Country\",\n    timestamp_col=\"InvoiceDate\",\n)\n\ndf_agg.collect()\n</code></pre> <pre><code>shape: (1_088, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Country        \u2506 day_of_week \u2506 hour \u2506 num_events \u2502\n\u2502 ---            \u2506 ---         \u2506 ---  \u2506 ---        \u2502\n\u2502 str            \u2506 i8          \u2506 i64  \u2506 i32        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Belgium        \u2506 2           \u2506 15   \u2506 1          \u2502\n\u2502 Germany        \u2506 0           \u2506 8    \u2506 112        \u2502\n\u2502 EIRE           \u2506 4           \u2506 16   \u2506 18         \u2502\n\u2502 Italy          \u2506 0           \u2506 11   \u2506 1          \u2502\n\u2502 Canada         \u2506 4           \u2506 12   \u2506 1          \u2502\n\u2502 \u2026              \u2506 \u2026           \u2506 \u2026    \u2506 \u2026          \u2502\n\u2502 Finland        \u2506 3           \u2506 19   \u2506 17         \u2502\n\u2502 Australia      \u2506 1           \u2506 14   \u2506 8          \u2502\n\u2502 Portugal       \u2506 1           \u2506 11   \u2506 23         \u2502\n\u2502 United Kingdom \u2506 0           \u2506 11   \u2506 17949      \u2502\n\u2502 Iceland        \u2506 2           \u2506 14   \u2506 29         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>latent_calendar/transformers.py</code> <pre><code>def raw_to_aggregate(\n    df: IntoFrameT,\n    id_col: str,\n    timestamp_col: str,\n    minutes: int = 60,\n    additional_groups: list[str] | None = None,\n    cols: list[str] | None = None,\n) -&gt; IntoFrameT:\n    \"\"\"Aggregate raw timestamp level data into\n\n    This function uses narwhals and will work on any supported DataFrame implementation.\n\n    Args:\n        df: The input data.\n        id_col: The name of the id column.\n        timestamp_col: The name of the timestamp column.\n        minutes: The number of minutes to discretize by.\n        additional_groups: Additional columns to group by.\n        cols: Additional columns to sum.\n\n    Returns:\n        A DataFrame with aggregated data.\n\n    Example:\n        Aggregate DataFrame in a polars LazyFrame\n\n        ```python\n        import polars as pl\n\n        from latent_calendar.datasets import load_online_transactions\n        from latent_calendar import raw_to_aggregate\n\n        df = load_online_transactions()\n        df_lazy = pl.LazyFrame(df)\n\n        df_agg = raw_to_aggregate(\n            df=df_lazy,\n            id_col=\"Country\",\n            timestamp_col=\"InvoiceDate\",\n        )\n\n        df_agg.collect()\n        ```\n\n        ```\n        shape: (1_088, 4)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Country        \u2506 day_of_week \u2506 hour \u2506 num_events \u2502\n        \u2502 ---            \u2506 ---         \u2506 ---  \u2506 ---        \u2502\n        \u2502 str            \u2506 i8          \u2506 i64  \u2506 i32        \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 Belgium        \u2506 2           \u2506 15   \u2506 1          \u2502\n        \u2502 Germany        \u2506 0           \u2506 8    \u2506 112        \u2502\n        \u2502 EIRE           \u2506 4           \u2506 16   \u2506 18         \u2502\n        \u2502 Italy          \u2506 0           \u2506 11   \u2506 1          \u2502\n        \u2502 Canada         \u2506 4           \u2506 12   \u2506 1          \u2502\n        \u2502 \u2026              \u2506 \u2026           \u2506 \u2026    \u2506 \u2026          \u2502\n        \u2502 Finland        \u2506 3           \u2506 19   \u2506 17         \u2502\n        \u2502 Australia      \u2506 1           \u2506 14   \u2506 8          \u2502\n        \u2502 Portugal       \u2506 1           \u2506 11   \u2506 23         \u2502\n        \u2502 United Kingdom \u2506 0           \u2506 11   \u2506 17949      \u2502\n        \u2502 Iceland        \u2506 2           \u2506 14   \u2506 29         \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        ```\n\n    \"\"\"\n    return (\n        nw.from_native(df)\n        .pipe(\n            create_timestamp_features,\n            timestamp_col=timestamp_col,\n        )\n        .pipe(\n            create_discretized_hour,\n            col=\"hour\",\n            minutes=minutes,\n        )\n        .pipe(\n            create_vocab,\n            hour_col=\"hour\",\n            day_of_week_col=\"day_of_week\",\n        )\n        .pipe(\n            aggregate_vocab,\n            groups=[id_col, \"day_of_week\", \"hour\", *(additional_groups or [])],\n            cols=cols,\n        )\n        .to_native()\n    )\n</code></pre>"},{"location":"modules/vocab/","title":"Vocab","text":"<p>Operations and relationship with the \"vocab\" of the default time slots.</p>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour","title":"<code>DOWHour</code>  <code>dataclass</code>","text":"<p>Day of week and hour of day class.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@dataclass\nclass DOWHour:\n    \"\"\"Day of week and hour of day class.\"\"\"\n\n    dow: int\n    hour: int\n\n    @classmethod\n    def from_vocab(cls, vocab: str) -&gt; \"DOWHour\":\n        \"\"\"Construct from a vocab string.\"\"\"\n        dow, hour = get_day_hour(vocab=vocab)\n\n        return cls(dow=dow, hour=hour)\n\n    def __post_init__(self) -&gt; None:\n        msg = \"Day of week goes from 0 to 6 and hour of day goes from 0 to 24.\"\n        if not 0 &lt;= self.dow &lt;= 6:\n            raise ValueError(msg)\n\n        if not 0 &lt;= self.hour &lt;= 24:\n            raise ValueError(msg)\n\n    def is_after(self, other: \"DOWHour\") -&gt; bool:\n        \"\"\"Check if self is after other.\"\"\"\n        if self.dow &gt; other.dow:\n            return True\n\n        if self.dow &lt; other.dow:\n            return False\n\n        return self.hour &gt; other.hour\n\n    @property\n    def vocab(self) -&gt; str:\n        \"\"\"Get the vocab string for an instance.\"\"\"\n        return format_dow_hour(self.dow, self.hour)\n\n    def __add__(self, hours: int) -&gt; \"DOWHour\":\n        \"\"\"Add a number of hours.\"\"\"\n        dow, hour = self.dow, self.hour\n\n        for _ in range(hours):\n            hour += 1\n            if hour &gt; 23:\n                dow += 1\n                dow = dow % 7\n\n            hour = hour % 24\n\n        return DOWHour(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.vocab","title":"<code>vocab</code>  <code>property</code>","text":"<p>Get the vocab string for an instance.</p>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.__add__","title":"<code>__add__(hours)</code>","text":"<p>Add a number of hours.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def __add__(self, hours: int) -&gt; \"DOWHour\":\n    \"\"\"Add a number of hours.\"\"\"\n    dow, hour = self.dow, self.hour\n\n    for _ in range(hours):\n        hour += 1\n        if hour &gt; 23:\n            dow += 1\n            dow = dow % 7\n\n        hour = hour % 24\n\n    return DOWHour(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.from_vocab","title":"<code>from_vocab(vocab)</code>  <code>classmethod</code>","text":"<p>Construct from a vocab string.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@classmethod\ndef from_vocab(cls, vocab: str) -&gt; \"DOWHour\":\n    \"\"\"Construct from a vocab string.\"\"\"\n    dow, hour = get_day_hour(vocab=vocab)\n\n    return cls(dow=dow, hour=hour)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.DOWHour.is_after","title":"<code>is_after(other)</code>","text":"<p>Check if self is after other.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def is_after(self, other: \"DOWHour\") -&gt; bool:\n    \"\"\"Check if self is after other.\"\"\"\n    if self.dow &gt; other.dow:\n        return True\n\n    if self.dow &lt; other.dow:\n        return False\n\n    return self.hour &gt; other.hour\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.HourFormatter","title":"<code>HourFormatter</code>  <code>dataclass</code>","text":"<p>Class to format the hour that includes midnight and noon.</p> <p>Parameters:</p> Name Type Description Default <code>midnight</code> <code>str | None</code> <p>string to use for midnight</p> <code>'Midnight'</code> <code>noon</code> <code>str | None</code> <p>string to use for noon</p> <code>'Noon'</code> <code>format_hour</code> <code>HOUR_FORMATTER</code> <p>HOUR_FORMATTER to map hour int to string</p> <code>HOUR_FORMATTERS['12hr']</code> <p>Examples:</p> <p>Just return the number and add midnight and noon.</p> <pre><code>hour_formatter = HourFormatter(\n    midnight=\"Midnight\",\n    noon=\"Noon\",\n    format_hour=lambda hour: hour\n)\n\nhour_formatter(0) # \"Midnight\"\nhour_formatter(12) # \"Noon\"\nhour_formatter(1) # 1\nhour_formatter(13) # 13\nhour_formatter(24) # \"Midnight\"\n</code></pre> Source code in <code>latent_calendar/vocab.py</code> <pre><code>@dataclass\nclass HourFormatter:\n    \"\"\"Class to format the hour that includes midnight and noon.\n\n    Args:\n        midnight: string to use for midnight\n        noon: string to use for noon\n        format_hour: HOUR_FORMATTER to map hour int to string\n\n    Examples:\n        Just return the number and add midnight and noon.\n\n        ```python\n        hour_formatter = HourFormatter(\n            midnight=\"Midnight\",\n            noon=\"Noon\",\n            format_hour=lambda hour: hour\n        )\n\n        hour_formatter(0) # \"Midnight\"\n        hour_formatter(12) # \"Noon\"\n        hour_formatter(1) # 1\n        hour_formatter(13) # 13\n        hour_formatter(24) # \"Midnight\"\n\n        ```\n\n    \"\"\"\n\n    midnight: str | None = \"Midnight\"\n    noon: str | None = \"Noon\"\n    format_hour: HOUR_FORMATTER = HOUR_FORMATTERS[\"12hr\"]\n\n    def __call__(self, hr: int) -&gt; str:\n        if self.midnight is not None and hr in (0, HOURS_IN_DAY):\n            return self.midnight\n\n        if hr == 12:\n            return self.noon if self.noon is not None else self.format_hour(hr)\n\n        return self.format_hour(hr)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.am_pm_of_hour","title":"<code>am_pm_of_hour(hour)</code>","text":"<p>Get the am or pm of the hour.</p> <p>Parameters:</p> Name Type Description Default <code>hour</code> <code>int</code> <p>hour of the day</p> required <p>Returns:</p> Type Description <code>str</code> <p>am or pm</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def am_pm_of_hour(hour: int) -&gt; str:\n    \"\"\"Get the am or pm of the hour.\n\n    Args:\n        hour: hour of the day\n\n    Returns:\n        am or pm\n\n    \"\"\"\n    return \"am\" if hour &lt; 12 else \"pm\"\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.get_day_hour","title":"<code>get_day_hour(vocab)</code>","text":"<p>Get the day and hour from the vocab.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def get_day_hour(vocab: str) -&gt; tuple[int, int]:\n    \"\"\"Get the day and hour from the vocab.\"\"\"\n    day_str, hour_str = vocab.split(\" \")\n\n    return int(day_str), int(hour_str)\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.make_human_readable","title":"<code>make_human_readable(vocab, hour_formatter=HOUR_FORMATTERS['12_am_pm'])</code>","text":"<p>Create a human readable string of the vocab.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str</code> <p>string vocab. i.e. \"00 01\"</p> required <code>hour_formatter</code> <code>HOUR_FORMATTER</code> <p>HOUR_FORMATTER to map hour int to string</p> <code>HOUR_FORMATTERS['12_am_pm']</code> <p>Returns:</p> Type Description <code>str</code> <p>human readable string of the vocab</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def make_human_readable(\n    vocab: str, hour_formatter: HOUR_FORMATTER = HOUR_FORMATTERS[\"12_am_pm\"]\n) -&gt; str:\n    \"\"\"Create a human readable string of the vocab.\n\n    Args:\n        vocab: string vocab. i.e. \"00 01\"\n        hour_formatter: HOUR_FORMATTER to map hour int to string\n\n    Returns:\n        human readable string of the vocab\n\n    \"\"\"\n    day, hour = get_day_hour(vocab=vocab)\n\n    human_day = calendar.day_name[day]\n    human_hour = hour_formatter(hour)\n\n    return f\"{human_day} {human_hour}\"\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.map_to_12_hour","title":"<code>map_to_12_hour(hour)</code>","text":"<p>Map the hour to a 12 hour clock.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def map_to_12_hour(hour: int) -&gt; int:\n    \"\"\"Map the hour to a 12 hour clock.\"\"\"\n    if hour == 0:\n        return 12\n\n    if hour == 12:\n        return hour\n\n    return hour % 12\n</code></pre>"},{"location":"modules/vocab/#latent_calendar.vocab.split_vocab","title":"<code>split_vocab(ser)</code>","text":"<p>Split pandas series of vocab into day of week and hour of day DataFrame.</p> Source code in <code>latent_calendar/vocab.py</code> <pre><code>def split_vocab(ser: pd.Series) -&gt; pd.DataFrame:\n    \"\"\"Split pandas series of vocab into day of week and hour of day DataFrame.\"\"\"\n    df_split = ser.str.split(\" \", expand=True).astype(int)\n\n    df_split.columns = [\"dow\", \"hour\"]\n\n    return df_split\n</code></pre>"},{"location":"modules/integrations/folium/","title":"Folium Integration Module","text":"<p>The <code>integrations.folium</code> module provides functions for creating interactive map popups and tooltips with calendar heatmaps.</p>"},{"location":"modules/integrations/folium/#installation","title":"Installation","text":"<pre><code>pip install latent-calendar[html,folium]\n</code></pre> <p>This installs:</p> <ul> <li><code>altair&gt;=5.0.0</code> - For interactive charts</li> <li><code>folium&gt;=0.14.0</code> - For map creation</li> </ul>"},{"location":"modules/integrations/folium/#overview","title":"Overview","text":"<p>This module bridges <code>latent-calendar</code> with Folium to display weekly temporal patterns on interactive maps. It's perfect for:</p> <ul> <li>Geographic time-series visualization</li> <li>Location-based event analysis</li> <li>Operational pattern mapping</li> <li>Research presentation with spatial context</li> </ul> <p>See the Folium Integration Guide for detailed examples and use cases.</p>"},{"location":"modules/integrations/folium/#api-reference","title":"API Reference","text":"<p>Folium integration for latent-calendar visualizations.</p> <p>This module provides helpers to embed interactive calendar heatmaps into Folium map popups and tooltips. Calendar heatmaps show weekly patterns across day-of-week and hour-of-day dimensions.</p> This module requires folium to be installed: <p>pip install latent-calendar[folium]</p> <p>The module provides both raw HTML generation functions and convenience functions that return ready-to-use Folium objects.</p> <p>Examples:</p> <p>Basic usage with Folium markers:</p> <pre><code>&gt;&gt;&gt; import folium\n&gt;&gt;&gt; from latent_calendar.integrations.folium import create_calendar_popup\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Assuming df_states has aggregated calendar data (168 columns per state)\n&gt;&gt;&gt; calendar_data = df_states.loc['CA']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create popup with calendar heatmap\n&gt;&gt;&gt; popup = create_calendar_popup(\n...     calendar_data,\n...     title=\"California Weekly Pattern\",\n...     color_scheme='blues'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Add to map\n&gt;&gt;&gt; map = folium.Map(location=[36.7, -119.7], zoom_start=6)\n&gt;&gt;&gt; folium.Marker([36.7, -119.7], popup=popup).add_to(map)\n&gt;&gt;&gt; map.save('map.html')\n</code></pre> <p>Using with GeoJSON features:</p> <pre><code>&gt;&gt;&gt; import folium\n&gt;&gt;&gt; from folium import GeoJson\n&gt;&gt;&gt; from latent_calendar.integrations.folium import create_calendar_popup\n&gt;&gt;&gt;\n&gt;&gt;&gt; for feature in geojson_features:\n...     state_name = feature['properties']['name']\n...     calendar_data = df_states.loc[state_name]\n...\n...     popup = create_calendar_popup(\n...         calendar_data,\n...         title=f\"Weekly Pattern: {state_name}\",\n...         width=450,\n...         height=320\n...     )\n...\n...     GeoJson(feature, popup=popup).add_to(map)\n</code></pre> <p>Advanced: Get raw HTML for custom integration:</p> <pre><code>&gt;&gt;&gt; from latent_calendar.integrations.folium import create_popup_html\n&gt;&gt;&gt;\n&gt;&gt;&gt; html = create_popup_html(\n...     calendar_data,\n...     title=\"Custom Calendar\",\n...     color_scheme='reds'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use HTML string in your own way\n&gt;&gt;&gt; custom_popup = folium.Popup(html, max_width=600)\n</code></pre>"},{"location":"modules/integrations/folium/#latent_calendar.integrations.folium.create_calendar_popup","title":"<code>create_calendar_popup(calendar_data, *, title=None, width=400, height=300, max_width=450, **chart_kwargs)</code>","text":"<p>Create a Folium Popup object with embedded calendar heatmap.</p> <p>Convenience function that returns a ready-to-use folium.Popup object containing an interactive calendar visualization. This is the recommended way to create calendar popups for most use cases.</p> <p>The calendar shows weekly patterns with day-of-week on the x-axis and hour-of-day on the y-axis, with color intensity representing data values.</p> <p>Parameters:</p> Name Type Description Default <code>calendar_data</code> <p>Wide calendar format (168 time slots: 7 days \u00d7 24 hours).           Can be pandas Series, numpy array, or list.</p> required <code>title</code> <code>str | None</code> <p>Popup title displayed above the calendar. Optional.</p> <code>None</code> <code>width</code> <code>int</code> <p>Calendar chart width in pixels. Default is 400.</p> <code>400</code> <code>height</code> <code>int</code> <p>Calendar chart height in pixels. Default is 300.</p> <code>300</code> <code>max_width</code> <code>int</code> <p>Maximum popup width in pixels. The popup will scale responsively       within this constraint. Default is 450.</p> <code>450</code> <code>**chart_kwargs</code> <p>Additional arguments passed to create_calendar_chart().            Useful options include:            - color_scheme: Color scheme name (default 'blues').              Options: 'blues', 'greens', 'reds', 'oranges', 'purples',              'viridis', 'plasma', 'inferno', 'magma', etc.            - monday_start: Start week on Monday (True, default) or Sunday (False)            - interactive: Enable tooltips and zoom (True, default)            - show_values: Show values in tooltips (True, default)</p> <code>{}</code> <p>Returns:</p> Type Description <p>folium.Popup object ready to add to markers or GeoJSON features</p> <p>Examples:</p> <p>Basic usage with markers:</p> <pre><code>&gt;&gt;&gt; import folium\n&gt;&gt;&gt; from latent_calendar.integrations.folium import create_calendar_popup\n&gt;&gt;&gt;\n&gt;&gt;&gt; popup = create_calendar_popup(\n...     calendar_data,\n...     title=\"California UFO Sightings\",\n...     color_scheme='blues'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; map = folium.Map(location=[36.7, -119.7], zoom_start=6)\n&gt;&gt;&gt; folium.Marker([36.7, -119.7], popup=popup).add_to(map)\n&gt;&gt;&gt; map.save('map.html')\n</code></pre> <p>With GeoJSON features:</p> <pre><code>&gt;&gt;&gt; from folium import GeoJson\n&gt;&gt;&gt; from latent_calendar.integrations.folium import create_calendar_popup\n&gt;&gt;&gt;\n&gt;&gt;&gt; for feature in geojson_data['features']:\n...     state_name = feature['properties']['name']\n...     calendar_data = df_states.loc[state_name]\n...\n...     popup = create_calendar_popup(\n...         calendar_data,\n...         title=f\"Patterns: {state_name}\",\n...         width=450,\n...         height=320,\n...         max_width=500\n...     )\n...\n...     GeoJson(feature, popup=popup).add_to(map)\n</code></pre> <p>Custom styling:</p> <pre><code>&gt;&gt;&gt; popup = create_calendar_popup(\n...     calendar_data,\n...     title=\"Weekend Activity\",\n...     width=500,\n...     height=350,\n...     color_scheme='viridis',\n...     monday_start=False  # Start week on Sunday\n... )\n</code></pre> Source code in <code>latent_calendar/integrations/folium.py</code> <pre><code>def create_calendar_popup(\n    calendar_data,\n    *,\n    title: str | None = None,\n    width: int = 400,\n    height: int = 300,\n    max_width: int = 450,\n    **chart_kwargs,\n):\n    \"\"\"Create a Folium Popup object with embedded calendar heatmap.\n\n    Convenience function that returns a ready-to-use folium.Popup object containing\n    an interactive calendar visualization. This is the recommended way to create\n    calendar popups for most use cases.\n\n    The calendar shows weekly patterns with day-of-week on the x-axis and hour-of-day\n    on the y-axis, with color intensity representing data values.\n\n    Args:\n        calendar_data: Wide calendar format (168 time slots: 7 days \u00d7 24 hours).\n                      Can be pandas Series, numpy array, or list.\n        title: Popup title displayed above the calendar. Optional.\n        width: Calendar chart width in pixels. Default is 400.\n        height: Calendar chart height in pixels. Default is 300.\n        max_width: Maximum popup width in pixels. The popup will scale responsively\n                  within this constraint. Default is 450.\n        **chart_kwargs: Additional arguments passed to create_calendar_chart().\n                       Useful options include:\n                       - color_scheme: Color scheme name (default 'blues').\n                         Options: 'blues', 'greens', 'reds', 'oranges', 'purples',\n                         'viridis', 'plasma', 'inferno', 'magma', etc.\n                       - monday_start: Start week on Monday (True, default) or Sunday (False)\n                       - interactive: Enable tooltips and zoom (True, default)\n                       - show_values: Show values in tooltips (True, default)\n\n    Returns:\n        folium.Popup object ready to add to markers or GeoJSON features\n\n    Examples:\n        Basic usage with markers:\n\n        &gt;&gt;&gt; import folium\n        &gt;&gt;&gt; from latent_calendar.integrations.folium import create_calendar_popup\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; popup = create_calendar_popup(\n        ...     calendar_data,\n        ...     title=\"California UFO Sightings\",\n        ...     color_scheme='blues'\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; map = folium.Map(location=[36.7, -119.7], zoom_start=6)\n        &gt;&gt;&gt; folium.Marker([36.7, -119.7], popup=popup).add_to(map)\n        &gt;&gt;&gt; map.save('map.html')\n\n        With GeoJSON features:\n\n        &gt;&gt;&gt; from folium import GeoJson\n        &gt;&gt;&gt; from latent_calendar.integrations.folium import create_calendar_popup\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; for feature in geojson_data['features']:\n        ...     state_name = feature['properties']['name']\n        ...     calendar_data = df_states.loc[state_name]\n        ...\n        ...     popup = create_calendar_popup(\n        ...         calendar_data,\n        ...         title=f\"Patterns: {state_name}\",\n        ...         width=450,\n        ...         height=320,\n        ...         max_width=500\n        ...     )\n        ...\n        ...     GeoJson(feature, popup=popup).add_to(map)\n\n        Custom styling:\n\n        &gt;&gt;&gt; popup = create_calendar_popup(\n        ...     calendar_data,\n        ...     title=\"Weekend Activity\",\n        ...     width=500,\n        ...     height=350,\n        ...     color_scheme='viridis',\n        ...     monday_start=False  # Start week on Sunday\n        ... )\n    \"\"\"\n    html = create_popup_html(\n        calendar_data,\n        title=title,\n        width=width,\n        height=height,\n        **chart_kwargs,\n    )\n\n    # Use IFrame to properly embed the full HTML document\n    # IFrame height needs to account for chart + title + padding\n    iframe_height = height + 80  # Add space for title and margins\n    iframe = folium.IFrame(\n        html,\n        width=max_width,\n        height=iframe_height,\n    )\n\n    return folium.Popup(iframe, max_width=max_width)\n</code></pre>"},{"location":"modules/integrations/folium/#latent_calendar.integrations.folium.create_calendar_tooltip","title":"<code>create_calendar_tooltip(calendar_data, *, title=None, width=300, height=200, compact=True, **chart_kwargs)</code>","text":"<p>Create a Folium Tooltip object with embedded calendar heatmap.</p> <p>Convenience function that returns a ready-to-use folium.Tooltip object containing a compact calendar visualization. Tooltips appear on hover and should be smaller and simpler than popups.</p> <p>Parameters:</p> Name Type Description Default <code>calendar_data</code> <p>Wide calendar format (168 time slots: 7 days \u00d7 24 hours)</p> required <code>title</code> <code>str | None</code> <p>Tooltip title. Optional.</p> <code>None</code> <code>width</code> <code>int</code> <p>Calendar chart width in pixels (default 300, smaller than popups)</p> <code>300</code> <code>height</code> <code>int</code> <p>Calendar chart height in pixels (default 200, smaller than popups)</p> <code>200</code> <code>compact</code> <code>bool</code> <p>Use compact styling that disables some interactive features to     reduce size and improve hover performance. Default is True.</p> <code>True</code> <code>**chart_kwargs</code> <p>Additional arguments passed to create_calendar_chart()</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tooltip</code> <p>folium.Tooltip object ready to add to markers or features</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import folium\n&gt;&gt;&gt; from latent_calendar.integrations.folium import create_calendar_tooltip\n&gt;&gt;&gt;\n&gt;&gt;&gt; tooltip = create_calendar_tooltip(\n...     calendar_data,\n...     title=\"Hover Preview\",\n...     compact=True\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; folium.Marker(\n...     [36.7, -119.7],\n...     tooltip=tooltip\n... ).add_to(map)\n</code></pre> Source code in <code>latent_calendar/integrations/folium.py</code> <pre><code>def create_calendar_tooltip(\n    calendar_data,\n    *,\n    title: str | None = None,\n    width: int = 300,\n    height: int = 200,\n    compact: bool = True,\n    **chart_kwargs,\n) -&gt; folium.Tooltip:\n    \"\"\"Create a Folium Tooltip object with embedded calendar heatmap.\n\n    Convenience function that returns a ready-to-use folium.Tooltip object containing\n    a compact calendar visualization. Tooltips appear on hover and should be smaller\n    and simpler than popups.\n\n    Args:\n        calendar_data: Wide calendar format (168 time slots: 7 days \u00d7 24 hours)\n        title: Tooltip title. Optional.\n        width: Calendar chart width in pixels (default 300, smaller than popups)\n        height: Calendar chart height in pixels (default 200, smaller than popups)\n        compact: Use compact styling that disables some interactive features to\n                reduce size and improve hover performance. Default is True.\n        **chart_kwargs: Additional arguments passed to create_calendar_chart()\n\n    Returns:\n        folium.Tooltip object ready to add to markers or features\n\n    Examples:\n        &gt;&gt;&gt; import folium\n        &gt;&gt;&gt; from latent_calendar.integrations.folium import create_calendar_tooltip\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; tooltip = create_calendar_tooltip(\n        ...     calendar_data,\n        ...     title=\"Hover Preview\",\n        ...     compact=True\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; folium.Marker(\n        ...     [36.7, -119.7],\n        ...     tooltip=tooltip\n        ... ).add_to(map)\n    \"\"\"\n    html = create_tooltip_html(\n        calendar_data,\n        title=title,\n        width=width,\n        height=height,\n        compact=compact,\n        **chart_kwargs,\n    )\n\n    return folium.Tooltip(html)\n</code></pre>"},{"location":"modules/integrations/folium/#latent_calendar.integrations.folium.create_popup_html","title":"<code>create_popup_html(calendar_data, *, title=None, width=400, height=300, **chart_kwargs)</code>","text":"<p>Create Folium-compatible popup HTML with calendar heatmap.</p> <p>Returns raw HTML string that can be used with folium.IFrame. This is useful for advanced users who want full control over the popup creation.</p> <p>For most use cases, consider using create_calendar_popup() which returns a ready-to-use folium.Popup object.</p> <p>Parameters:</p> Name Type Description Default <code>calendar_data</code> <p>Wide calendar format (168 time slots: 7 days \u00d7 24 hours).           Can be pandas Series, numpy array, or list.</p> required <code>title</code> <code>str | None</code> <p>Popup title displayed above the calendar. Optional.</p> <code>None</code> <code>width</code> <code>int</code> <p>Calendar chart width in pixels. Default is 400.</p> <code>400</code> <code>height</code> <code>int</code> <p>Calendar chart height in pixels. Default is 300.</p> <code>300</code> <code>**chart_kwargs</code> <p>Additional arguments passed to create_calendar_chart().            Useful options include:            - color_scheme: 'blues', 'greens', 'reds', 'viridis', etc.            - monday_start: True (default) or False for Sunday start            - interactive: True (default) for tooltips and zoom            - show_values: True (default) to show values in tooltips</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML string ready for folium.IFrame embedding</p> <p>Examples:</p> <p>Basic usage:</p> <pre><code>&gt;&gt;&gt; from latent_calendar.integrations.folium import create_popup_html\n&gt;&gt;&gt; import folium\n&gt;&gt;&gt;\n&gt;&gt;&gt; html = create_popup_html(calendar_data, title=\"My Calendar\")\n&gt;&gt;&gt; iframe = folium.IFrame(html, width=450, height=350)\n&gt;&gt;&gt; popup = folium.Popup(iframe, max_width=450)\n&gt;&gt;&gt; folium.Marker([36.7, -119.7], popup=popup).add_to(map)\n</code></pre> <p>With custom styling:</p> <pre><code>&gt;&gt;&gt; html = create_popup_html(\n...     calendar_data,\n...     title=\"Custom Calendar\",\n...     width=500,\n...     height=350,\n...     color_scheme='reds',\n...     monday_start=False\n... )\n</code></pre> Source code in <code>latent_calendar/integrations/folium.py</code> <pre><code>def create_popup_html(\n    calendar_data,\n    *,\n    title: str | None = None,\n    width: int = 400,\n    height: int = 300,\n    **chart_kwargs,\n) -&gt; str:\n    \"\"\"Create Folium-compatible popup HTML with calendar heatmap.\n\n    Returns raw HTML string that can be used with folium.IFrame.\n    This is useful for advanced users who want full control over the popup creation.\n\n    For most use cases, consider using create_calendar_popup() which returns\n    a ready-to-use folium.Popup object.\n\n    Args:\n        calendar_data: Wide calendar format (168 time slots: 7 days \u00d7 24 hours).\n                      Can be pandas Series, numpy array, or list.\n        title: Popup title displayed above the calendar. Optional.\n        width: Calendar chart width in pixels. Default is 400.\n        height: Calendar chart height in pixels. Default is 300.\n        **chart_kwargs: Additional arguments passed to create_calendar_chart().\n                       Useful options include:\n                       - color_scheme: 'blues', 'greens', 'reds', 'viridis', etc.\n                       - monday_start: True (default) or False for Sunday start\n                       - interactive: True (default) for tooltips and zoom\n                       - show_values: True (default) to show values in tooltips\n\n    Returns:\n        HTML string ready for folium.IFrame embedding\n\n    Examples:\n        Basic usage:\n\n        &gt;&gt;&gt; from latent_calendar.integrations.folium import create_popup_html\n        &gt;&gt;&gt; import folium\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; html = create_popup_html(calendar_data, title=\"My Calendar\")\n        &gt;&gt;&gt; iframe = folium.IFrame(html, width=450, height=350)\n        &gt;&gt;&gt; popup = folium.Popup(iframe, max_width=450)\n        &gt;&gt;&gt; folium.Marker([36.7, -119.7], popup=popup).add_to(map)\n\n        With custom styling:\n\n        &gt;&gt;&gt; html = create_popup_html(\n        ...     calendar_data,\n        ...     title=\"Custom Calendar\",\n        ...     width=500,\n        ...     height=350,\n        ...     color_scheme='reds',\n        ...     monday_start=False\n        ... )\n    \"\"\"\n    chart = create_calendar_chart(\n        calendar_data,\n        title=title,\n        width=width,\n        height=height,\n        **chart_kwargs,\n    )\n    html = chart.to_html(embed_options={\"actions\": False})\n\n    return html\n</code></pre>"},{"location":"modules/integrations/folium/#latent_calendar.integrations.folium.create_tooltip_html","title":"<code>create_tooltip_html(calendar_data, *, title=None, width=300, height=200, compact=True, **chart_kwargs)</code>","text":"<p>Create Folium-compatible tooltip HTML with calendar heatmap.</p> <p>Returns raw HTML string for a smaller, optimized calendar suitable for hover tooltips (as opposed to click popups). Tooltips should be more compact since they appear on hover and should not obstruct the map view.</p> <p>Parameters:</p> Name Type Description Default <code>calendar_data</code> <p>Wide calendar format (168 time slots: 7 days \u00d7 24 hours)</p> required <code>title</code> <code>str | None</code> <p>Tooltip title. Optional.</p> <code>None</code> <code>width</code> <code>int</code> <p>Tooltip width in pixels (default 300, smaller than popup default)</p> <code>300</code> <code>height</code> <code>int</code> <p>Tooltip height in pixels (default 200, smaller than popup default)</p> <code>200</code> <code>compact</code> <code>bool</code> <p>Use compact styling for smaller display. When True, disables     some interactive features to reduce size. Default is True.</p> <code>True</code> <code>**chart_kwargs</code> <p>Additional arguments passed to create_calendar_chart()</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML string ready for folium.Tooltip()</p> Note <p>Tooltips are shown on hover and should be smaller/simpler than popups. Consider using compact=True (default) to disable some features and reduce the size.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from latent_calendar.integrations.folium import create_tooltip_html\n&gt;&gt;&gt; import folium\n&gt;&gt;&gt;\n&gt;&gt;&gt; html = create_tooltip_html(\n...     calendar_data,\n...     title=\"Hover Preview\",\n...     compact=True\n... )\n&gt;&gt;&gt; tooltip = folium.Tooltip(html)\n</code></pre> Source code in <code>latent_calendar/integrations/folium.py</code> <pre><code>def create_tooltip_html(\n    calendar_data,\n    *,\n    title: str | None = None,\n    width: int = 300,\n    height: int = 200,\n    compact: bool = True,\n    **chart_kwargs,\n) -&gt; str:\n    \"\"\"Create Folium-compatible tooltip HTML with calendar heatmap.\n\n    Returns raw HTML string for a smaller, optimized calendar suitable for hover\n    tooltips (as opposed to click popups). Tooltips should be more compact since\n    they appear on hover and should not obstruct the map view.\n\n    Args:\n        calendar_data: Wide calendar format (168 time slots: 7 days \u00d7 24 hours)\n        title: Tooltip title. Optional.\n        width: Tooltip width in pixels (default 300, smaller than popup default)\n        height: Tooltip height in pixels (default 200, smaller than popup default)\n        compact: Use compact styling for smaller display. When True, disables\n                some interactive features to reduce size. Default is True.\n        **chart_kwargs: Additional arguments passed to create_calendar_chart()\n\n    Returns:\n        HTML string ready for folium.Tooltip()\n\n    Note:\n        Tooltips are shown on hover and should be smaller/simpler than popups.\n        Consider using compact=True (default) to disable some features and\n        reduce the size.\n\n    Examples:\n        &gt;&gt;&gt; from latent_calendar.integrations.folium import create_tooltip_html\n        &gt;&gt;&gt; import folium\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; html = create_tooltip_html(\n        ...     calendar_data,\n        ...     title=\"Hover Preview\",\n        ...     compact=True\n        ... )\n        &gt;&gt;&gt; tooltip = folium.Tooltip(html)\n    \"\"\"\n    if compact:\n        # Disable some features for compact display\n        chart_kwargs.setdefault(\"interactive\", False)\n        chart_kwargs.setdefault(\"show_values\", False)\n\n    return create_popup_html(\n        calendar_data,\n        title=title,\n        width=width,\n        height=height,\n        **chart_kwargs,\n    )\n</code></pre>"},{"location":"modules/integrations/folium/#quick-reference","title":"Quick Reference","text":""},{"location":"modules/integrations/folium/#main-functions","title":"Main Functions","text":"Function Returns Use Case <code>create_calendar_popup()</code> <code>folium.Popup</code> Interactive popup on click <code>create_calendar_tooltip()</code> <code>folium.Tooltip</code> Compact preview on hover <code>create_popup_html()</code> <code>str</code> Advanced HTML customization <code>create_tooltip_html()</code> <code>str</code> Advanced HTML customization"},{"location":"modules/integrations/folium/#common-parameters","title":"Common Parameters","text":"<p>All functions share these key parameters:</p> <ul> <li><code>calendar_data</code>: pd.Series with 168 values (7 days \u00d7 24 hours)</li> <li><code>title</code>: Optional title text</li> <li><code>width</code>: Chart width in pixels</li> <li><code>height</code>: Chart height in pixels</li> <li><code>color_scheme</code>: Altair color scheme name</li> <li><code>show_values</code>: Display numeric values in cells</li> <li><code>monday_start</code>: Start week on Monday (vs Sunday)</li> <li><code>interactive</code>: Enable zoom/pan</li> <li><code>max_width</code>: Maximum popup/tooltip width</li> </ul>"},{"location":"modules/integrations/folium/#usage-example","title":"Usage Example","text":""},{"location":"modules/integrations/folium/#quick-start","title":"Quick Start","text":"<p>Here's a minimal example showing UFO sightings in California:</p> <pre><code>import folium\nfrom latent_calendar.datasets import load_ufo_sightings\nfrom latent_calendar.integrations.folium import create_calendar_popup\n\n# 1. Load and aggregate data by state\ndf = load_ufo_sightings()\ndf_states = df[df['country'] == 'us'].cal.aggregate_events(\n    by='state/province',\n    timestamp_col='Date_time'\n)\n\n# 2. Get California's weekly pattern\ncalifornia_data = df_states.loc['ca']\n\n# 3. Create an interactive popup\npopup = create_calendar_popup(\n    california_data,\n    title=\"California UFO Sightings\",\n    width=400,\n    height=280,\n    color_scheme='blues'\n)\n\n# 4. Add to map\nm = folium.Map(location=[36.7, -119.7], zoom_start=6)\nfolium.Marker(\n    location=[36.7, -119.7],\n    popup=popup,\n    tooltip=\"Click to see calendar\"\n).add_to(m)\n\nm.save('california_ufos.html')\n</code></pre> <p>For complete examples with GeoJSON, multiple popups, and visual demonstrations, see the Folium Integration Guide.</p>"},{"location":"modules/integrations/folium/#customization-options","title":"Customization Options","text":""},{"location":"modules/integrations/folium/#color-schemes","title":"Color Schemes","text":"<p>All Altair/Vega color schemes are supported. Common choices:</p> <pre><code>color_scheme='blues'    # Blue gradient (default for popups)\ncolor_scheme='greens'   # Green gradient\ncolor_scheme='viridis'  # Perceptually uniform\ncolor_scheme='reds'     # Red gradient\n</code></pre>"},{"location":"modules/integrations/folium/#week-start-day","title":"Week Start Day","text":"<pre><code># Start week on Monday (default)\npopup = create_calendar_popup(data, monday_start=True)\n\n# Start week on Sunday (US convention)\npopup = create_calendar_popup(data, monday_start=False)\n</code></pre>"},{"location":"modules/integrations/folium/#interactive-features","title":"Interactive Features","text":"<pre><code># Enable zoom/pan and tooltips (default)\npopup = create_calendar_popup(data, interactive=True)\n\n# Disable interactivity for static display\npopup = create_calendar_popup(data, interactive=False, show_values=True)\n</code></pre>"},{"location":"modules/integrations/folium/#chart-dimensions","title":"Chart Dimensions","text":"<pre><code># Compact popup for mobile\npopup = create_calendar_popup(data, width=300, height=200, max_width=350)\n\n# Large popup for desktop\npopup = create_calendar_popup(data, width=600, height=400, max_width=650)\n</code></pre>"},{"location":"modules/integrations/folium/#data-requirements","title":"Data Requirements","text":"<p>The folium integration expects calendar data in wide format - a pandas Series with 168 values representing 7 days \u00d7 24 hours:</p> <pre><code># Get wide format using .cal.aggregate_events()\ndf_aggregated = df.cal.aggregate_events(\n    by='location_column',\n    timestamp_col='datetime_column'\n)\n\n# Each row is a location with 168 time slots\n&gt;&gt;&gt; df_aggregated.loc['ca']\nday_of_week  hour\n0            0       45\n             1       32\n             ...\n6            23      67\nName: ca, dtype: int64\n</code></pre>"},{"location":"modules/integrations/folium/#common-issues","title":"Common Issues","text":"<p>Popup not appearing? Make sure you call <code>.add_to(map)</code>: <pre><code>folium.Marker([lat, lon], popup=popup).add_to(m)  # Don't forget this!\n</code></pre></p> <p>Chart too small/large? Ensure <code>max_width &gt;= width</code>: <pre><code>popup = create_calendar_popup(data, width=500, max_width=600)\n</code></pre></p> <p>Map loading slowly? Use smaller dimensions and disable values: <pre><code>popup = create_calendar_popup(data, width=350, height=250, show_values=False)\n</code></pre></p>"},{"location":"modules/integrations/folium/#see-also","title":"See Also","text":"<ul> <li>Folium Integration Guide - Complete examples and use cases</li> <li>HTML Module - Low-level HTML generation</li> <li><code>.cal</code> Accessor - Data preparation</li> <li>UFO Sightings Example - Example dataset</li> <li>Folium Documentation - Official Folium docs</li> </ul>"},{"location":"modules/plot/colors/","title":"Colors","text":"<p>Handling the colors in the calendar plots.</p> <p>This module provides some helper function and some defaults. However, they might not be the best of all purposes.</p> <p>Color maps here take floats to a color string. Usually a hex string.</p> Example <p>Create a color map for count data.</p> <pre><code>cmap = create_default_cmap(max_value=10)\n\ncmap(0)  # '#ffffe5'\ncmap(5)  # '#379e54'\ncmap(10) # '#004529'\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.ColorMap","title":"<code>ColorMap</code>","text":"<p>               Bases: <code>ScalarMappable</code></p> <p>This supports colorbar for a figure from matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>norm</code> <p>matplotlib.colors.Normalize</p> required <code>cmap</code> <p>matplotlib.cm.ScalarMappable</p> required <code>default_cm</code> <code>CM</code> <p>matplotlib.cm.ScalarMappable</p> required Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>class ColorMap(ScalarMappable):\n    \"\"\"This supports colorbar for a figure from matplotlib.\n\n    Args:\n        norm: matplotlib.colors.Normalize\n        cmap: matplotlib.cm.ScalarMappable\n        default_cm: matplotlib.cm.ScalarMappable\n\n    \"\"\"\n\n    def __init__(self, norm, cmap, default_cm: CM) -&gt; None:\n        cmap = cmap if cmap is not None else default_cm\n        super().__init__(norm=norm, cmap=cmap)\n\n    def __call__(self, x: float) -&gt; str:\n        return rgb2hex(self.cmap(self.norm(x)))\n\n    def add_colorbar(self, ax=None) -&gt; None:\n        \"\"\"Add the colorbar to axis or axes.\n\n        Args:\n            ax: single or np.ndarray of Axes\n\n        \"\"\"\n        fig = plt.gcf()\n\n        fig.colorbar(self, ax=ax, ticks=self.norm.ticks)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.ColorMap.add_colorbar","title":"<code>add_colorbar(ax=None)</code>","text":"<p>Add the colorbar to axis or axes.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>single or np.ndarray of Axes</p> <code>None</code> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def add_colorbar(self, ax=None) -&gt; None:\n    \"\"\"Add the colorbar to axis or axes.\n\n    Args:\n        ax: single or np.ndarray of Axes\n\n    \"\"\"\n    fig = plt.gcf()\n\n    fig.colorbar(self, ax=ax, ticks=self.norm.ticks)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_cmap","title":"<code>create_cmap(max_value, min_value=0.0, cm=None)</code>","text":"<p>Create color map function.</p> <p>Parameters:</p> Name Type Description Default <code>max_value</code> <code>float</code> <p>maximum value for the color map</p> required <code>min_value</code> <code>float</code> <p>minimum value for the color map</p> <code>0.0</code> <code>cm</code> <code>CM | None</code> <p>function that takes a value and returns a color</p> <code>None</code> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_cmap(max_value: float, min_value: float = 0.0, cm: CM | None = None) -&gt; CMAP:\n    \"\"\"Create color map function.\n\n    Args:\n        max_value: maximum value for the color map\n        min_value: minimum value for the color map\n        cm: function that takes a value and returns a color\n\n    \"\"\"\n    norm = Normalize(vmin=min_value, vmax=max_value)\n    norm.ticks = [norm.vmin, norm.vmax]\n    return ColorMap(norm=norm, cmap=cm, default_cm=plt.cm.YlGn)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_diverge_cmap","title":"<code>create_diverge_cmap(center_value, range, cm=None)</code>","text":"<p>Create color map function to emphasize a center value and deviation from that center.</p> <p>Might be good for values that are relative to some baseline</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_diverge_cmap(\n    center_value: float, range: float, cm: CM | None = None\n) -&gt; CMAP:\n    \"\"\"Create color map function to emphasize a center value and deviation from that center.\n\n    Might be good for values that are relative to some baseline\n\n    \"\"\"\n    half_range = range / 2\n    norm = Normalize(vmin=center_value - half_range, vmax=center_value + half_range)\n    norm.ticks = [norm.vmin, 0, norm.vmax]\n    return ColorMap(norm=norm, cmap=cm, default_cm=plt.cm.coolwarm)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.create_relative_cmap","title":"<code>create_relative_cmap(range)</code>","text":"<p>Good for relative scales.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def create_relative_cmap(range: float) -&gt; CMAP:\n    \"\"\"Good for relative scales.\"\"\"\n    return create_diverge_cmap(center_value=1.0, range=range)\n</code></pre>"},{"location":"modules/plot/colors/#latent_calendar.plot.colors.settle_data_and_cmap","title":"<code>settle_data_and_cmap(data, divergent)</code>","text":"<p>Return a tuple of transformed data and cmap for displaying that data.</p> Source code in <code>latent_calendar/plot/colors.py</code> <pre><code>def settle_data_and_cmap(data, divergent: bool) -&gt; tuple[np.ndarray, CMAP]:\n    \"\"\"Return a tuple of transformed data and cmap for displaying that data.\"\"\"\n    if divergent:\n        # Comparing the values to random rate\n        EVEN_PROBABILITY = 1 / data.shape[0]\n        data = data / EVEN_PROBABILITY\n        return data, create_default_divergent_cmap()\n\n    return data, create_default_cmap(value=data.max())\n</code></pre>"},{"location":"modules/plot/config/","title":"Config","text":"<p>Configuration file for plotting.</p>"},{"location":"modules/plot/config/#latent_calendar.plot.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Default configuration used in some of the plots.</p> <p>Parameters:</p> Name Type Description Default <code>divergent</code> <code>bool</code> <p>whether to show divergent calendar by default.</p> <code>True</code> <code>range</code> <code>float</code> <p>Where to a divergent plot</p> <code>3.0</code> <code>max_value_ratio</code> <code>float</code> <p>Where to clip the default cmap in the calendar view</p> <code>0.75</code> Source code in <code>latent_calendar/plot/config.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"Default configuration used in some of the plots.\n\n    Args:\n        divergent: whether to show divergent calendar by default.\n        range: Where to a divergent plot\n        max_value_ratio: Where to clip the default cmap in the calendar view\n\n    \"\"\"\n\n    divergent: bool = True\n    range: float = 3.0\n    max_value_ratio: float = 0.75\n</code></pre>"},{"location":"modules/plot/core/","title":"Core","text":"<p>Plots including a model.</p>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_blank_calendar","title":"<code>plot_blank_calendar(day_labeler=DayLabeler(), time_labeler=TimeLabeler(), display_settings=None, ax=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Create a blank calendar with no data</p> <p>Parameters:</p> Name Type Description Default <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>display_settings</code> <code>DisplaySettings | None</code> <p>override of the display settings in the calendar</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>Optional axes to plot on</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_blank_calendar(\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    display_settings: DisplaySettings | None = None,\n    ax: plt.Axes | None = None,\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n) -&gt; plt.Axes:\n    \"\"\"Create a blank calendar with no data\n\n    Args:\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        display_settings: override of the display settings in the calendar\n        ax: Optional axes to plot on\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    update_start(day_labeler=day_labeler, monday_start=monday_start)\n\n    if display_settings is not None:\n        update_display_settings(\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            display_settings=display_settings,\n        )\n\n    ax = ax if ax is not None else plt.gca()\n\n    configure_axis(ax=ax, day_labeler=day_labeler, time_labeler=time_labeler)\n    grid_lines.configure_grid(ax=ax)\n\n    return ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_calendar","title":"<code>plot_calendar(calendar_iter, *, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), display_settings=None, cmap=None, alpha=None, ax=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Plot a calendar from generator of values.</p> <p>This can plot both numpy matrix and DataFrame values as long as the iterable fits CALENDAR_ITERATION definition</p> <p>Parameters:</p> Name Type Description Default <code>calendar_iter</code> <code>CALENDAR_ITERATION</code> <p>CALENDAR_ITERATION</p> required <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>display_settings</code> <code>DisplaySettings | None</code> <p>override of the display settings in the calendar</p> <code>None</code> <code>cmap</code> <code>CMAP | None</code> <p>function that maps floats to string colors</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>Optional axes to plot on</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Modified matplotlib axis</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_calendar(\n    calendar_iter: CALENDAR_ITERATION,\n    *,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    display_settings: DisplaySettings | None = None,\n    cmap: CMAP | None = None,\n    alpha: float | None = None,\n    ax: plt.Axes | None = None,\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n) -&gt; plt.Axes:\n    \"\"\"Plot a calendar from generator of values.\n\n    This can plot both numpy matrix and DataFrame values as long as the iterable fits CALENDAR_ITERATION definition\n\n    Args:\n        calendar_iter: CALENDAR_ITERATION\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        display_settings: override of the display settings in the calendar\n        cmap: function that maps floats to string colors\n        ax: Optional axes to plot on\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        Modified matplotlib axis\n\n    \"\"\"\n    ax = plot_blank_calendar(\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        display_settings=display_settings,\n        ax=ax,\n        grid_lines=grid_lines,\n        monday_start=monday_start,\n    )\n\n    if cmap is None:\n\n        def cmap(x: float) -&gt; str:\n            return \"lightblue\"\n\n    for calendar_data in calendar_iter:\n        event = CalendarEvent.from_calendar_data(calendar_data=calendar_data)\n\n        event.plot(\n            ax=ax,\n            facecolor=cmap(calendar_data.value),\n            alpha=alpha,\n            monday_start=monday_start,\n        )\n\n    return ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_calendar_by_row","title":"<code>plot_calendar_by_row(df, max_cols=3, title_func=None, day_labeler=None, time_labeler=None, cmaps=None, grid_lines=GridLines(), monday_start=True)</code>","text":"<p>Iterate a DataFrame by row and plot calendar events.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>wide DataFrame where each column is the vocabulary</p> required <code>max_cols</code> <code>int</code> <p>max number of columns in the created grid.</p> <code>3</code> <code>title_func</code> <code>TITLE_FUNC | None</code> <p>function to make the title from DataFrame index and DataFrame row, default like '2020-01-01 n_trip(s) = 10'</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler | None</code> <p>base day_labeler</p> <code>None</code> <code>time_labeler</code> <code>TimeLabeler | None</code> <p>base day_labeler</p> <code>None</code> <code>cmaps</code> <code>CMAP | ColorMap | CMAP_GENERATOR | None</code> <p>Colormapping function(s) to use for each row</p> <code>None</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_calendar_by_row(\n    df: pd.DataFrame,\n    max_cols: int = 3,\n    title_func: TITLE_FUNC | None = None,\n    day_labeler: DayLabeler | None = None,\n    time_labeler: TimeLabeler | None = None,\n    cmaps: CMAP | ColorMap | CMAP_GENERATOR | None = None,\n    grid_lines: GridLines = GridLines(),\n    monday_start: bool = True,\n) -&gt; None:\n    \"\"\"Iterate a DataFrame by row and plot calendar events.\n\n    Args:\n        df: wide DataFrame where each column is the vocabulary\n        max_cols: max number of columns in the created grid.\n        title_func: function to make the title from DataFrame index and DataFrame row, default like '2020-01-01 n_trip(s) = 10'\n        day_labeler: base day_labeler\n        time_labeler: base day_labeler\n        cmaps: Colormapping function(s) to use for each row\n        grid_lines: GridLines instance\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        None\n\n    \"\"\"\n    n_cols = len(df.columns)\n    if n_cols % 7 != 0:\n        raise CalendarFormatError(\n            f\"Number of columns must be a multiple of 7, got {n_cols} columns. Make sure DataFrame is in wide calendar format.\"\n        )\n\n    title_func = title_func if title_func is not None else default_title_func\n\n    if isinstance(cmaps, ColorMap):\n        cmaps = repeat(cmaps)\n\n    if cmaps is None:\n        cmaps = repeat(create_default_cmap(value=df.to_numpy().max()))\n\n    total = len(df)\n\n    for (ax, plot_axes), (idx, row), cmap in zip(\n        default_axes_and_grid_axes(\n            total=total,\n            max_cols=max_cols,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        ),\n        df.iterrows(),\n        cmaps,\n    ):\n        calendar_data = row.to_numpy()\n        plot_calendar(\n            iterate_long_array(calendar_data),\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            grid_lines=grid_lines,\n            ax=ax,\n            cmap=cmap,\n            monday_start=monday_start,\n        )\n        title = title_func(idx, row)\n        ax.set_title(title)\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_dataframe_as_calendar","title":"<code>plot_dataframe_as_calendar(df, config, *, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines(), cmap=None, alpha=None, ax=None, monday_start=True)</code>","text":"<p>Simple Wrapper about plot_calendar in order to plot DataFrame in various formats</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame in format with columns in config instance</p> required <code>config</code> <code>DataFrameConfig</code> <p>DataFrameConfig</p> required <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>cmap</code> <code>CMAP | None</code> <p>function that maps floats to string colors</p> <code>None</code> <code>alpha</code> <code>float | None</code> <p>alpha level of each rectangle</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>optional axis to plot on</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>new or modified axes</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_dataframe_as_calendar(\n    df: pd.DataFrame,\n    config: DataFrameConfig,\n    *,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n    cmap: CMAP | None = None,\n    alpha: float | None = None,\n    ax: plt.Axes | None = None,\n    monday_start: bool = True,\n) -&gt; plt.Axes:\n    \"\"\"Simple Wrapper about plot_calendar in order to plot DataFrame in various formats\n\n    Args:\n        df: DataFrame in format with columns in config instance\n        config: DataFrameConfig\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        grid_lines: GridLines instance\n        cmap: function that maps floats to string colors\n        alpha: alpha level of each rectangle\n        ax: optional axis to plot on\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        new or modified axes\n\n    \"\"\"\n    return plot_calendar(\n        iterate_dataframe(df, config),\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        cmap=cmap,\n        alpha=alpha,\n        ax=ax,\n        monday_start=monday_start,\n        grid_lines=grid_lines,\n    )\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_dataframe_grid_across_column","title":"<code>plot_dataframe_grid_across_column(df, grid_col, config=None, max_cols=3, *, alpha=None, monday_start=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler(), grid_lines=GridLines())</code>","text":"<p>Plot the long DataFrame in a grid by some different column.</p> <p>Continuous version of the plot_calendar_by_row</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to plot. Requires all the columns in config</p> required <code>grid_col</code> <code>str</code> <p>column name of DataFrame to plot across</p> required <code>config</code> <code>DataFrameConfig | None</code> <p>DataFrameConfig instance of the column mapping. Default IterConfig</p> <code>None</code> <code>max_cols</code> <code>int</code> <p>max number of columns in the grid</p> <code>3</code> <code>alpha</code> <code>float | None</code> <p>alpha of each calendar event</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_dataframe_grid_across_column(\n    df: pd.DataFrame,\n    grid_col: str,\n    config: DataFrameConfig | None = None,\n    max_cols: int = 3,\n    *,\n    alpha: float | None = None,\n    monday_start: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    grid_lines: GridLines = GridLines(),\n) -&gt; None:\n    \"\"\"Plot the long DataFrame in a grid by some different column.\n\n    Continuous version of the plot_calendar_by_row\n\n    Args:\n        df: DataFrame to plot. Requires all the columns in config\n        grid_col: column name of DataFrame to plot across\n        config: DataFrameConfig instance of the column mapping. Default IterConfig\n        max_cols: max number of columns in the grid\n        alpha: alpha of each calendar event\n        monday_start: whether to start the week on Monday or Sunday\n\n    \"\"\"\n    if grid_col not in df.columns:\n        msg = f\"{grid_col} is not in the DataFrame.\"\n        raise KeyError(msg)\n\n    values = df.loc[:, grid_col].dropna().unique()\n    # Use np.sort() for pandas 3.0 compatibility (ArrowStringArray has no sort() method)\n    values = np.sort(values)\n\n    total = len(values)\n\n    for (ax, plot_axes), value in zip(\n        default_axes_and_grid_axes(\n            total=total,\n            max_cols=max_cols,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        ),\n        values,\n    ):\n        idx = df[grid_col] == value\n        df_tmp = df.loc[idx, :]\n\n        day_labeler, time_labeler = plot_axes\n\n        plot_dataframe_as_calendar(\n            df=df_tmp,\n            config=config,\n            ax=ax,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n            alpha=alpha,\n            monday_start=monday_start,\n        )\n        ax.set_title(f\"{value}\")\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.calendar.plot_series_as_calendar","title":"<code>plot_series_as_calendar(series, *, grid_lines=GridLines(), day_labeler=DayLabeler(), time_labeler=TimeLabeler(), cmap=None, alpha=None, ax=None, monday_start=True)</code>","text":"<p>Simple Wrapper about plot_calendar in order to plot Series in various formats</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>Series in format with index as datetime and values as float</p> required <code>grid_lines</code> <code>GridLines</code> <p>GridLines instance</p> <code>GridLines()</code> <code>day_labeler</code> <code>DayLabeler</code> <p>instance in order to configure the day labels</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>instance in order to configure the time labels</p> <code>TimeLabeler()</code> <code>cmap</code> <code>CMAP | None</code> <p>function that maps floats to string colors</p> <code>None</code> <code>alpha</code> <code>float | None</code> <p>alpha level of each rectangle</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>optional axis to plot on</p> <code>None</code> <code>monday_start</code> <code>bool</code> <p>whether to start the week on Monday or Sunday</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>new or modified axes</p> Source code in <code>latent_calendar/plot/core/calendar.py</code> <pre><code>def plot_series_as_calendar(\n    series: pd.Series,\n    *,\n    grid_lines: GridLines = GridLines(),\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n    cmap: CMAP | None = None,\n    alpha: float | None = None,\n    ax: plt.Axes | None = None,\n    monday_start: bool = True,\n) -&gt; plt.Axes:\n    \"\"\"Simple Wrapper about plot_calendar in order to plot Series in various formats\n\n    Args:\n        series: Series in format with index as datetime and values as float\n        grid_lines: GridLines instance\n        day_labeler: instance in order to configure the day labels\n        time_labeler: instance in order to configure the time labels\n        cmap: function that maps floats to string colors\n        alpha: alpha level of each rectangle\n        ax: optional axis to plot on\n        monday_start: whether to start the week on Monday or Sunday\n\n    Returns:\n        new or modified axes\n\n    \"\"\"\n    if cmap is None:\n        cmap = create_default_cmap(value=series.to_numpy().max())\n\n    return plot_calendar(\n        iterate_series(series),\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n        cmap=cmap,\n        alpha=alpha,\n        ax=ax,\n        monday_start=monday_start,\n        grid_lines=grid_lines,\n    )\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_component_distribution","title":"<code>plot_component_distribution(X_latent, model, ax)</code>","text":"<p>Third profile plot.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_component_distribution(\n    X_latent: np.ndarray, model: LatentCalendar, ax: plt.Axes\n) -&gt; plt.Axes:\n    \"\"\"Third profile plot.\"\"\"\n    x = range(len(X_latent))\n    ax.bar(x, X_latent)\n    step = 1 if model.n_components &lt; 15 else 2\n    ax.set_xticks(np.arange(model.n_components, step=step))\n    ax.set_ylabel(\"P[L=l | Data]\")\n    ax.set_title(\"Latent Component Distribution\")\n\n    return ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_distribution","title":"<code>plot_distribution(X_probs, ax, display_y_axis=True, divergent=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Second plot of the profile calendar probability distribution.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_distribution(\n    X_probs: np.ndarray,\n    ax: plt.Axes,\n    display_y_axis: bool = True,\n    divergent: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; plt.Axes:\n    \"\"\"Second plot of the profile calendar probability distribution.\"\"\"\n    time_labeler.display = display_y_axis\n\n    data, cmap = settle_data_and_cmap(data=X_probs, divergent=divergent)\n\n    iter_data = iterate_long_array(data)\n\n    subtext = \"Comparison to random rate\" if divergent else \"Raw Probabilities\"\n    plot_calendar(\n        iter_data,\n        ax=ax,\n        cmap=cmap,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n    title = f\"Predicted Probability Distribution\\n{subtext}\"\n    ax.set_title(title)\n\n    return ax\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_model_components","title":"<code>plot_model_components(model, max_cols=5, divergent=True, components=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Helper function to create plot of all the components of the LatentCalendar instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar instance</p> required <code>max_cols</code> <code>int</code> <p>maximum number of columns in the grid of calendar components.</p> <code>5</code> <code>divergent</code> <code>bool</code> <p>what data to plot</p> <code>True</code> <code>components</code> <code>Iterable[int] | None</code> <p>Specific subset of components to plot. Default is all</p> <code>None</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_model_components(\n    model: LatentCalendar,\n    max_cols: int = 5,\n    divergent: bool = True,\n    components: Iterable[int] | None = None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; None:\n    \"\"\"Helper function to create plot of all the components of the LatentCalendar instance.\n\n    Args:\n        model: LatentCalendar instance\n        max_cols: maximum number of columns in the grid of calendar components.\n        divergent: what data to plot\n        components: Specific subset of components to plot. Default is all\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n\n    Returns:\n        None\n\n    \"\"\"\n    if components is None:\n        components = list(range(model.n_components))\n\n    if any([component &gt; model.n_components - 1 for component in components]):\n        msg = f\"One of the listed components is greater than the total number {model.n_components}\"\n        raise ValueError(msg)\n\n    total = len(components)\n    normalized_components_to_plot = model.normalized_components_[components]\n\n    def get_title(component_idx: int) -&gt; str:\n        return f\"Component {component_idx}\"\n\n    # TOOD: refactor to just use the plot_calendar_by_row ?\n    values = zip(\n        components,\n        default_axes_and_grid_axes(\n            total=total,\n            max_cols=max_cols,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        ),\n        normalized_components_to_plot,\n    )\n    for component_idx, (ax, plot_axes), latent in values:\n        data, cmap = settle_data_and_cmap(latent, divergent)\n\n        day_labeler, time_labeler = plot_axes\n        plot_calendar(\n            iterate_long_array(data),\n            cmap=cmap,\n            ax=ax,\n            day_labeler=day_labeler,\n            time_labeler=time_labeler,\n        )\n        title = get_title(component_idx=component_idx)\n        ax.set_title(title)\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_model_predictions","title":"<code>plot_model_predictions(X_to_predict, X_holdout, model, divergent=True, axes=None, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Plot the model predictions compared to the test data.</p> <p>Parameters:</p> Name Type Description Default <code>X_to_predict</code> <code>ndarray</code> <p>Data for the model</p> required <code>X_holdout</code> <code>ndarray</code> <p>Holdout data for the model</p> required <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar model instance</p> required <code>divergent</code> <code>bool</code> <p>Option to change the data displayed</p> <code>True</code> <code>axes</code> <code>Iterable[Axes]</code> <p>list of 3 axes to plot this data</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Axes]</code> <p>The axes used for plotting</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_model_predictions(\n    X_to_predict: np.ndarray,\n    X_holdout: np.ndarray,\n    model: LatentCalendar,\n    divergent: bool = True,\n    axes: Iterable[plt.Axes] = None,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; Iterable[plt.Axes]:\n    \"\"\"Plot the model predictions compared to the test data.\n\n    Args:\n        X_to_predict: Data for the model\n        X_holdout: Holdout data for the model\n        model: LatentCalendar model instance\n        divergent: Option to change the data displayed\n        axes: list of 3 axes to plot this data\n\n    Returns:\n        The axes used for plotting\n\n    \"\"\"\n    X_to_predict = X_to_predict[np.newaxis, :]\n    X_holdout = X_holdout[np.newaxis, :]\n\n    if axes is None:\n        _, axes = plt.subplots(nrows=1, ncols=3)\n\n    X_to_predict_probs = model.predict(X_to_predict)[0]\n\n    ax = axes[0]\n    plot_raw_data(\n        array=X_to_predict, ax=ax, day_labeler=day_labeler, time_labeler=time_labeler\n    )\n    ax.set_title(\"Raw Data for Prediction\")\n\n    ax = axes[1]\n    plot_distribution(\n        X_probs=X_to_predict_probs,\n        ax=ax,\n        display_y_axis=False,\n        divergent=divergent,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n    ax.set_title(\"Distribution from Prediction\")\n\n    ax = axes[2]\n    plot_raw_data(\n        array=X_holdout,\n        ax=ax,\n        display_y_axis=False,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n    ax.set_title(\"Raw Data in Future\")\n\n    return axes\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_profile","title":"<code>plot_profile(array, model, divergent=True, axes=None, include_components=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>Create a profile plot with 3 different plots.</p> <p>Displays the raw data, predicted probability distribution, and latent breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>long array (n_timeslots, )</p> required <code>model</code> <code>LatentCalendar</code> <p>LatentCalendar model instance</p> required <code>divergent</code> <code>bool</code> <p>Option to change the data displayed</p> <code>True</code> <code>axes</code> <code>Iterable[Axes]</code> <p>list of 3 axes to plot this data</p> <code>None</code> <code>include_components</code> <code>bool</code> <p>If the last component plot should be included</p> <code>True</code> <code>day_labeler</code> <code>DayLabeler</code> <p>DayLabeler instance</p> <code>DayLabeler()</code> <code>time_labeler</code> <code>TimeLabeler</code> <p>TimeLabeler instance</p> <code>TimeLabeler()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>None</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_profile(\n    array: np.ndarray,\n    model: LatentCalendar,\n    divergent: bool = True,\n    axes: Iterable[plt.Axes] = None,\n    include_components: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; np.ndarray:\n    \"\"\"Create a profile plot with 3 different plots.\n\n    Displays the raw data, predicted probability distribution, and latent breakdown.\n\n    Args:\n        array: long array (n_timeslots, )\n        model: LatentCalendar model instance\n        divergent: Option to change the data displayed\n        axes: list of 3 axes to plot this data\n        include_components: If the last component plot should be included\n        day_labeler: DayLabeler instance\n        time_labeler: TimeLabeler instance\n\n    Returns:\n        None\n\n    \"\"\"\n    ncols = 3 if include_components else 2\n    if axes is None:\n        _, axes = plt.subplots(nrows=1, ncols=ncols)\n\n    if len(axes) != ncols:\n        msg = \"The axes do not equal the number of plots required.\"\n        raise ValueError(msg)\n\n    # Data under model\n    X_new = array[np.newaxis, :]\n    X_probs = model.predict(X_new)[0]\n\n    # Raw Data\n    ax = axes[0]\n    plot_raw_data(\n        array=array, ax=ax, day_labeler=day_labeler, time_labeler=time_labeler\n    )\n\n    # Under Model\n    ax = axes[1]\n    plot_distribution(\n        X_probs=X_probs,\n        ax=ax,\n        display_y_axis=False,\n        divergent=divergent,\n        day_labeler=day_labeler,\n        time_labeler=time_labeler,\n    )\n\n    # Component distribution\n    if include_components:\n        ax = axes[2]\n        X_latent = model.transform(X_new)[0]\n        plot_component_distribution(X_latent=X_latent, model=model, ax=ax)\n\n    return axes\n</code></pre>"},{"location":"modules/plot/core/#latent_calendar.plot.core.model.plot_raw_data","title":"<code>plot_raw_data(array, ax, display_y_axis=True, day_labeler=DayLabeler(), time_labeler=TimeLabeler())</code>","text":"<p>First plot of raw data.</p> Source code in <code>latent_calendar/plot/core/model.py</code> <pre><code>def plot_raw_data(\n    array: np.ndarray,\n    ax: plt.Axes,\n    display_y_axis: bool = True,\n    day_labeler: DayLabeler = DayLabeler(),\n    time_labeler: TimeLabeler = TimeLabeler(),\n) -&gt; plt.Axes:\n    \"\"\"First plot of raw data.\"\"\"\n    try:\n        max_value = np.quantile(array[array &gt; 0], 0.95)\n    except IndexError:\n        max_value = 1\n\n    time_labeler.display = display_y_axis\n\n    cmap = create_default_cmap(value=max_value)\n\n    plot_calendar(\n        iterate_long_array(array),\n        ax=ax,\n        cmap=cmap,\n        time_labeler=time_labeler,\n        day_labeler=day_labeler,\n    )\n    ax.set_title(\"Raw Data\")\n\n    return ax\n</code></pre>"},{"location":"modules/plot/elements/","title":"Elements","text":"<p>The specific elements on the calendar plot.</p> <p>Includes x-axis, y-axis, and their settings, as well as the calendar events.</p>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent","title":"<code>CalendarEvent</code>  <code>dataclass</code>","text":"<p>Something on the calendar.</p> <p>Plots rectangles on matplotlib axis.</p> <p>Parameters:</p> Name Type Description Default <code>day</code> <code>int</code> <p>The day of the week. 0 is Monday.</p> required <code>start</code> <code>float</code> <p>The start hour of the event.</p> required <code>end</code> <code>float | None</code> <p>The end hour of the event.</p> <code>None</code> <code>duration</code> <code>float | None</code> <p>The duration of the event. Only used if end is None.</p> <code>None</code> <code>days</code> <code>int</code> <p>The number of days the event spans. Default is 1.</p> <code>1</code> <p>Examples:</p> <p>Plot event from calendar data</p> <pre><code>calendar_data = CalendarData(day=0, start=0, end=2.5)\nevent = CalendarEvent.from_calendar_data(calendar_data=calendar_data, cmap=...)\nevent.plot(ax=ax)\n</code></pre> <p>Plot a single calendar event from vocab</p> <pre><code>event = CalendarEvent.from_vocab(\"00 01\")\nevent.plot(ax=ax)\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass CalendarEvent:\n    \"\"\"Something on the calendar.\n\n    Plots rectangles on matplotlib axis.\n\n    Args:\n        day: The day of the week. 0 is Monday.\n        start: The start hour of the event.\n        end: The end hour of the event.\n        duration: The duration of the event. Only used if end is None.\n        days: The number of days the event spans. Default is 1.\n\n    Examples:\n        Plot event from calendar data\n\n        ```python\n        calendar_data = CalendarData(day=0, start=0, end=2.5)\n        event = CalendarEvent.from_calendar_data(calendar_data=calendar_data, cmap=...)\n        event.plot(ax=ax)\n        ```\n\n        Plot a single calendar event from vocab\n\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\")\n        event.plot(ax=ax)\n        ```\n\n    \"\"\"\n\n    day: int\n    start: float\n    end: float | None = None\n    duration: float | None = None\n    days: int = 1\n\n    def __post_init__(self) -&gt; None:\n        if self.day not in range(DAYS_IN_WEEK):\n            raise ValueError(\"Day must be between 0 and 6\")\n\n        if self.end is None and self.duration is None:\n            raise ValueError(\"Either end or duration must be provided\")\n\n        if self.end is not None and self.duration is not None:\n            raise ValueError(\"Only one of end or duration can be provided\")\n\n        if self.end is None:\n            self.end = self.start + (self.duration / 60)\n            self.duration = None\n\n        if self.days not in range(1, DAYS_IN_WEEK + 1):\n            raise ValueError(\"Days must be between 1 and 7\")\n\n    @classmethod\n    def from_calendar_data(\n        cls,\n        calendar_data: CalendarData,\n    ) -&gt; \"CalendarEvent\":\n        return cls(\n            day=calendar_data.day,\n            start=calendar_data.start,\n            end=calendar_data.end,\n        )\n\n    @classmethod\n    def from_vocab(\n        cls,\n        vocab: str,\n        duration: float = 60.0,\n    ) -&gt; \"CalendarEvent\":\n        \"\"\"Constructor from vocab string in order to plot on an axis.\n\n        Args:\n            vocab: The vocab string.\n            duration: The duration of the event.\n\n        Example:\n            Plot on an axis\n\n            ```python\n            event = CalendarEvent.from_vocab(\"00 01\")\n            event.plot(ax=ax)\n            ```\n\n            Plot a two and half hour window\n\n            ```python\n            event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\n            event.plot(ax=ax)\n            ```\n\n        \"\"\"\n        day, hour = get_day_hour(vocab=vocab)\n\n        return cls(\n            day=day,\n            start=hour,\n            end=hour + (duration / 60),\n        )\n\n    @property\n    def multiday_tour(self) -&gt; bool:\n        if self.end == HOURS_IN_DAY:\n            return False\n\n        return self.end % HOURS_IN_DAY &lt; self.start\n\n    @property\n    def multiweek_tour(self) -&gt; bool:\n        return self.day + self.days &gt; DAYS_IN_WEEK\n\n    def _cap_event_at_week_end(self) -&gt; None:\n        self.days = DAYS_IN_WEEK - self.day\n\n    def _create_next_week_event(self) -&gt; \"CalendarEvent\":\n        return CalendarEvent(\n            day=0,\n            start=self.start,\n            end=self.end,\n            days=self.days - DAYS_IN_WEEK + self.day,\n        )\n\n    def _cap_event_at_midnight(self) -&gt; None:\n        self.end = min(HOURS_IN_DAY, self.end)\n\n    def _create_next_day_event(self) -&gt; \"CalendarEvent\":\n        \"\"\"In the case of tour going into the next day, this is the next item.\"\"\"\n        return CalendarEvent(\n            day=(self.day + 1) % DAYS_IN_WEEK,\n            start=0,\n            end=self.end % HOURS_IN_DAY,\n            days=self.days,\n        )\n\n    def separate_events(self) -&gt; list[\"CalendarEvent\"]:\n        \"\"\"Return list of events that represent the one event across different days.\n\n        Examples:\n            A single event that goes from 23:00 to 01:00 will be split into two events.\n\n            ```python\n            event = CalendarEvent(day=0, start=23, duration=2 * 60)\n\n            events = event.separate_events()\n            ```\n\n        \"\"\"\n        event = replace(self)\n        events = [event]\n\n        if event.multiday_tour:\n            events.append(event._create_next_day_event())\n            event._cap_event_at_midnight()\n\n        for event in events:\n            if not event.multiweek_tour:\n                continue\n\n            events.append(event._create_next_week_event())\n            event._cap_event_at_week_end()\n\n        return events\n\n    def _create_matplotlib_rectangle(\n        self, monday_start: bool, lw, fill: bool, linestyle, fillcolor, alpha, **kwargs\n    ) -&gt; plt.Rectangle:\n        \"\"\"Create a rectangle matplotlib instance from the event.\"\"\"\n        height = self.end - self.start\n        assert height &gt; 0.0, (\n            f\"The rectangle doesn't have positive height. Hour start {self.start} &gt; Hour end {self.end}\"\n        )\n\n        x = self.day if monday_start else (self.day + 1) % DAYS_IN_WEEK\n        rect_kwargs = {\n            \"xy\": [x, self.start],\n            \"width\": self.days,\n            \"height\": height,\n        }\n\n        rect_kwargs[\"edgecolor\"] = \"black\"\n        rect_kwargs[\"lw\"] = lw\n        rect_kwargs[\"fill\"] = fill\n        rect_kwargs[\"linestyle\"] = linestyle\n        rect_kwargs[\"facecolor\"] = fillcolor\n        rect_kwargs[\"alpha\"] = alpha\n\n        rect_kwargs.update(kwargs)\n\n        return plt.Rectangle(**rect_kwargs)\n\n    def plot(\n        self,\n        ax: plt.Axes,\n        monday_start: bool = True,\n        lw: float = 0.1,\n        fill: bool = True,\n        linestyle=None,\n        fillcolor=None,\n        alpha=None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Put the CalendarEvent instance onto an axis.\n\n        Options for kwargs [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html).\n\n        Args:\n            ax: Axis to plot on\n            monday_start: Whether to start the week on Monday or Sunday.\n            lw: The line width of the event.\n            fill: Whether to fill the event.\n            linestyle: The line style of the event.\n            fillcolor: The color of the event.\n            alpha: The alpha of the event.\n            kwargs: Addtional kwargs for the Patch instances or to override.\n\n        \"\"\"\n        for event in self.separate_events():\n            rectangle = event._create_matplotlib_rectangle(\n                monday_start=monday_start,\n                lw=lw,\n                fill=fill,\n                linestyle=linestyle,\n                fillcolor=fillcolor,\n                alpha=alpha,\n                **kwargs,\n            )\n            if \"label\" in kwargs:\n                kwargs.pop(\"label\")\n\n            ax.add_patch(rectangle)\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.from_vocab","title":"<code>from_vocab(vocab, duration=60.0)</code>  <code>classmethod</code>","text":"<p>Constructor from vocab string in order to plot on an axis.</p> <p>Parameters:</p> Name Type Description Default <code>vocab</code> <code>str</code> <p>The vocab string.</p> required <code>duration</code> <code>float</code> <p>The duration of the event.</p> <code>60.0</code> Example <p>Plot on an axis</p> <pre><code>event = CalendarEvent.from_vocab(\"00 01\")\nevent.plot(ax=ax)\n</code></pre> <p>Plot a two and half hour window</p> <pre><code>event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\nevent.plot(ax=ax)\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@classmethod\ndef from_vocab(\n    cls,\n    vocab: str,\n    duration: float = 60.0,\n) -&gt; \"CalendarEvent\":\n    \"\"\"Constructor from vocab string in order to plot on an axis.\n\n    Args:\n        vocab: The vocab string.\n        duration: The duration of the event.\n\n    Example:\n        Plot on an axis\n\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\")\n        event.plot(ax=ax)\n        ```\n\n        Plot a two and half hour window\n\n        ```python\n        event = CalendarEvent.from_vocab(\"00 01\", hours=2.5)\n        event.plot(ax=ax)\n        ```\n\n    \"\"\"\n    day, hour = get_day_hour(vocab=vocab)\n\n    return cls(\n        day=day,\n        start=hour,\n        end=hour + (duration / 60),\n    )\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.plot","title":"<code>plot(ax, monday_start=True, lw=0.1, fill=True, linestyle=None, fillcolor=None, alpha=None, **kwargs)</code>","text":"<p>Put the CalendarEvent instance onto an axis.</p> <p>Options for kwargs here.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axis to plot on</p> required <code>monday_start</code> <code>bool</code> <p>Whether to start the week on Monday or Sunday.</p> <code>True</code> <code>lw</code> <code>float</code> <p>The line width of the event.</p> <code>0.1</code> <code>fill</code> <code>bool</code> <p>Whether to fill the event.</p> <code>True</code> <code>linestyle</code> <p>The line style of the event.</p> <code>None</code> <code>fillcolor</code> <p>The color of the event.</p> <code>None</code> <code>alpha</code> <p>The alpha of the event.</p> <code>None</code> <code>kwargs</code> <p>Addtional kwargs for the Patch instances or to override.</p> <code>{}</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def plot(\n    self,\n    ax: plt.Axes,\n    monday_start: bool = True,\n    lw: float = 0.1,\n    fill: bool = True,\n    linestyle=None,\n    fillcolor=None,\n    alpha=None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Put the CalendarEvent instance onto an axis.\n\n    Options for kwargs [here](https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html).\n\n    Args:\n        ax: Axis to plot on\n        monday_start: Whether to start the week on Monday or Sunday.\n        lw: The line width of the event.\n        fill: Whether to fill the event.\n        linestyle: The line style of the event.\n        fillcolor: The color of the event.\n        alpha: The alpha of the event.\n        kwargs: Addtional kwargs for the Patch instances or to override.\n\n    \"\"\"\n    for event in self.separate_events():\n        rectangle = event._create_matplotlib_rectangle(\n            monday_start=monday_start,\n            lw=lw,\n            fill=fill,\n            linestyle=linestyle,\n            fillcolor=fillcolor,\n            alpha=alpha,\n            **kwargs,\n        )\n        if \"label\" in kwargs:\n            kwargs.pop(\"label\")\n\n        ax.add_patch(rectangle)\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.CalendarEvent.separate_events","title":"<code>separate_events()</code>","text":"<p>Return list of events that represent the one event across different days.</p> <p>Examples:</p> <p>A single event that goes from 23:00 to 01:00 will be split into two events.</p> <pre><code>event = CalendarEvent(day=0, start=23, duration=2 * 60)\n\nevents = event.separate_events()\n</code></pre> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def separate_events(self) -&gt; list[\"CalendarEvent\"]:\n    \"\"\"Return list of events that represent the one event across different days.\n\n    Examples:\n        A single event that goes from 23:00 to 01:00 will be split into two events.\n\n        ```python\n        event = CalendarEvent(day=0, start=23, duration=2 * 60)\n\n        events = event.separate_events()\n        ```\n\n    \"\"\"\n    event = replace(self)\n    events = [event]\n\n    if event.multiday_tour:\n        events.append(event._create_next_day_event())\n        event._cap_event_at_midnight()\n\n    for event in events:\n        if not event.multiweek_tour:\n            continue\n\n        events.append(event._create_next_week_event())\n        event._cap_event_at_week_end()\n\n    return events\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler","title":"<code>DayLabeler</code>  <code>dataclass</code>","text":"<p>Day of the week axis.</p> <p>This is typically the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>day_start</code> <code>int</code> <p>The day to start the plot at.</p> <code>0</code> <code>days_of_week</code> <code>list[str]</code> <p>The names of the days of the week.</p> <code>create_default_days()</code> <code>rotation</code> <code>float | None</code> <p>The rotation of the day labels.</p> <code>45</code> <code>display</code> <code>bool</code> <p>Whether to display the day labels.</p> <code>True</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass DayLabeler:\n    \"\"\"Day of the week axis.\n\n    This is typically the x-axis.\n\n    Args:\n        day_start: The day to start the plot at.\n        days_of_week: The names of the days of the week.\n        rotation: The rotation of the day labels.\n        display: Whether to display the day labels.\n\n    \"\"\"\n\n    day_start: int = 0\n    days_of_week: list[str] = field(default_factory=create_default_days)\n    rotation: float | None = 45\n    display: bool = True\n\n    def __post_init__(self) -&gt; None:\n        if self.day_start not in range(DAYS_IN_WEEK):\n            msg = \"'day_start' value must be 0: Monday or 6: Sunday\"\n            raise ValueError(msg)\n\n    @property\n    def day_labels(self) -&gt; list[str]:\n        \"\"\"What is added to the plot. If this is display, empty ticks.\"\"\"\n        if not self.display:\n            return [\"\" for _ in range(DAYS_IN_WEEK)]\n\n        return self.days_of_week[self.day_start :] + self.days_of_week[: self.day_start]\n\n    def create_labels(self, ax: plt.Axes, axis: Literal[\"x\", \"y\"] = \"x\") -&gt; None:\n        \"\"\"Create the labels for the plot.\"\"\"\n        getattr(ax, f\"set_{axis}lim\")(0, DAYS_IN_WEEK)\n        getattr(ax, f\"set_{axis}ticks\")(\n            [i + 0.5 for i in range(DAYS_IN_WEEK)],\n            self.day_labels,\n            rotation=self.rotation,\n        )\n\n        if axis == \"y\":\n            ax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler.day_labels","title":"<code>day_labels</code>  <code>property</code>","text":"<p>What is added to the plot. If this is display, empty ticks.</p>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DayLabeler.create_labels","title":"<code>create_labels(ax, axis='x')</code>","text":"<p>Create the labels for the plot.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def create_labels(self, ax: plt.Axes, axis: Literal[\"x\", \"y\"] = \"x\") -&gt; None:\n    \"\"\"Create the labels for the plot.\"\"\"\n    getattr(ax, f\"set_{axis}lim\")(0, DAYS_IN_WEEK)\n    getattr(ax, f\"set_{axis}ticks\")(\n        [i + 0.5 for i in range(DAYS_IN_WEEK)],\n        self.day_labels,\n        rotation=self.rotation,\n    )\n\n    if axis == \"y\":\n        ax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.DisplaySettings","title":"<code>DisplaySettings</code>  <code>dataclass</code>","text":"<p>Small wrapper to hold the display settings in the plots.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>bool</code> <p>Whether to x axis the plot.</p> <code>True</code> <code>y</code> <code>bool</code> <p>Whether to y axis the plot.</p> <code>True</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass DisplaySettings:\n    \"\"\"Small wrapper to hold the display settings in the plots.\n\n    Args:\n        x: Whether to x axis the plot.\n        y: Whether to y axis the plot.\n\n    \"\"\"\n\n    x: bool = True\n    y: bool = True\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.GridLines","title":"<code>GridLines</code>  <code>dataclass</code>","text":"<p>Grid lines between the calendar for the plot.</p> <p>Parameters:</p> Name Type Description Default <code>dow</code> <code>bool</code> <p>Whether to add day of week grid lines.</p> <code>False</code> <code>hour</code> <code>bool</code> <p>Whether to add hour grid lines.</p> <code>False</code> <code>color</code> <code>str</code> <p>The color of the grid lines.</p> <code>'black'</code> <code>linestyle</code> <code>str</code> <p>The style of the grid lines.</p> <code>'--'</code> <code>alpha</code> <code>float</code> <p>The alpha of the grid lines.</p> <code>0.2</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass GridLines:\n    \"\"\"Grid lines between the calendar for the plot.\n\n    Args:\n        dow: Whether to add day of week grid lines.\n        hour: Whether to add hour grid lines.\n        color: The color of the grid lines.\n        linestyle: The style of the grid lines.\n        alpha: The alpha of the grid lines.\n\n    \"\"\"\n\n    dow: bool = False\n    hour: bool = False\n    color: str = \"black\"\n    linestyle: str = \"--\"\n    alpha: float = 0.2\n\n    def configure_grid(self, ax: plt.Axes) -&gt; None:\n        if self.dow:\n            for dow in range(DAYS_IN_WEEK):\n                ax.axvline(\n                    x=dow + 1,\n                    color=self.color,\n                    linestyle=self.linestyle,\n                    alpha=self.alpha,\n                )\n\n        if self.hour:\n            for hour in range(HOURS_IN_DAY):\n                ax.axhline(\n                    y=hour + 1,\n                    color=self.color,\n                    linestyle=self.linestyle,\n                    alpha=self.alpha,\n                )\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.TimeLabeler","title":"<code>TimeLabeler</code>  <code>dataclass</code>","text":"<p>This is time of day and all its settings in the plot.</p> <p>This is typically the y-axis.</p> <p>Parameters:</p> Name Type Description Default <code>hour_formatter</code> <code>HourFormatter</code> <p>The formatter for the hour labels.</p> <code>HourFormatter()</code> <code>start</code> <code>int</code> <p>The hour to start the plot at.</p> <code>0</code> <code>stride</code> <code>int</code> <p>The number of hours to skip between ticks.</p> <code>2</code> <code>display</code> <code>bool</code> <p>Whether to display the hour labels.</p> <code>True</code> <code>rotation</code> <code>float | None</code> <p>The rotation of the hour labels.</p> <code>0</code> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>@dataclass\nclass TimeLabeler:\n    \"\"\"This is time of day and all its settings in the plot.\n\n    This is typically the y-axis.\n\n    Args:\n        hour_formatter: The formatter for the hour labels.\n        start: The hour to start the plot at.\n        stride: The number of hours to skip between ticks.\n        display: Whether to display the hour labels.\n        rotation: The rotation of the hour labels.\n\n    \"\"\"\n\n    hour_formatter: HourFormatter = field(default_factory=HourFormatter)\n    start: int = 0\n    stride: int = 2\n    display: bool = True\n    rotation: float | None = 0\n\n    def get_hours(self) -&gt; tuple[list[int], list[str]]:\n        return range(HOURS_IN_DAY + 1)[:: self.stride]\n\n    def create_labels(self, ax: plt.Axes, axis: Literal[\"x\", \"y\"] = \"y\") -&gt; None:\n        \"\"\"Create the hour labels on the plot ax.\"\"\"\n        hours = self.get_hours()\n        hour_name_func = self.label if self.display else self.empty_label\n        hour_names = hour_name_func(hours)\n\n        getattr(ax, f\"set_{axis}ticks\")(hours, hour_names, rotation=self.rotation)\n        getattr(ax, f\"set_{axis}lim\")(0, HOURS_IN_DAY)\n\n        if axis == \"y\":\n            ax.invert_yaxis()\n\n    def label(self, hrs: list[int]) -&gt; list[str]:\n        return [self.hour_formatter(hr) for hr in hrs]\n\n    def empty_label(self, hrs: list[int]) -&gt; list[str]:\n        return [\"\" for _ in range(len(hrs))]\n</code></pre>"},{"location":"modules/plot/elements/#latent_calendar.plot.elements.TimeLabeler.create_labels","title":"<code>create_labels(ax, axis='y')</code>","text":"<p>Create the hour labels on the plot ax.</p> Source code in <code>latent_calendar/plot/elements.py</code> <pre><code>def create_labels(self, ax: plt.Axes, axis: Literal[\"x\", \"y\"] = \"y\") -&gt; None:\n    \"\"\"Create the hour labels on the plot ax.\"\"\"\n    hours = self.get_hours()\n    hour_name_func = self.label if self.display else self.empty_label\n    hour_names = hour_name_func(hours)\n\n    getattr(ax, f\"set_{axis}ticks\")(hours, hour_names, rotation=self.rotation)\n    getattr(ax, f\"set_{axis}lim\")(0, HOURS_IN_DAY)\n\n    if axis == \"y\":\n        ax.invert_yaxis()\n</code></pre>"},{"location":"modules/plot/grid_settings/","title":"Grid settings","text":""},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.default_plot_axes_in_grid","title":"<code>default_plot_axes_in_grid(nrows, ncols, total=None, day_labeler=None, time_labeler=None)</code>","text":"<p>Additional layer on the display_settings_in_grid in order to modify the settings.</p> <p>Yields:</p> Type Description <code>PlotAxes</code> <p>PlotAxes instance with appropriate display settings based on the position in the grid.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def default_plot_axes_in_grid(\n    nrows: int,\n    ncols: int,\n    total: int | None = None,\n    day_labeler: DayLabeler | None = None,\n    time_labeler: TimeLabeler | None = None,\n) -&gt; Generator[PlotAxes, None, None]:\n    \"\"\"Additional layer on the display_settings_in_grid in order to modify the settings.\n\n    Yields:\n        PlotAxes instance with appropriate display settings based on the position in the grid.\n\n    \"\"\"\n    day_labeler = day_labeler if day_labeler is not None else DayLabeler()\n    default_stride = 2 if nrows &lt;= 2 else 4\n    time_labeler = (\n        time_labeler if time_labeler is not None else TimeLabeler(stride=default_stride)\n    )\n\n    for display_settings in display_settings_in_grid(\n        nrows=nrows, ncols=ncols, total=total\n    ):\n        day_labeler.display = display_settings.x\n        time_labeler.display = display_settings.y\n\n        yield day_labeler, time_labeler\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.display_settings_in_grid","title":"<code>display_settings_in_grid(nrows, ncols, total=None)</code>","text":"<p>Helper for display logic in a grid.</p> <p>Can be used with zip since zip function will stop at the shorts of the iterators</p> <p>Yields:</p> Type Description <code>DisplaySettings</code> <p>DisplaySettings instance with the appropriate settings based on position in the grid.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def display_settings_in_grid(\n    nrows: int,\n    ncols: int,\n    total: int | None = None,\n) -&gt; Generator[DisplaySettings, None, None]:\n    \"\"\"Helper for display logic in a grid.\n\n    Can be used with zip since zip function will stop at the shorts of the iterators\n\n    Yields:\n        DisplaySettings instance with the appropriate settings based on position in the grid.\n\n    \"\"\"\n    total = total if total is not None else nrows * ncols\n\n    yield from (\n        DisplaySettings(\n            x=last_in_column(i, nrows, ncols, total), y=is_left_edge(i, ncols)\n        )\n        for i in range(total)\n    )\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.get_rows_and_cols","title":"<code>get_rows_and_cols(n, max_cols)</code>","text":"<p>Return the number of rows and cols.</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def get_rows_and_cols(n: int, max_cols: int) -&gt; tuple[int, int]:\n    \"\"\"Return the number of rows and cols.\"\"\"\n    nrows = max((n // max_cols) + 1, 1)\n    ncols = min(n, max_cols)\n\n    if n % max_cols == 0:\n        nrows -= 1\n\n    return nrows, ncols\n</code></pre>"},{"location":"modules/plot/grid_settings/#latent_calendar.plot.grid_settings.grid_axes","title":"<code>grid_axes(nrows, ncols, total)</code>","text":"<p>Yields a grid of size nrow, ncols with total cap.</p> <p>Using this instead of plt.subplots(ncols, nrows) and deleting</p> Source code in <code>latent_calendar/plot/grid_settings.py</code> <pre><code>def grid_axes(nrows: int, ncols: int, total: int) -&gt; Generator[plt.Axes, None, None]:\n    \"\"\"Yields a grid of size nrow, ncols with total cap.\n\n    Using this instead of plt.subplots(ncols, nrows) and deleting\n\n    \"\"\"\n    gs = gridspec.GridSpec(nrows, ncols)\n\n    fig = plt.figure()\n\n    yield from (fig.add_subplot(gs[i]) for i in range(total))\n</code></pre>"},{"location":"modules/plot/iterate/","title":"Iterate","text":"<p>Generalize the iteration to support different data formats. Namely,</p> <ul> <li>2d numpy array</li> <li>1d numpy array (long format)</li> <li>pandas Series</li> <li>pandas DataFrame with various columns</li> </ul> <p>This powers the calendar plot and is passed into the <code>plot_calendar</code> function.</p> <p>Examples:</p> <p>Plot calendar based on 1d numpy array.</p> <pre><code>import numpy as np\n\nfrom latent_calendar.plot import plot_calendar\nfrom latent_calendar.plot.iterate import iterate_long_array\n\ndata = np.ones(7 * 24)\nplot_calendar(\n    iterate_long_array(data),\n)\n</code></pre> <p>Plot calendar based on 2d numpy array.</p> <pre><code>from latent_calendar.plot import plot_calendar\n\ndata = np.ones((7, 24))\nplot_calendar(\n    iterate_matrix(data),\n)\n</code></pre> <p>Plot calendar for every half hour instead of every hour. NOTE: This happens automatically!</p> <pre><code>from latent_calendar.plot import plot_calendar\n\ndata = np.ones((7, 24 * 2))\nplot_calendar(\n    iterate_matrix(data),\n)\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.CalendarData","title":"<code>CalendarData</code>  <code>dataclass</code>","text":"<p>All the data that goes into calendar plot.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass CalendarData:\n    \"\"\"All the data that goes into calendar plot.\"\"\"\n\n    day: int\n    start: float\n    end: float\n    value: float\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.IterConfig","title":"<code>IterConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataFrameConfig</code></p> <p>Small wrapper to hold the column mapping in DataFrame.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass IterConfig(DataFrameConfig):\n    \"\"\"Small wrapper to hold the column mapping in DataFrame.\"\"\"\n\n    day: str = \"day_of_week\"\n    start: str = \"hour_start\"\n    end: str = \"hour_end\"\n    value: str = \"value\"\n\n    @property\n    def columns(self) -&gt; list[str]:\n        return [self.day, self.start, self.end]\n\n    def extract_columns(self, df: pd.DataFrame) -&gt; FRAME_ITER:\n        self._check_columns(df)\n        return (\n            df[self.day],\n            df[self.start],\n            df[self.end],\n            self._default_repeat(df, self.value, VALUE_DEFAULT),\n        )\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.VocabIterConfig","title":"<code>VocabIterConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataFrameConfig</code></p> <p>Small wrapper to hold the column mapping in the DataFrame.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>@dataclass\nclass VocabIterConfig(DataFrameConfig):\n    \"\"\"Small wrapper to hold the column mapping in the DataFrame.\"\"\"\n\n    vocab: str = \"vocab\"\n    value: str = \"value\"\n\n    @property\n    def columns(self) -&gt; list[str]:\n        return [self.vocab]\n\n    def extract_columns(self, df: pd.DataFrame) -&gt; FRAME_ITER:\n        self._check_columns(df)\n\n        day = df[self.vocab].str.split(\" \").apply(lambda x: int(x[0]))\n        start = df[self.vocab].str.split(\" \").apply(lambda x: int(x[1]))\n\n        return (\n            day,\n            start,\n            start + 1,\n            self._default_repeat(df, self.value, VALUE_DEFAULT),\n        )\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.iterate_dataframe","title":"<code>iterate_dataframe(df, config)</code>","text":"<p>Iterate the calendar data in DataFrame form based on config.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame with calendar data.</p> required <code>config</code> <code>DataFrameConfig</code> <p>Configuration to describe what columns to use.</p> required Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>def iterate_dataframe(\n    df: pd.DataFrame,\n    config: DataFrameConfig,\n) -&gt; CALENDAR_ITERATION:\n    \"\"\"Iterate the calendar data in DataFrame form based on config.\n\n    Args:\n        df: DataFrame with calendar data.\n        config: Configuration to describe what columns to use.\n\n    \"\"\"\n    for values in zip(*config.extract_columns(df)):\n        yield CalendarData(*values)\n</code></pre>"},{"location":"modules/plot/iterate/#latent_calendar.plot.iterate.iterate_matrix","title":"<code>iterate_matrix(calendar_data)</code>","text":"<p>Iterates the calendar matrix of values.</p> Source code in <code>latent_calendar/plot/iterate.py</code> <pre><code>def iterate_matrix(calendar_data: np.ndarray) -&gt; CALENDAR_ITERATION:\n    \"\"\"Iterates the calendar matrix of values.\"\"\"\n    if calendar_data.ndim != 2:\n        raise ValueError(f\"Data must be 2d not of shape {calendar_data.shape}\")\n\n    n_days, n_hours = calendar_data.shape\n\n    if n_days != DAYS_IN_WEEK:\n        raise ValueError(f\"Data must have {DAYS_IN_WEEK} days not {n_days}\")\n\n    step_size = HOURS_IN_DAY / n_hours\n\n    for day, hours in enumerate(calendar_data):\n        for hour, value in enumerate(hours):\n            start = hour * step_size\n            end = start + step_size\n            yield CalendarData(day, start, end, value)\n</code></pre>"}]}